"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.se_GetRoutesCommand = exports.se_GetRouteResponsesCommand = exports.se_GetRouteResponseCommand = exports.se_GetRouteCommand = exports.se_GetModelTemplateCommand = exports.se_GetModelsCommand = exports.se_GetModelCommand = exports.se_GetIntegrationsCommand = exports.se_GetIntegrationResponsesCommand = exports.se_GetIntegrationResponseCommand = exports.se_GetIntegrationCommand = exports.se_GetDomainNamesCommand = exports.se_GetDomainNameCommand = exports.se_GetDeploymentsCommand = exports.se_GetDeploymentCommand = exports.se_GetAuthorizersCommand = exports.se_GetAuthorizerCommand = exports.se_GetApisCommand = exports.se_GetApiMappingsCommand = exports.se_GetApiMappingCommand = exports.se_GetApiCommand = exports.se_ExportApiCommand = exports.se_DeleteVpcLinkCommand = exports.se_DeleteStageCommand = exports.se_DeleteRouteSettingsCommand = exports.se_DeleteRouteResponseCommand = exports.se_DeleteRouteRequestParameterCommand = exports.se_DeleteRouteCommand = exports.se_DeleteModelCommand = exports.se_DeleteIntegrationResponseCommand = exports.se_DeleteIntegrationCommand = exports.se_DeleteDomainNameCommand = exports.se_DeleteDeploymentCommand = exports.se_DeleteCorsConfigurationCommand = exports.se_DeleteAuthorizerCommand = exports.se_DeleteApiMappingCommand = exports.se_DeleteApiCommand = exports.se_DeleteAccessLogSettingsCommand = exports.se_CreateVpcLinkCommand = exports.se_CreateStageCommand = exports.se_CreateRouteResponseCommand = exports.se_CreateRouteCommand = exports.se_CreateModelCommand = exports.se_CreateIntegrationResponseCommand = exports.se_CreateIntegrationCommand = exports.se_CreateDomainNameCommand = exports.se_CreateDeploymentCommand = exports.se_CreateAuthorizerCommand = exports.se_CreateApiMappingCommand = exports.se_CreateApiCommand = void 0;
exports.de_DeleteVpcLinkCommand = exports.de_DeleteStageCommand = exports.de_DeleteRouteSettingsCommand = exports.de_DeleteRouteResponseCommand = exports.de_DeleteRouteRequestParameterCommand = exports.de_DeleteRouteCommand = exports.de_DeleteModelCommand = exports.de_DeleteIntegrationResponseCommand = exports.de_DeleteIntegrationCommand = exports.de_DeleteDomainNameCommand = exports.de_DeleteDeploymentCommand = exports.de_DeleteCorsConfigurationCommand = exports.de_DeleteAuthorizerCommand = exports.de_DeleteApiMappingCommand = exports.de_DeleteApiCommand = exports.de_DeleteAccessLogSettingsCommand = exports.de_CreateVpcLinkCommand = exports.de_CreateStageCommand = exports.de_CreateRouteResponseCommand = exports.de_CreateRouteCommand = exports.de_CreateModelCommand = exports.de_CreateIntegrationResponseCommand = exports.de_CreateIntegrationCommand = exports.de_CreateDomainNameCommand = exports.de_CreateDeploymentCommand = exports.de_CreateAuthorizerCommand = exports.de_CreateApiMappingCommand = exports.de_CreateApiCommand = exports.se_UpdateVpcLinkCommand = exports.se_UpdateStageCommand = exports.se_UpdateRouteResponseCommand = exports.se_UpdateRouteCommand = exports.se_UpdateModelCommand = exports.se_UpdateIntegrationResponseCommand = exports.se_UpdateIntegrationCommand = exports.se_UpdateDomainNameCommand = exports.se_UpdateDeploymentCommand = exports.se_UpdateAuthorizerCommand = exports.se_UpdateApiMappingCommand = exports.se_UpdateApiCommand = exports.se_UntagResourceCommand = exports.se_TagResourceCommand = exports.se_ResetAuthorizersCacheCommand = exports.se_ReimportApiCommand = exports.se_ImportApiCommand = exports.se_GetVpcLinksCommand = exports.se_GetVpcLinkCommand = exports.se_GetTagsCommand = exports.se_GetStagesCommand = exports.se_GetStageCommand = void 0;
exports.de_UpdateVpcLinkCommand = exports.de_UpdateStageCommand = exports.de_UpdateRouteResponseCommand = exports.de_UpdateRouteCommand = exports.de_UpdateModelCommand = exports.de_UpdateIntegrationResponseCommand = exports.de_UpdateIntegrationCommand = exports.de_UpdateDomainNameCommand = exports.de_UpdateDeploymentCommand = exports.de_UpdateAuthorizerCommand = exports.de_UpdateApiMappingCommand = exports.de_UpdateApiCommand = exports.de_UntagResourceCommand = exports.de_TagResourceCommand = exports.de_ResetAuthorizersCacheCommand = exports.de_ReimportApiCommand = exports.de_ImportApiCommand = exports.de_GetVpcLinksCommand = exports.de_GetVpcLinkCommand = exports.de_GetTagsCommand = exports.de_GetStagesCommand = exports.de_GetStageCommand = exports.de_GetRoutesCommand = exports.de_GetRouteResponsesCommand = exports.de_GetRouteResponseCommand = exports.de_GetRouteCommand = exports.de_GetModelTemplateCommand = exports.de_GetModelsCommand = exports.de_GetModelCommand = exports.de_GetIntegrationsCommand = exports.de_GetIntegrationResponsesCommand = exports.de_GetIntegrationResponseCommand = exports.de_GetIntegrationCommand = exports.de_GetDomainNamesCommand = exports.de_GetDomainNameCommand = exports.de_GetDeploymentsCommand = exports.de_GetDeploymentCommand = exports.de_GetAuthorizersCommand = exports.de_GetAuthorizerCommand = exports.de_GetApisCommand = exports.de_GetApiMappingsCommand = exports.de_GetApiMappingCommand = exports.de_GetApiCommand = exports.de_ExportApiCommand = void 0;
const protocol_http_1 = require("@smithy/protocol-http");
const smithy_client_1 = require("@smithy/smithy-client");
const ApiGatewayV2ServiceException_1 = require("../models/ApiGatewayV2ServiceException");
const models_0_1 = require("../models/models_0");
const se_CreateApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        apiKeySelectionExpression: [, , `ApiKeySelectionExpression`],
        corsConfiguration: [, (_) => se_Cors(_, context), `CorsConfiguration`],
        credentialsArn: [, , `CredentialsArn`],
        description: [, , `Description`],
        disableExecuteApiEndpoint: [, , `DisableExecuteApiEndpoint`],
        disableSchemaValidation: [, , `DisableSchemaValidation`],
        name: [, , `Name`],
        protocolType: [, , `ProtocolType`],
        routeKey: [, , `RouteKey`],
        routeSelectionExpression: [, , `RouteSelectionExpression`],
        tags: [, (_) => (0, smithy_client_1._json)(_), `Tags`],
        target: [, , `Target`],
        version: [, , `Version`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateApiCommand = se_CreateApiCommand;
const se_CreateApiMappingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/domainnames/{DomainName}/apimappings";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        apiId: [, , `ApiId`],
        apiMappingKey: [, , `ApiMappingKey`],
        stage: [, , `Stage`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateApiMappingCommand = se_CreateApiMappingCommand;
const se_CreateAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/authorizers";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        authorizerCredentialsArn: [, , `AuthorizerCredentialsArn`],
        authorizerPayloadFormatVersion: [, , `AuthorizerPayloadFormatVersion`],
        authorizerResultTtlInSeconds: [, , `AuthorizerResultTtlInSeconds`],
        authorizerType: [, , `AuthorizerType`],
        authorizerUri: [, , `AuthorizerUri`],
        enableSimpleResponses: [, , `EnableSimpleResponses`],
        identitySource: [, (_) => (0, smithy_client_1._json)(_), `IdentitySource`],
        identityValidationExpression: [, , `IdentityValidationExpression`],
        jwtConfiguration: [, (_) => se_JWTConfiguration(_, context), `JwtConfiguration`],
        name: [, , `Name`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateAuthorizerCommand = se_CreateAuthorizerCommand;
const se_CreateDeploymentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/deployments";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        description: [, , `Description`],
        stageName: [, , `StageName`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateDeploymentCommand = se_CreateDeploymentCommand;
const se_CreateDomainNameCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/domainnames";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        domainName: [, , `DomainName`],
        domainNameConfigurations: [, (_) => se_DomainNameConfigurations(_, context), `DomainNameConfigurations`],
        mutualTlsAuthentication: [, (_) => se_MutualTlsAuthenticationInput(_, context), `MutualTlsAuthentication`],
        tags: [, (_) => (0, smithy_client_1._json)(_), `Tags`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateDomainNameCommand = se_CreateDomainNameCommand;
const se_CreateIntegrationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/integrations";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        connectionId: [, , `ConnectionId`],
        connectionType: [, , `ConnectionType`],
        contentHandlingStrategy: [, , `ContentHandlingStrategy`],
        credentialsArn: [, , `CredentialsArn`],
        description: [, , `Description`],
        integrationMethod: [, , `IntegrationMethod`],
        integrationSubtype: [, , `IntegrationSubtype`],
        integrationType: [, , `IntegrationType`],
        integrationUri: [, , `IntegrationUri`],
        passthroughBehavior: [, , `PassthroughBehavior`],
        payloadFormatVersion: [, , `PayloadFormatVersion`],
        requestParameters: [, (_) => (0, smithy_client_1._json)(_), `RequestParameters`],
        requestTemplates: [, (_) => (0, smithy_client_1._json)(_), `RequestTemplates`],
        responseParameters: [, (_) => (0, smithy_client_1._json)(_), `ResponseParameters`],
        templateSelectionExpression: [, , `TemplateSelectionExpression`],
        timeoutInMillis: [, , `TimeoutInMillis`],
        tlsConfig: [, (_) => se_TlsConfigInput(_, context), `TlsConfig`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateIntegrationCommand = se_CreateIntegrationCommand;
const se_CreateIntegrationResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/integrations/{IntegrationId}/integrationresponses";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "IntegrationId", () => input.IntegrationId, "{IntegrationId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        contentHandlingStrategy: [, , `ContentHandlingStrategy`],
        integrationResponseKey: [, , `IntegrationResponseKey`],
        responseParameters: [, (_) => (0, smithy_client_1._json)(_), `ResponseParameters`],
        responseTemplates: [, (_) => (0, smithy_client_1._json)(_), `ResponseTemplates`],
        templateSelectionExpression: [, , `TemplateSelectionExpression`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateIntegrationResponseCommand = se_CreateIntegrationResponseCommand;
const se_CreateModelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/models";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        contentType: [, , `ContentType`],
        description: [, , `Description`],
        name: [, , `Name`],
        schema: [, , `Schema`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateModelCommand = se_CreateModelCommand;
const se_CreateRouteCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/routes";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        apiKeyRequired: [, , `ApiKeyRequired`],
        authorizationScopes: [, (_) => (0, smithy_client_1._json)(_), `AuthorizationScopes`],
        authorizationType: [, , `AuthorizationType`],
        authorizerId: [, , `AuthorizerId`],
        modelSelectionExpression: [, , `ModelSelectionExpression`],
        operationName: [, , `OperationName`],
        requestModels: [, (_) => (0, smithy_client_1._json)(_), `RequestModels`],
        requestParameters: [, (_) => se_RouteParameters(_, context), `RequestParameters`],
        routeKey: [, , `RouteKey`],
        routeResponseSelectionExpression: [, , `RouteResponseSelectionExpression`],
        target: [, , `Target`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateRouteCommand = se_CreateRouteCommand;
const se_CreateRouteResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/routes/{RouteId}/routeresponses";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        modelSelectionExpression: [, , `ModelSelectionExpression`],
        responseModels: [, (_) => (0, smithy_client_1._json)(_), `ResponseModels`],
        responseParameters: [, (_) => se_RouteParameters(_, context), `ResponseParameters`],
        routeResponseKey: [, , `RouteResponseKey`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateRouteResponseCommand = se_CreateRouteResponseCommand;
const se_CreateStageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/stages";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        accessLogSettings: [, (_) => se_AccessLogSettings(_, context), `AccessLogSettings`],
        autoDeploy: [, , `AutoDeploy`],
        clientCertificateId: [, , `ClientCertificateId`],
        defaultRouteSettings: [, (_) => se_RouteSettings(_, context), `DefaultRouteSettings`],
        deploymentId: [, , `DeploymentId`],
        description: [, , `Description`],
        routeSettings: [, (_) => se_RouteSettingsMap(_, context), `RouteSettings`],
        stageName: [, , `StageName`],
        stageVariables: [, (_) => (0, smithy_client_1._json)(_), `StageVariables`],
        tags: [, (_) => (0, smithy_client_1._json)(_), `Tags`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateStageCommand = se_CreateStageCommand;
const se_CreateVpcLinkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/vpclinks";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        name: [, , `Name`],
        securityGroupIds: [, (_) => (0, smithy_client_1._json)(_), `SecurityGroupIds`],
        subnetIds: [, (_) => (0, smithy_client_1._json)(_), `SubnetIds`],
        tags: [, (_) => (0, smithy_client_1._json)(_), `Tags`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateVpcLinkCommand = se_CreateVpcLinkCommand;
const se_DeleteAccessLogSettingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/stages/{StageName}/accesslogsettings";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "StageName", () => input.StageName, "{StageName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteAccessLogSettingsCommand = se_DeleteAccessLogSettingsCommand;
const se_DeleteApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteApiCommand = se_DeleteApiCommand;
const se_DeleteApiMappingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/domainnames/{DomainName}/apimappings/{ApiMappingId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiMappingId", () => input.ApiMappingId, "{ApiMappingId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteApiMappingCommand = se_DeleteApiMappingCommand;
const se_DeleteAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/authorizers/{AuthorizerId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "AuthorizerId", () => input.AuthorizerId, "{AuthorizerId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteAuthorizerCommand = se_DeleteAuthorizerCommand;
const se_DeleteCorsConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/cors";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteCorsConfigurationCommand = se_DeleteCorsConfigurationCommand;
const se_DeleteDeploymentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/deployments/{DeploymentId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "DeploymentId", () => input.DeploymentId, "{DeploymentId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteDeploymentCommand = se_DeleteDeploymentCommand;
const se_DeleteDomainNameCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/domainnames/{DomainName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteDomainNameCommand = se_DeleteDomainNameCommand;
const se_DeleteIntegrationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/integrations/{IntegrationId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "IntegrationId", () => input.IntegrationId, "{IntegrationId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteIntegrationCommand = se_DeleteIntegrationCommand;
const se_DeleteIntegrationResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/integrations/{IntegrationId}/integrationresponses/{IntegrationResponseId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "IntegrationId", () => input.IntegrationId, "{IntegrationId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "IntegrationResponseId", () => input.IntegrationResponseId, "{IntegrationResponseId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteIntegrationResponseCommand = se_DeleteIntegrationResponseCommand;
const se_DeleteModelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/models/{ModelId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ModelId", () => input.ModelId, "{ModelId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteModelCommand = se_DeleteModelCommand;
const se_DeleteRouteCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/routes/{RouteId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteRouteCommand = se_DeleteRouteCommand;
const se_DeleteRouteRequestParameterCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/routes/{RouteId}/requestparameters/{RequestParameterKey}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "RequestParameterKey", () => input.RequestParameterKey, "{RequestParameterKey}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteRouteRequestParameterCommand = se_DeleteRouteRequestParameterCommand;
const se_DeleteRouteResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/routes/{RouteId}/routeresponses/{RouteResponseId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "RouteResponseId", () => input.RouteResponseId, "{RouteResponseId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteRouteResponseCommand = se_DeleteRouteResponseCommand;
const se_DeleteRouteSettingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/stages/{StageName}/routesettings/{RouteKey}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "RouteKey", () => input.RouteKey, "{RouteKey}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "StageName", () => input.StageName, "{StageName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteRouteSettingsCommand = se_DeleteRouteSettingsCommand;
const se_DeleteStageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/stages/{StageName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "StageName", () => input.StageName, "{StageName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteStageCommand = se_DeleteStageCommand;
const se_DeleteVpcLinkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/vpclinks/{VpcLinkId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "VpcLinkId", () => input.VpcLinkId, "{VpcLinkId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteVpcLinkCommand = se_DeleteVpcLinkCommand;
const se_ExportApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/exports/{Specification}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Specification", () => input.Specification, "{Specification}", false);
    const query = (0, smithy_client_1.map)({
        exportVersion: [, input.ExportVersion],
        includeExtensions: [() => input.IncludeExtensions !== void 0, () => input.IncludeExtensions.toString()],
        outputType: [, (0, smithy_client_1.expectNonNull)(input.OutputType, `OutputType`)],
        stageName: [, input.StageName],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ExportApiCommand = se_ExportApiCommand;
const se_GetApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetApiCommand = se_GetApiCommand;
const se_GetApiMappingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/domainnames/{DomainName}/apimappings/{ApiMappingId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiMappingId", () => input.ApiMappingId, "{ApiMappingId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetApiMappingCommand = se_GetApiMappingCommand;
const se_GetApiMappingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/domainnames/{DomainName}/apimappings";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    const query = (0, smithy_client_1.map)({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetApiMappingsCommand = se_GetApiMappingsCommand;
const se_GetApisCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis";
    const query = (0, smithy_client_1.map)({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetApisCommand = se_GetApisCommand;
const se_GetAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/authorizers/{AuthorizerId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "AuthorizerId", () => input.AuthorizerId, "{AuthorizerId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetAuthorizerCommand = se_GetAuthorizerCommand;
const se_GetAuthorizersCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/authorizers";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    const query = (0, smithy_client_1.map)({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetAuthorizersCommand = se_GetAuthorizersCommand;
const se_GetDeploymentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/deployments/{DeploymentId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "DeploymentId", () => input.DeploymentId, "{DeploymentId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetDeploymentCommand = se_GetDeploymentCommand;
const se_GetDeploymentsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/deployments";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    const query = (0, smithy_client_1.map)({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetDeploymentsCommand = se_GetDeploymentsCommand;
const se_GetDomainNameCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/domainnames/{DomainName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetDomainNameCommand = se_GetDomainNameCommand;
const se_GetDomainNamesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/domainnames";
    const query = (0, smithy_client_1.map)({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetDomainNamesCommand = se_GetDomainNamesCommand;
const se_GetIntegrationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/integrations/{IntegrationId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "IntegrationId", () => input.IntegrationId, "{IntegrationId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetIntegrationCommand = se_GetIntegrationCommand;
const se_GetIntegrationResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/integrations/{IntegrationId}/integrationresponses/{IntegrationResponseId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "IntegrationId", () => input.IntegrationId, "{IntegrationId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "IntegrationResponseId", () => input.IntegrationResponseId, "{IntegrationResponseId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetIntegrationResponseCommand = se_GetIntegrationResponseCommand;
const se_GetIntegrationResponsesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/integrations/{IntegrationId}/integrationresponses";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "IntegrationId", () => input.IntegrationId, "{IntegrationId}", false);
    const query = (0, smithy_client_1.map)({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetIntegrationResponsesCommand = se_GetIntegrationResponsesCommand;
const se_GetIntegrationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/integrations";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    const query = (0, smithy_client_1.map)({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetIntegrationsCommand = se_GetIntegrationsCommand;
const se_GetModelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/models/{ModelId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ModelId", () => input.ModelId, "{ModelId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetModelCommand = se_GetModelCommand;
const se_GetModelsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/models";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    const query = (0, smithy_client_1.map)({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetModelsCommand = se_GetModelsCommand;
const se_GetModelTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/models/{ModelId}/template";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ModelId", () => input.ModelId, "{ModelId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetModelTemplateCommand = se_GetModelTemplateCommand;
const se_GetRouteCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/routes/{RouteId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetRouteCommand = se_GetRouteCommand;
const se_GetRouteResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/routes/{RouteId}/routeresponses/{RouteResponseId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "RouteResponseId", () => input.RouteResponseId, "{RouteResponseId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetRouteResponseCommand = se_GetRouteResponseCommand;
const se_GetRouteResponsesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/routes/{RouteId}/routeresponses";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    const query = (0, smithy_client_1.map)({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetRouteResponsesCommand = se_GetRouteResponsesCommand;
const se_GetRoutesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/routes";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    const query = (0, smithy_client_1.map)({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetRoutesCommand = se_GetRoutesCommand;
const se_GetStageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/stages/{StageName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "StageName", () => input.StageName, "{StageName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetStageCommand = se_GetStageCommand;
const se_GetStagesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/stages";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    const query = (0, smithy_client_1.map)({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetStagesCommand = se_GetStagesCommand;
const se_GetTagsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/tags/{ResourceArn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetTagsCommand = se_GetTagsCommand;
const se_GetVpcLinkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/vpclinks/{VpcLinkId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "VpcLinkId", () => input.VpcLinkId, "{VpcLinkId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetVpcLinkCommand = se_GetVpcLinkCommand;
const se_GetVpcLinksCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/vpclinks";
    const query = (0, smithy_client_1.map)({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetVpcLinksCommand = se_GetVpcLinksCommand;
const se_ImportApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis";
    const query = (0, smithy_client_1.map)({
        basepath: [, input.Basepath],
        failOnWarnings: [() => input.FailOnWarnings !== void 0, () => input.FailOnWarnings.toString()],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        body: [, , `Body`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ImportApiCommand = se_ImportApiCommand;
const se_ReimportApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    const query = (0, smithy_client_1.map)({
        basepath: [, input.Basepath],
        failOnWarnings: [() => input.FailOnWarnings !== void 0, () => input.FailOnWarnings.toString()],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        body: [, , `Body`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ReimportApiCommand = se_ReimportApiCommand;
const se_ResetAuthorizersCacheCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/stages/{StageName}/cache/authorizers";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "StageName", () => input.StageName, "{StageName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_ResetAuthorizersCacheCommand = se_ResetAuthorizersCacheCommand;
const se_TagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/tags/{ResourceArn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        tags: [, (_) => (0, smithy_client_1._json)(_), `Tags`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_TagResourceCommand = se_TagResourceCommand;
const se_UntagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/tags/{ResourceArn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    const query = (0, smithy_client_1.map)({
        tagKeys: [
            (0, smithy_client_1.expectNonNull)(input.TagKeys, `TagKeys`) != null,
            () => (input.TagKeys || []).map((_entry) => _entry),
        ],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_UntagResourceCommand = se_UntagResourceCommand;
const se_UpdateApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        apiKeySelectionExpression: [, , `ApiKeySelectionExpression`],
        corsConfiguration: [, (_) => se_Cors(_, context), `CorsConfiguration`],
        credentialsArn: [, , `CredentialsArn`],
        description: [, , `Description`],
        disableExecuteApiEndpoint: [, , `DisableExecuteApiEndpoint`],
        disableSchemaValidation: [, , `DisableSchemaValidation`],
        name: [, , `Name`],
        routeKey: [, , `RouteKey`],
        routeSelectionExpression: [, , `RouteSelectionExpression`],
        target: [, , `Target`],
        version: [, , `Version`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateApiCommand = se_UpdateApiCommand;
const se_UpdateApiMappingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/domainnames/{DomainName}/apimappings/{ApiMappingId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiMappingId", () => input.ApiMappingId, "{ApiMappingId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        apiId: [, , `ApiId`],
        apiMappingKey: [, , `ApiMappingKey`],
        stage: [, , `Stage`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateApiMappingCommand = se_UpdateApiMappingCommand;
const se_UpdateAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/authorizers/{AuthorizerId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "AuthorizerId", () => input.AuthorizerId, "{AuthorizerId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        authorizerCredentialsArn: [, , `AuthorizerCredentialsArn`],
        authorizerPayloadFormatVersion: [, , `AuthorizerPayloadFormatVersion`],
        authorizerResultTtlInSeconds: [, , `AuthorizerResultTtlInSeconds`],
        authorizerType: [, , `AuthorizerType`],
        authorizerUri: [, , `AuthorizerUri`],
        enableSimpleResponses: [, , `EnableSimpleResponses`],
        identitySource: [, (_) => (0, smithy_client_1._json)(_), `IdentitySource`],
        identityValidationExpression: [, , `IdentityValidationExpression`],
        jwtConfiguration: [, (_) => se_JWTConfiguration(_, context), `JwtConfiguration`],
        name: [, , `Name`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateAuthorizerCommand = se_UpdateAuthorizerCommand;
const se_UpdateDeploymentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/deployments/{DeploymentId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "DeploymentId", () => input.DeploymentId, "{DeploymentId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        description: [, , `Description`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateDeploymentCommand = se_UpdateDeploymentCommand;
const se_UpdateDomainNameCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/domainnames/{DomainName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        domainNameConfigurations: [, (_) => se_DomainNameConfigurations(_, context), `DomainNameConfigurations`],
        mutualTlsAuthentication: [, (_) => se_MutualTlsAuthenticationInput(_, context), `MutualTlsAuthentication`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateDomainNameCommand = se_UpdateDomainNameCommand;
const se_UpdateIntegrationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/integrations/{IntegrationId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "IntegrationId", () => input.IntegrationId, "{IntegrationId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        connectionId: [, , `ConnectionId`],
        connectionType: [, , `ConnectionType`],
        contentHandlingStrategy: [, , `ContentHandlingStrategy`],
        credentialsArn: [, , `CredentialsArn`],
        description: [, , `Description`],
        integrationMethod: [, , `IntegrationMethod`],
        integrationSubtype: [, , `IntegrationSubtype`],
        integrationType: [, , `IntegrationType`],
        integrationUri: [, , `IntegrationUri`],
        passthroughBehavior: [, , `PassthroughBehavior`],
        payloadFormatVersion: [, , `PayloadFormatVersion`],
        requestParameters: [, (_) => (0, smithy_client_1._json)(_), `RequestParameters`],
        requestTemplates: [, (_) => (0, smithy_client_1._json)(_), `RequestTemplates`],
        responseParameters: [, (_) => (0, smithy_client_1._json)(_), `ResponseParameters`],
        templateSelectionExpression: [, , `TemplateSelectionExpression`],
        timeoutInMillis: [, , `TimeoutInMillis`],
        tlsConfig: [, (_) => se_TlsConfigInput(_, context), `TlsConfig`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateIntegrationCommand = se_UpdateIntegrationCommand;
const se_UpdateIntegrationResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/integrations/{IntegrationId}/integrationresponses/{IntegrationResponseId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "IntegrationId", () => input.IntegrationId, "{IntegrationId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "IntegrationResponseId", () => input.IntegrationResponseId, "{IntegrationResponseId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        contentHandlingStrategy: [, , `ContentHandlingStrategy`],
        integrationResponseKey: [, , `IntegrationResponseKey`],
        responseParameters: [, (_) => (0, smithy_client_1._json)(_), `ResponseParameters`],
        responseTemplates: [, (_) => (0, smithy_client_1._json)(_), `ResponseTemplates`],
        templateSelectionExpression: [, , `TemplateSelectionExpression`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateIntegrationResponseCommand = se_UpdateIntegrationResponseCommand;
const se_UpdateModelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/models/{ModelId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ModelId", () => input.ModelId, "{ModelId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        contentType: [, , `ContentType`],
        description: [, , `Description`],
        name: [, , `Name`],
        schema: [, , `Schema`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateModelCommand = se_UpdateModelCommand;
const se_UpdateRouteCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/routes/{RouteId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        apiKeyRequired: [, , `ApiKeyRequired`],
        authorizationScopes: [, (_) => (0, smithy_client_1._json)(_), `AuthorizationScopes`],
        authorizationType: [, , `AuthorizationType`],
        authorizerId: [, , `AuthorizerId`],
        modelSelectionExpression: [, , `ModelSelectionExpression`],
        operationName: [, , `OperationName`],
        requestModels: [, (_) => (0, smithy_client_1._json)(_), `RequestModels`],
        requestParameters: [, (_) => se_RouteParameters(_, context), `RequestParameters`],
        routeKey: [, , `RouteKey`],
        routeResponseSelectionExpression: [, , `RouteResponseSelectionExpression`],
        target: [, , `Target`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateRouteCommand = se_UpdateRouteCommand;
const se_UpdateRouteResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/routes/{RouteId}/routeresponses/{RouteResponseId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "RouteResponseId", () => input.RouteResponseId, "{RouteResponseId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        modelSelectionExpression: [, , `ModelSelectionExpression`],
        responseModels: [, (_) => (0, smithy_client_1._json)(_), `ResponseModels`],
        responseParameters: [, (_) => se_RouteParameters(_, context), `ResponseParameters`],
        routeResponseKey: [, , `RouteResponseKey`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateRouteResponseCommand = se_UpdateRouteResponseCommand;
const se_UpdateStageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/stages/{StageName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "StageName", () => input.StageName, "{StageName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        accessLogSettings: [, (_) => se_AccessLogSettings(_, context), `AccessLogSettings`],
        autoDeploy: [, , `AutoDeploy`],
        clientCertificateId: [, , `ClientCertificateId`],
        defaultRouteSettings: [, (_) => se_RouteSettings(_, context), `DefaultRouteSettings`],
        deploymentId: [, , `DeploymentId`],
        description: [, , `Description`],
        routeSettings: [, (_) => se_RouteSettingsMap(_, context), `RouteSettings`],
        stageVariables: [, (_) => (0, smithy_client_1._json)(_), `StageVariables`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateStageCommand = se_UpdateStageCommand;
const se_UpdateVpcLinkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/vpclinks/{VpcLinkId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "VpcLinkId", () => input.VpcLinkId, "{VpcLinkId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        name: [, , `Name`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateVpcLinkCommand = se_UpdateVpcLinkCommand;
const de_CreateApiCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateApiCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ApiEndpoint: [, smithy_client_1.expectString, `apiEndpoint`],
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        ApiId: [, smithy_client_1.expectString, `apiId`],
        ApiKeySelectionExpression: [, smithy_client_1.expectString, `apiKeySelectionExpression`],
        CorsConfiguration: [, (_) => de_Cors(_, context), `corsConfiguration`],
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        Description: [, smithy_client_1.expectString, `description`],
        DisableExecuteApiEndpoint: [, smithy_client_1.expectBoolean, `disableExecuteApiEndpoint`],
        DisableSchemaValidation: [, smithy_client_1.expectBoolean, `disableSchemaValidation`],
        ImportInfo: [, smithy_client_1._json, `importInfo`],
        Name: [, smithy_client_1.expectString, `name`],
        ProtocolType: [, smithy_client_1.expectString, `protocolType`],
        RouteSelectionExpression: [, smithy_client_1.expectString, `routeSelectionExpression`],
        Tags: [, smithy_client_1._json, `tags`],
        Version: [, smithy_client_1.expectString, `version`],
        Warnings: [, smithy_client_1._json, `warnings`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateApiCommand = de_CreateApiCommand;
const de_CreateApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateApiMappingCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateApiMappingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ApiId: [, smithy_client_1.expectString, `apiId`],
        ApiMappingId: [, smithy_client_1.expectString, `apiMappingId`],
        ApiMappingKey: [, smithy_client_1.expectString, `apiMappingKey`],
        Stage: [, smithy_client_1.expectString, `stage`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateApiMappingCommand = de_CreateApiMappingCommand;
const de_CreateApiMappingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateAuthorizerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        AuthorizerCredentialsArn: [, smithy_client_1.expectString, `authorizerCredentialsArn`],
        AuthorizerId: [, smithy_client_1.expectString, `authorizerId`],
        AuthorizerPayloadFormatVersion: [, smithy_client_1.expectString, `authorizerPayloadFormatVersion`],
        AuthorizerResultTtlInSeconds: [, smithy_client_1.expectInt32, `authorizerResultTtlInSeconds`],
        AuthorizerType: [, smithy_client_1.expectString, `authorizerType`],
        AuthorizerUri: [, smithy_client_1.expectString, `authorizerUri`],
        EnableSimpleResponses: [, smithy_client_1.expectBoolean, `enableSimpleResponses`],
        IdentitySource: [, smithy_client_1._json, `identitySource`],
        IdentityValidationExpression: [, smithy_client_1.expectString, `identityValidationExpression`],
        JwtConfiguration: [, (_) => de_JWTConfiguration(_, context), `jwtConfiguration`],
        Name: [, smithy_client_1.expectString, `name`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateAuthorizerCommand = de_CreateAuthorizerCommand;
const de_CreateAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateDeploymentCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        AutoDeployed: [, smithy_client_1.expectBoolean, `autoDeployed`],
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        DeploymentId: [, smithy_client_1.expectString, `deploymentId`],
        DeploymentStatus: [, smithy_client_1.expectString, `deploymentStatus`],
        DeploymentStatusMessage: [, smithy_client_1.expectString, `deploymentStatusMessage`],
        Description: [, smithy_client_1.expectString, `description`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateDeploymentCommand = de_CreateDeploymentCommand;
const de_CreateDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateDomainNameCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ApiMappingSelectionExpression: [, smithy_client_1.expectString, `apiMappingSelectionExpression`],
        DomainName: [, smithy_client_1.expectString, `domainName`],
        DomainNameConfigurations: [, (_) => de_DomainNameConfigurations(_, context), `domainNameConfigurations`],
        MutualTlsAuthentication: [, (_) => de_MutualTlsAuthentication(_, context), `mutualTlsAuthentication`],
        Tags: [, smithy_client_1._json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateDomainNameCommand = de_CreateDomainNameCommand;
const de_CreateDomainNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.apigatewayv2#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateIntegrationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        ConnectionId: [, smithy_client_1.expectString, `connectionId`],
        ConnectionType: [, smithy_client_1.expectString, `connectionType`],
        ContentHandlingStrategy: [, smithy_client_1.expectString, `contentHandlingStrategy`],
        CredentialsArn: [, smithy_client_1.expectString, `credentialsArn`],
        Description: [, smithy_client_1.expectString, `description`],
        IntegrationId: [, smithy_client_1.expectString, `integrationId`],
        IntegrationMethod: [, smithy_client_1.expectString, `integrationMethod`],
        IntegrationResponseSelectionExpression: [, smithy_client_1.expectString, `integrationResponseSelectionExpression`],
        IntegrationSubtype: [, smithy_client_1.expectString, `integrationSubtype`],
        IntegrationType: [, smithy_client_1.expectString, `integrationType`],
        IntegrationUri: [, smithy_client_1.expectString, `integrationUri`],
        PassthroughBehavior: [, smithy_client_1.expectString, `passthroughBehavior`],
        PayloadFormatVersion: [, smithy_client_1.expectString, `payloadFormatVersion`],
        RequestParameters: [, smithy_client_1._json, `requestParameters`],
        RequestTemplates: [, smithy_client_1._json, `requestTemplates`],
        ResponseParameters: [, smithy_client_1._json, `responseParameters`],
        TemplateSelectionExpression: [, smithy_client_1.expectString, `templateSelectionExpression`],
        TimeoutInMillis: [, smithy_client_1.expectInt32, `timeoutInMillis`],
        TlsConfig: [, (_) => de_TlsConfig(_, context), `tlsConfig`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateIntegrationCommand = de_CreateIntegrationCommand;
const de_CreateIntegrationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateIntegrationResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ContentHandlingStrategy: [, smithy_client_1.expectString, `contentHandlingStrategy`],
        IntegrationResponseId: [, smithy_client_1.expectString, `integrationResponseId`],
        IntegrationResponseKey: [, smithy_client_1.expectString, `integrationResponseKey`],
        ResponseParameters: [, smithy_client_1._json, `responseParameters`],
        ResponseTemplates: [, smithy_client_1._json, `responseTemplates`],
        TemplateSelectionExpression: [, smithy_client_1.expectString, `templateSelectionExpression`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateIntegrationResponseCommand = de_CreateIntegrationResponseCommand;
const de_CreateIntegrationResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateModelCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateModelCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ContentType: [, smithy_client_1.expectString, `contentType`],
        Description: [, smithy_client_1.expectString, `description`],
        ModelId: [, smithy_client_1.expectString, `modelId`],
        Name: [, smithy_client_1.expectString, `name`],
        Schema: [, smithy_client_1.expectString, `schema`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateModelCommand = de_CreateModelCommand;
const de_CreateModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateRouteCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateRouteCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        ApiKeyRequired: [, smithy_client_1.expectBoolean, `apiKeyRequired`],
        AuthorizationScopes: [, smithy_client_1._json, `authorizationScopes`],
        AuthorizationType: [, smithy_client_1.expectString, `authorizationType`],
        AuthorizerId: [, smithy_client_1.expectString, `authorizerId`],
        ModelSelectionExpression: [, smithy_client_1.expectString, `modelSelectionExpression`],
        OperationName: [, smithy_client_1.expectString, `operationName`],
        RequestModels: [, smithy_client_1._json, `requestModels`],
        RequestParameters: [, (_) => de_RouteParameters(_, context), `requestParameters`],
        RouteId: [, smithy_client_1.expectString, `routeId`],
        RouteKey: [, smithy_client_1.expectString, `routeKey`],
        RouteResponseSelectionExpression: [, smithy_client_1.expectString, `routeResponseSelectionExpression`],
        Target: [, smithy_client_1.expectString, `target`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateRouteCommand = de_CreateRouteCommand;
const de_CreateRouteCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateRouteResponseCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateRouteResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ModelSelectionExpression: [, smithy_client_1.expectString, `modelSelectionExpression`],
        ResponseModels: [, smithy_client_1._json, `responseModels`],
        ResponseParameters: [, (_) => de_RouteParameters(_, context), `responseParameters`],
        RouteResponseId: [, smithy_client_1.expectString, `routeResponseId`],
        RouteResponseKey: [, smithy_client_1.expectString, `routeResponseKey`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateRouteResponseCommand = de_CreateRouteResponseCommand;
const de_CreateRouteResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateStageCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateStageCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        AccessLogSettings: [, (_) => de_AccessLogSettings(_, context), `accessLogSettings`],
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        AutoDeploy: [, smithy_client_1.expectBoolean, `autoDeploy`],
        ClientCertificateId: [, smithy_client_1.expectString, `clientCertificateId`],
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        DefaultRouteSettings: [, (_) => de_RouteSettings(_, context), `defaultRouteSettings`],
        DeploymentId: [, smithy_client_1.expectString, `deploymentId`],
        Description: [, smithy_client_1.expectString, `description`],
        LastDeploymentStatusMessage: [, smithy_client_1.expectString, `lastDeploymentStatusMessage`],
        LastUpdatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `lastUpdatedDate`],
        RouteSettings: [, (_) => de_RouteSettingsMap(_, context), `routeSettings`],
        StageName: [, smithy_client_1.expectString, `stageName`],
        StageVariables: [, smithy_client_1._json, `stageVariables`],
        Tags: [, smithy_client_1._json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateStageCommand = de_CreateStageCommand;
const de_CreateStageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateVpcLinkCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        Name: [, smithy_client_1.expectString, `name`],
        SecurityGroupIds: [, smithy_client_1._json, `securityGroupIds`],
        SubnetIds: [, smithy_client_1._json, `subnetIds`],
        Tags: [, smithy_client_1._json, `tags`],
        VpcLinkId: [, smithy_client_1.expectString, `vpcLinkId`],
        VpcLinkStatus: [, smithy_client_1.expectString, `vpcLinkStatus`],
        VpcLinkStatusMessage: [, smithy_client_1.expectString, `vpcLinkStatusMessage`],
        VpcLinkVersion: [, smithy_client_1.expectString, `vpcLinkVersion`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateVpcLinkCommand = de_CreateVpcLinkCommand;
const de_CreateVpcLinkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteAccessLogSettingsCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteAccessLogSettingsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteAccessLogSettingsCommand = de_DeleteAccessLogSettingsCommand;
const de_DeleteAccessLogSettingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteApiCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteApiCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteApiCommand = de_DeleteApiCommand;
const de_DeleteApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteApiMappingCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteApiMappingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteApiMappingCommand = de_DeleteApiMappingCommand;
const de_DeleteApiMappingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteAuthorizerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteAuthorizerCommand = de_DeleteAuthorizerCommand;
const de_DeleteAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteCorsConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteCorsConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteCorsConfigurationCommand = de_DeleteCorsConfigurationCommand;
const de_DeleteCorsConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteDeploymentCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteDeploymentCommand = de_DeleteDeploymentCommand;
const de_DeleteDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteDomainNameCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteDomainNameCommand = de_DeleteDomainNameCommand;
const de_DeleteDomainNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteIntegrationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteIntegrationCommand = de_DeleteIntegrationCommand;
const de_DeleteIntegrationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteIntegrationResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteIntegrationResponseCommand = de_DeleteIntegrationResponseCommand;
const de_DeleteIntegrationResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteModelCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteModelCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteModelCommand = de_DeleteModelCommand;
const de_DeleteModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteRouteCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteRouteCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteRouteCommand = de_DeleteRouteCommand;
const de_DeleteRouteCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteRouteRequestParameterCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteRouteRequestParameterCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteRouteRequestParameterCommand = de_DeleteRouteRequestParameterCommand;
const de_DeleteRouteRequestParameterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteRouteResponseCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteRouteResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteRouteResponseCommand = de_DeleteRouteResponseCommand;
const de_DeleteRouteResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteRouteSettingsCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteRouteSettingsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteRouteSettingsCommand = de_DeleteRouteSettingsCommand;
const de_DeleteRouteSettingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteStageCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteStageCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteStageCommand = de_DeleteStageCommand;
const de_DeleteStageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteVpcLinkCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteVpcLinkCommand = de_DeleteVpcLinkCommand;
const de_DeleteVpcLinkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ExportApiCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ExportApiCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = await (0, smithy_client_1.collectBody)(output.body, context);
    contents.body = data;
    return contents;
};
exports.de_ExportApiCommand = de_ExportApiCommand;
const de_ExportApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetApiCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetApiCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ApiEndpoint: [, smithy_client_1.expectString, `apiEndpoint`],
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        ApiId: [, smithy_client_1.expectString, `apiId`],
        ApiKeySelectionExpression: [, smithy_client_1.expectString, `apiKeySelectionExpression`],
        CorsConfiguration: [, (_) => de_Cors(_, context), `corsConfiguration`],
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        Description: [, smithy_client_1.expectString, `description`],
        DisableExecuteApiEndpoint: [, smithy_client_1.expectBoolean, `disableExecuteApiEndpoint`],
        DisableSchemaValidation: [, smithy_client_1.expectBoolean, `disableSchemaValidation`],
        ImportInfo: [, smithy_client_1._json, `importInfo`],
        Name: [, smithy_client_1.expectString, `name`],
        ProtocolType: [, smithy_client_1.expectString, `protocolType`],
        RouteSelectionExpression: [, smithy_client_1.expectString, `routeSelectionExpression`],
        Tags: [, smithy_client_1._json, `tags`],
        Version: [, smithy_client_1.expectString, `version`],
        Warnings: [, smithy_client_1._json, `warnings`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetApiCommand = de_GetApiCommand;
const de_GetApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetApiMappingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetApiMappingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ApiId: [, smithy_client_1.expectString, `apiId`],
        ApiMappingId: [, smithy_client_1.expectString, `apiMappingId`],
        ApiMappingKey: [, smithy_client_1.expectString, `apiMappingKey`],
        Stage: [, smithy_client_1.expectString, `stage`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetApiMappingCommand = de_GetApiMappingCommand;
const de_GetApiMappingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetApiMappingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetApiMappingsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Items: [, (_) => de___listOfApiMapping(_, context), `items`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetApiMappingsCommand = de_GetApiMappingsCommand;
const de_GetApiMappingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetApisCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetApisCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Items: [, (_) => de___listOfApi(_, context), `items`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetApisCommand = de_GetApisCommand;
const de_GetApisCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAuthorizerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        AuthorizerCredentialsArn: [, smithy_client_1.expectString, `authorizerCredentialsArn`],
        AuthorizerId: [, smithy_client_1.expectString, `authorizerId`],
        AuthorizerPayloadFormatVersion: [, smithy_client_1.expectString, `authorizerPayloadFormatVersion`],
        AuthorizerResultTtlInSeconds: [, smithy_client_1.expectInt32, `authorizerResultTtlInSeconds`],
        AuthorizerType: [, smithy_client_1.expectString, `authorizerType`],
        AuthorizerUri: [, smithy_client_1.expectString, `authorizerUri`],
        EnableSimpleResponses: [, smithy_client_1.expectBoolean, `enableSimpleResponses`],
        IdentitySource: [, smithy_client_1._json, `identitySource`],
        IdentityValidationExpression: [, smithy_client_1.expectString, `identityValidationExpression`],
        JwtConfiguration: [, (_) => de_JWTConfiguration(_, context), `jwtConfiguration`],
        Name: [, smithy_client_1.expectString, `name`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetAuthorizerCommand = de_GetAuthorizerCommand;
const de_GetAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetAuthorizersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAuthorizersCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Items: [, (_) => de___listOfAuthorizer(_, context), `items`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetAuthorizersCommand = de_GetAuthorizersCommand;
const de_GetAuthorizersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDeploymentCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        AutoDeployed: [, smithy_client_1.expectBoolean, `autoDeployed`],
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        DeploymentId: [, smithy_client_1.expectString, `deploymentId`],
        DeploymentStatus: [, smithy_client_1.expectString, `deploymentStatus`],
        DeploymentStatusMessage: [, smithy_client_1.expectString, `deploymentStatusMessage`],
        Description: [, smithy_client_1.expectString, `description`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetDeploymentCommand = de_GetDeploymentCommand;
const de_GetDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDeploymentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDeploymentsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Items: [, (_) => de___listOfDeployment(_, context), `items`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetDeploymentsCommand = de_GetDeploymentsCommand;
const de_GetDeploymentsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDomainNameCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ApiMappingSelectionExpression: [, smithy_client_1.expectString, `apiMappingSelectionExpression`],
        DomainName: [, smithy_client_1.expectString, `domainName`],
        DomainNameConfigurations: [, (_) => de_DomainNameConfigurations(_, context), `domainNameConfigurations`],
        MutualTlsAuthentication: [, (_) => de_MutualTlsAuthentication(_, context), `mutualTlsAuthentication`],
        Tags: [, smithy_client_1._json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetDomainNameCommand = de_GetDomainNameCommand;
const de_GetDomainNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDomainNamesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDomainNamesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Items: [, (_) => de___listOfDomainName(_, context), `items`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetDomainNamesCommand = de_GetDomainNamesCommand;
const de_GetDomainNamesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetIntegrationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        ConnectionId: [, smithy_client_1.expectString, `connectionId`],
        ConnectionType: [, smithy_client_1.expectString, `connectionType`],
        ContentHandlingStrategy: [, smithy_client_1.expectString, `contentHandlingStrategy`],
        CredentialsArn: [, smithy_client_1.expectString, `credentialsArn`],
        Description: [, smithy_client_1.expectString, `description`],
        IntegrationId: [, smithy_client_1.expectString, `integrationId`],
        IntegrationMethod: [, smithy_client_1.expectString, `integrationMethod`],
        IntegrationResponseSelectionExpression: [, smithy_client_1.expectString, `integrationResponseSelectionExpression`],
        IntegrationSubtype: [, smithy_client_1.expectString, `integrationSubtype`],
        IntegrationType: [, smithy_client_1.expectString, `integrationType`],
        IntegrationUri: [, smithy_client_1.expectString, `integrationUri`],
        PassthroughBehavior: [, smithy_client_1.expectString, `passthroughBehavior`],
        PayloadFormatVersion: [, smithy_client_1.expectString, `payloadFormatVersion`],
        RequestParameters: [, smithy_client_1._json, `requestParameters`],
        RequestTemplates: [, smithy_client_1._json, `requestTemplates`],
        ResponseParameters: [, smithy_client_1._json, `responseParameters`],
        TemplateSelectionExpression: [, smithy_client_1.expectString, `templateSelectionExpression`],
        TimeoutInMillis: [, smithy_client_1.expectInt32, `timeoutInMillis`],
        TlsConfig: [, (_) => de_TlsConfig(_, context), `tlsConfig`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetIntegrationCommand = de_GetIntegrationCommand;
const de_GetIntegrationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetIntegrationResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ContentHandlingStrategy: [, smithy_client_1.expectString, `contentHandlingStrategy`],
        IntegrationResponseId: [, smithy_client_1.expectString, `integrationResponseId`],
        IntegrationResponseKey: [, smithy_client_1.expectString, `integrationResponseKey`],
        ResponseParameters: [, smithy_client_1._json, `responseParameters`],
        ResponseTemplates: [, smithy_client_1._json, `responseTemplates`],
        TemplateSelectionExpression: [, smithy_client_1.expectString, `templateSelectionExpression`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetIntegrationResponseCommand = de_GetIntegrationResponseCommand;
const de_GetIntegrationResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetIntegrationResponsesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetIntegrationResponsesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Items: [, (_) => de___listOfIntegrationResponse(_, context), `items`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetIntegrationResponsesCommand = de_GetIntegrationResponsesCommand;
const de_GetIntegrationResponsesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetIntegrationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetIntegrationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Items: [, (_) => de___listOfIntegration(_, context), `items`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetIntegrationsCommand = de_GetIntegrationsCommand;
const de_GetIntegrationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetModelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetModelCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ContentType: [, smithy_client_1.expectString, `contentType`],
        Description: [, smithy_client_1.expectString, `description`],
        ModelId: [, smithy_client_1.expectString, `modelId`],
        Name: [, smithy_client_1.expectString, `name`],
        Schema: [, smithy_client_1.expectString, `schema`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetModelCommand = de_GetModelCommand;
const de_GetModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetModelsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetModelsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Items: [, (_) => de___listOfModel(_, context), `items`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetModelsCommand = de_GetModelsCommand;
const de_GetModelsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetModelTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetModelTemplateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Value: [, smithy_client_1.expectString, `value`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetModelTemplateCommand = de_GetModelTemplateCommand;
const de_GetModelTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetRouteCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRouteCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        ApiKeyRequired: [, smithy_client_1.expectBoolean, `apiKeyRequired`],
        AuthorizationScopes: [, smithy_client_1._json, `authorizationScopes`],
        AuthorizationType: [, smithy_client_1.expectString, `authorizationType`],
        AuthorizerId: [, smithy_client_1.expectString, `authorizerId`],
        ModelSelectionExpression: [, smithy_client_1.expectString, `modelSelectionExpression`],
        OperationName: [, smithy_client_1.expectString, `operationName`],
        RequestModels: [, smithy_client_1._json, `requestModels`],
        RequestParameters: [, (_) => de_RouteParameters(_, context), `requestParameters`],
        RouteId: [, smithy_client_1.expectString, `routeId`],
        RouteKey: [, smithy_client_1.expectString, `routeKey`],
        RouteResponseSelectionExpression: [, smithy_client_1.expectString, `routeResponseSelectionExpression`],
        Target: [, smithy_client_1.expectString, `target`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetRouteCommand = de_GetRouteCommand;
const de_GetRouteCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetRouteResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRouteResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ModelSelectionExpression: [, smithy_client_1.expectString, `modelSelectionExpression`],
        ResponseModels: [, smithy_client_1._json, `responseModels`],
        ResponseParameters: [, (_) => de_RouteParameters(_, context), `responseParameters`],
        RouteResponseId: [, smithy_client_1.expectString, `routeResponseId`],
        RouteResponseKey: [, smithy_client_1.expectString, `routeResponseKey`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetRouteResponseCommand = de_GetRouteResponseCommand;
const de_GetRouteResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetRouteResponsesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRouteResponsesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Items: [, (_) => de___listOfRouteResponse(_, context), `items`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetRouteResponsesCommand = de_GetRouteResponsesCommand;
const de_GetRouteResponsesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetRoutesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRoutesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Items: [, (_) => de___listOfRoute(_, context), `items`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetRoutesCommand = de_GetRoutesCommand;
const de_GetRoutesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetStageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetStageCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        AccessLogSettings: [, (_) => de_AccessLogSettings(_, context), `accessLogSettings`],
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        AutoDeploy: [, smithy_client_1.expectBoolean, `autoDeploy`],
        ClientCertificateId: [, smithy_client_1.expectString, `clientCertificateId`],
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        DefaultRouteSettings: [, (_) => de_RouteSettings(_, context), `defaultRouteSettings`],
        DeploymentId: [, smithy_client_1.expectString, `deploymentId`],
        Description: [, smithy_client_1.expectString, `description`],
        LastDeploymentStatusMessage: [, smithy_client_1.expectString, `lastDeploymentStatusMessage`],
        LastUpdatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `lastUpdatedDate`],
        RouteSettings: [, (_) => de_RouteSettingsMap(_, context), `routeSettings`],
        StageName: [, smithy_client_1.expectString, `stageName`],
        StageVariables: [, smithy_client_1._json, `stageVariables`],
        Tags: [, smithy_client_1._json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetStageCommand = de_GetStageCommand;
const de_GetStageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetStagesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetStagesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Items: [, (_) => de___listOfStage(_, context), `items`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetStagesCommand = de_GetStagesCommand;
const de_GetStagesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetTagsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetTagsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Tags: [, smithy_client_1._json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetTagsCommand = de_GetTagsCommand;
const de_GetTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetVpcLinkCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        Name: [, smithy_client_1.expectString, `name`],
        SecurityGroupIds: [, smithy_client_1._json, `securityGroupIds`],
        SubnetIds: [, smithy_client_1._json, `subnetIds`],
        Tags: [, smithy_client_1._json, `tags`],
        VpcLinkId: [, smithy_client_1.expectString, `vpcLinkId`],
        VpcLinkStatus: [, smithy_client_1.expectString, `vpcLinkStatus`],
        VpcLinkStatusMessage: [, smithy_client_1.expectString, `vpcLinkStatusMessage`],
        VpcLinkVersion: [, smithy_client_1.expectString, `vpcLinkVersion`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetVpcLinkCommand = de_GetVpcLinkCommand;
const de_GetVpcLinkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetVpcLinksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetVpcLinksCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Items: [, (_) => de___listOfVpcLink(_, context), `items`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetVpcLinksCommand = de_GetVpcLinksCommand;
const de_GetVpcLinksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ImportApiCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_ImportApiCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ApiEndpoint: [, smithy_client_1.expectString, `apiEndpoint`],
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        ApiId: [, smithy_client_1.expectString, `apiId`],
        ApiKeySelectionExpression: [, smithy_client_1.expectString, `apiKeySelectionExpression`],
        CorsConfiguration: [, (_) => de_Cors(_, context), `corsConfiguration`],
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        Description: [, smithy_client_1.expectString, `description`],
        DisableExecuteApiEndpoint: [, smithy_client_1.expectBoolean, `disableExecuteApiEndpoint`],
        DisableSchemaValidation: [, smithy_client_1.expectBoolean, `disableSchemaValidation`],
        ImportInfo: [, smithy_client_1._json, `importInfo`],
        Name: [, smithy_client_1.expectString, `name`],
        ProtocolType: [, smithy_client_1.expectString, `protocolType`],
        RouteSelectionExpression: [, smithy_client_1.expectString, `routeSelectionExpression`],
        Tags: [, smithy_client_1._json, `tags`],
        Version: [, smithy_client_1.expectString, `version`],
        Warnings: [, smithy_client_1._json, `warnings`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ImportApiCommand = de_ImportApiCommand;
const de_ImportApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ReimportApiCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_ReimportApiCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ApiEndpoint: [, smithy_client_1.expectString, `apiEndpoint`],
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        ApiId: [, smithy_client_1.expectString, `apiId`],
        ApiKeySelectionExpression: [, smithy_client_1.expectString, `apiKeySelectionExpression`],
        CorsConfiguration: [, (_) => de_Cors(_, context), `corsConfiguration`],
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        Description: [, smithy_client_1.expectString, `description`],
        DisableExecuteApiEndpoint: [, smithy_client_1.expectBoolean, `disableExecuteApiEndpoint`],
        DisableSchemaValidation: [, smithy_client_1.expectBoolean, `disableSchemaValidation`],
        ImportInfo: [, smithy_client_1._json, `importInfo`],
        Name: [, smithy_client_1.expectString, `name`],
        ProtocolType: [, smithy_client_1.expectString, `protocolType`],
        RouteSelectionExpression: [, smithy_client_1.expectString, `routeSelectionExpression`],
        Tags: [, smithy_client_1._json, `tags`],
        Version: [, smithy_client_1.expectString, `version`],
        Warnings: [, smithy_client_1._json, `warnings`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ReimportApiCommand = de_ReimportApiCommand;
const de_ReimportApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ResetAuthorizersCacheCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_ResetAuthorizersCacheCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_ResetAuthorizersCacheCommand = de_ResetAuthorizersCacheCommand;
const de_ResetAuthorizersCacheCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_TagResourceCommand = de_TagResourceCommand;
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UntagResourceCommand = de_UntagResourceCommand;
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateApiCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateApiCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ApiEndpoint: [, smithy_client_1.expectString, `apiEndpoint`],
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        ApiId: [, smithy_client_1.expectString, `apiId`],
        ApiKeySelectionExpression: [, smithy_client_1.expectString, `apiKeySelectionExpression`],
        CorsConfiguration: [, (_) => de_Cors(_, context), `corsConfiguration`],
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        Description: [, smithy_client_1.expectString, `description`],
        DisableExecuteApiEndpoint: [, smithy_client_1.expectBoolean, `disableExecuteApiEndpoint`],
        DisableSchemaValidation: [, smithy_client_1.expectBoolean, `disableSchemaValidation`],
        ImportInfo: [, smithy_client_1._json, `importInfo`],
        Name: [, smithy_client_1.expectString, `name`],
        ProtocolType: [, smithy_client_1.expectString, `protocolType`],
        RouteSelectionExpression: [, smithy_client_1.expectString, `routeSelectionExpression`],
        Tags: [, smithy_client_1._json, `tags`],
        Version: [, smithy_client_1.expectString, `version`],
        Warnings: [, smithy_client_1._json, `warnings`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateApiCommand = de_UpdateApiCommand;
const de_UpdateApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateApiMappingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateApiMappingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ApiId: [, smithy_client_1.expectString, `apiId`],
        ApiMappingId: [, smithy_client_1.expectString, `apiMappingId`],
        ApiMappingKey: [, smithy_client_1.expectString, `apiMappingKey`],
        Stage: [, smithy_client_1.expectString, `stage`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateApiMappingCommand = de_UpdateApiMappingCommand;
const de_UpdateApiMappingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateAuthorizerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        AuthorizerCredentialsArn: [, smithy_client_1.expectString, `authorizerCredentialsArn`],
        AuthorizerId: [, smithy_client_1.expectString, `authorizerId`],
        AuthorizerPayloadFormatVersion: [, smithy_client_1.expectString, `authorizerPayloadFormatVersion`],
        AuthorizerResultTtlInSeconds: [, smithy_client_1.expectInt32, `authorizerResultTtlInSeconds`],
        AuthorizerType: [, smithy_client_1.expectString, `authorizerType`],
        AuthorizerUri: [, smithy_client_1.expectString, `authorizerUri`],
        EnableSimpleResponses: [, smithy_client_1.expectBoolean, `enableSimpleResponses`],
        IdentitySource: [, smithy_client_1._json, `identitySource`],
        IdentityValidationExpression: [, smithy_client_1.expectString, `identityValidationExpression`],
        JwtConfiguration: [, (_) => de_JWTConfiguration(_, context), `jwtConfiguration`],
        Name: [, smithy_client_1.expectString, `name`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateAuthorizerCommand = de_UpdateAuthorizerCommand;
const de_UpdateAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDeploymentCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        AutoDeployed: [, smithy_client_1.expectBoolean, `autoDeployed`],
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        DeploymentId: [, smithy_client_1.expectString, `deploymentId`],
        DeploymentStatus: [, smithy_client_1.expectString, `deploymentStatus`],
        DeploymentStatusMessage: [, smithy_client_1.expectString, `deploymentStatusMessage`],
        Description: [, smithy_client_1.expectString, `description`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateDeploymentCommand = de_UpdateDeploymentCommand;
const de_UpdateDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDomainNameCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ApiMappingSelectionExpression: [, smithy_client_1.expectString, `apiMappingSelectionExpression`],
        DomainName: [, smithy_client_1.expectString, `domainName`],
        DomainNameConfigurations: [, (_) => de_DomainNameConfigurations(_, context), `domainNameConfigurations`],
        MutualTlsAuthentication: [, (_) => de_MutualTlsAuthentication(_, context), `mutualTlsAuthentication`],
        Tags: [, smithy_client_1._json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateDomainNameCommand = de_UpdateDomainNameCommand;
const de_UpdateDomainNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateIntegrationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        ConnectionId: [, smithy_client_1.expectString, `connectionId`],
        ConnectionType: [, smithy_client_1.expectString, `connectionType`],
        ContentHandlingStrategy: [, smithy_client_1.expectString, `contentHandlingStrategy`],
        CredentialsArn: [, smithy_client_1.expectString, `credentialsArn`],
        Description: [, smithy_client_1.expectString, `description`],
        IntegrationId: [, smithy_client_1.expectString, `integrationId`],
        IntegrationMethod: [, smithy_client_1.expectString, `integrationMethod`],
        IntegrationResponseSelectionExpression: [, smithy_client_1.expectString, `integrationResponseSelectionExpression`],
        IntegrationSubtype: [, smithy_client_1.expectString, `integrationSubtype`],
        IntegrationType: [, smithy_client_1.expectString, `integrationType`],
        IntegrationUri: [, smithy_client_1.expectString, `integrationUri`],
        PassthroughBehavior: [, smithy_client_1.expectString, `passthroughBehavior`],
        PayloadFormatVersion: [, smithy_client_1.expectString, `payloadFormatVersion`],
        RequestParameters: [, smithy_client_1._json, `requestParameters`],
        RequestTemplates: [, smithy_client_1._json, `requestTemplates`],
        ResponseParameters: [, smithy_client_1._json, `responseParameters`],
        TemplateSelectionExpression: [, smithy_client_1.expectString, `templateSelectionExpression`],
        TimeoutInMillis: [, smithy_client_1.expectInt32, `timeoutInMillis`],
        TlsConfig: [, (_) => de_TlsConfig(_, context), `tlsConfig`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateIntegrationCommand = de_UpdateIntegrationCommand;
const de_UpdateIntegrationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateIntegrationResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ContentHandlingStrategy: [, smithy_client_1.expectString, `contentHandlingStrategy`],
        IntegrationResponseId: [, smithy_client_1.expectString, `integrationResponseId`],
        IntegrationResponseKey: [, smithy_client_1.expectString, `integrationResponseKey`],
        ResponseParameters: [, smithy_client_1._json, `responseParameters`],
        ResponseTemplates: [, smithy_client_1._json, `responseTemplates`],
        TemplateSelectionExpression: [, smithy_client_1.expectString, `templateSelectionExpression`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateIntegrationResponseCommand = de_UpdateIntegrationResponseCommand;
const de_UpdateIntegrationResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateModelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateModelCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ContentType: [, smithy_client_1.expectString, `contentType`],
        Description: [, smithy_client_1.expectString, `description`],
        ModelId: [, smithy_client_1.expectString, `modelId`],
        Name: [, smithy_client_1.expectString, `name`],
        Schema: [, smithy_client_1.expectString, `schema`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateModelCommand = de_UpdateModelCommand;
const de_UpdateModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateRouteCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateRouteCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        ApiKeyRequired: [, smithy_client_1.expectBoolean, `apiKeyRequired`],
        AuthorizationScopes: [, smithy_client_1._json, `authorizationScopes`],
        AuthorizationType: [, smithy_client_1.expectString, `authorizationType`],
        AuthorizerId: [, smithy_client_1.expectString, `authorizerId`],
        ModelSelectionExpression: [, smithy_client_1.expectString, `modelSelectionExpression`],
        OperationName: [, smithy_client_1.expectString, `operationName`],
        RequestModels: [, smithy_client_1._json, `requestModels`],
        RequestParameters: [, (_) => de_RouteParameters(_, context), `requestParameters`],
        RouteId: [, smithy_client_1.expectString, `routeId`],
        RouteKey: [, smithy_client_1.expectString, `routeKey`],
        RouteResponseSelectionExpression: [, smithy_client_1.expectString, `routeResponseSelectionExpression`],
        Target: [, smithy_client_1.expectString, `target`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateRouteCommand = de_UpdateRouteCommand;
const de_UpdateRouteCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateRouteResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateRouteResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ModelSelectionExpression: [, smithy_client_1.expectString, `modelSelectionExpression`],
        ResponseModels: [, smithy_client_1._json, `responseModels`],
        ResponseParameters: [, (_) => de_RouteParameters(_, context), `responseParameters`],
        RouteResponseId: [, smithy_client_1.expectString, `routeResponseId`],
        RouteResponseKey: [, smithy_client_1.expectString, `routeResponseKey`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateRouteResponseCommand = de_UpdateRouteResponseCommand;
const de_UpdateRouteResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateStageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateStageCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        AccessLogSettings: [, (_) => de_AccessLogSettings(_, context), `accessLogSettings`],
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        AutoDeploy: [, smithy_client_1.expectBoolean, `autoDeploy`],
        ClientCertificateId: [, smithy_client_1.expectString, `clientCertificateId`],
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        DefaultRouteSettings: [, (_) => de_RouteSettings(_, context), `defaultRouteSettings`],
        DeploymentId: [, smithy_client_1.expectString, `deploymentId`],
        Description: [, smithy_client_1.expectString, `description`],
        LastDeploymentStatusMessage: [, smithy_client_1.expectString, `lastDeploymentStatusMessage`],
        LastUpdatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `lastUpdatedDate`],
        RouteSettings: [, (_) => de_RouteSettingsMap(_, context), `routeSettings`],
        StageName: [, smithy_client_1.expectString, `stageName`],
        StageVariables: [, smithy_client_1._json, `stageVariables`],
        Tags: [, smithy_client_1._json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateStageCommand = de_UpdateStageCommand;
const de_UpdateStageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateVpcLinkCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        Name: [, smithy_client_1.expectString, `name`],
        SecurityGroupIds: [, smithy_client_1._json, `securityGroupIds`],
        SubnetIds: [, smithy_client_1._json, `subnetIds`],
        Tags: [, smithy_client_1._json, `tags`],
        VpcLinkId: [, smithy_client_1.expectString, `vpcLinkId`],
        VpcLinkStatus: [, smithy_client_1.expectString, `vpcLinkStatus`],
        VpcLinkStatusMessage: [, smithy_client_1.expectString, `vpcLinkStatusMessage`],
        VpcLinkVersion: [, smithy_client_1.expectString, `vpcLinkVersion`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateVpcLinkCommand = de_UpdateVpcLinkCommand;
const de_UpdateVpcLinkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = (0, smithy_client_1.withBaseException)(ApiGatewayV2ServiceException_1.ApiGatewayV2ServiceException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        Message: [, smithy_client_1.expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_BadRequestExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        Message: [, smithy_client_1.expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.BadRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        Message: [, smithy_client_1.expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_NotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        Message: [, smithy_client_1.expectString, `message`],
        ResourceType: [, smithy_client_1.expectString, `resourceType`],
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.NotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        LimitType: [, smithy_client_1.expectString, `limitType`],
        Message: [, smithy_client_1.expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const se_AccessLogSettings = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        destinationArn: [, , `DestinationArn`],
        format: [, , `Format`],
    });
};
const se_Cors = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        allowCredentials: [, , `AllowCredentials`],
        allowHeaders: [, smithy_client_1._json, `AllowHeaders`],
        allowMethods: [, smithy_client_1._json, `AllowMethods`],
        allowOrigins: [, smithy_client_1._json, `AllowOrigins`],
        exposeHeaders: [, smithy_client_1._json, `ExposeHeaders`],
        maxAge: [, , `MaxAge`],
    });
};
const se_DomainNameConfiguration = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        apiGatewayDomainName: [, , `ApiGatewayDomainName`],
        certificateArn: [, , `CertificateArn`],
        certificateName: [, , `CertificateName`],
        certificateUploadDate: [, (_) => _.toISOString().split(".")[0] + "Z", `CertificateUploadDate`],
        domainNameStatus: [, , `DomainNameStatus`],
        domainNameStatusMessage: [, , `DomainNameStatusMessage`],
        endpointType: [, , `EndpointType`],
        hostedZoneId: [, , `HostedZoneId`],
        ownershipVerificationCertificateArn: [, , `OwnershipVerificationCertificateArn`],
        securityPolicy: [, , `SecurityPolicy`],
    });
};
const se_DomainNameConfigurations = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_DomainNameConfiguration(entry, context);
    });
};
const se_JWTConfiguration = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        audience: [, smithy_client_1._json, `Audience`],
        issuer: [, , `Issuer`],
    });
};
const se_MutualTlsAuthenticationInput = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        truststoreUri: [, , `TruststoreUri`],
        truststoreVersion: [, , `TruststoreVersion`],
    });
};
const se_ParameterConstraints = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        required: [, , `Required`],
    });
};
const se_RouteParameters = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_ParameterConstraints(value, context);
        return acc;
    }, {});
};
const se_RouteSettings = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        dataTraceEnabled: [, , `DataTraceEnabled`],
        detailedMetricsEnabled: [, , `DetailedMetricsEnabled`],
        loggingLevel: [, , `LoggingLevel`],
        throttlingBurstLimit: [, , `ThrottlingBurstLimit`],
        throttlingRateLimit: [, smithy_client_1.serializeFloat, `ThrottlingRateLimit`],
    });
};
const se_RouteSettingsMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_RouteSettings(value, context);
        return acc;
    }, {});
};
const se_TlsConfigInput = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        serverNameToVerify: [, , `ServerNameToVerify`],
    });
};
const de___listOfApi = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Api(entry, context);
    });
    return retVal;
};
const de___listOfApiMapping = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ApiMapping(entry, context);
    });
    return retVal;
};
const de___listOfAuthorizer = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Authorizer(entry, context);
    });
    return retVal;
};
const de___listOfDeployment = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Deployment(entry, context);
    });
    return retVal;
};
const de___listOfDomainName = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DomainName(entry, context);
    });
    return retVal;
};
const de___listOfIntegration = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Integration(entry, context);
    });
    return retVal;
};
const de___listOfIntegrationResponse = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IntegrationResponse(entry, context);
    });
    return retVal;
};
const de___listOfModel = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Model(entry, context);
    });
    return retVal;
};
const de___listOfRoute = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Route(entry, context);
    });
    return retVal;
};
const de___listOfRouteResponse = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteResponse(entry, context);
    });
    return retVal;
};
const de___listOfStage = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Stage(entry, context);
    });
    return retVal;
};
const de___listOfVpcLink = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcLink(entry, context);
    });
    return retVal;
};
const de_AccessLogSettings = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        DestinationArn: [, smithy_client_1.expectString, `destinationArn`],
        Format: [, smithy_client_1.expectString, `format`],
    });
};
const de_Api = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ApiEndpoint: [, smithy_client_1.expectString, `apiEndpoint`],
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        ApiId: [, smithy_client_1.expectString, `apiId`],
        ApiKeySelectionExpression: [, smithy_client_1.expectString, `apiKeySelectionExpression`],
        CorsConfiguration: [, (_) => de_Cors(_, context), `corsConfiguration`],
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        Description: [, smithy_client_1.expectString, `description`],
        DisableExecuteApiEndpoint: [, smithy_client_1.expectBoolean, `disableExecuteApiEndpoint`],
        DisableSchemaValidation: [, smithy_client_1.expectBoolean, `disableSchemaValidation`],
        ImportInfo: [, smithy_client_1._json, `importInfo`],
        Name: [, smithy_client_1.expectString, `name`],
        ProtocolType: [, smithy_client_1.expectString, `protocolType`],
        RouteSelectionExpression: [, smithy_client_1.expectString, `routeSelectionExpression`],
        Tags: [, smithy_client_1._json, `tags`],
        Version: [, smithy_client_1.expectString, `version`],
        Warnings: [, smithy_client_1._json, `warnings`],
    });
};
const de_ApiMapping = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ApiId: [, smithy_client_1.expectString, `apiId`],
        ApiMappingId: [, smithy_client_1.expectString, `apiMappingId`],
        ApiMappingKey: [, smithy_client_1.expectString, `apiMappingKey`],
        Stage: [, smithy_client_1.expectString, `stage`],
    });
};
const de_Authorizer = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AuthorizerCredentialsArn: [, smithy_client_1.expectString, `authorizerCredentialsArn`],
        AuthorizerId: [, smithy_client_1.expectString, `authorizerId`],
        AuthorizerPayloadFormatVersion: [, smithy_client_1.expectString, `authorizerPayloadFormatVersion`],
        AuthorizerResultTtlInSeconds: [, smithy_client_1.expectInt32, `authorizerResultTtlInSeconds`],
        AuthorizerType: [, smithy_client_1.expectString, `authorizerType`],
        AuthorizerUri: [, smithy_client_1.expectString, `authorizerUri`],
        EnableSimpleResponses: [, smithy_client_1.expectBoolean, `enableSimpleResponses`],
        IdentitySource: [, smithy_client_1._json, `identitySource`],
        IdentityValidationExpression: [, smithy_client_1.expectString, `identityValidationExpression`],
        JwtConfiguration: [, (_) => de_JWTConfiguration(_, context), `jwtConfiguration`],
        Name: [, smithy_client_1.expectString, `name`],
    });
};
const de_Cors = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AllowCredentials: [, smithy_client_1.expectBoolean, `allowCredentials`],
        AllowHeaders: [, smithy_client_1._json, `allowHeaders`],
        AllowMethods: [, smithy_client_1._json, `allowMethods`],
        AllowOrigins: [, smithy_client_1._json, `allowOrigins`],
        ExposeHeaders: [, smithy_client_1._json, `exposeHeaders`],
        MaxAge: [, smithy_client_1.expectInt32, `maxAge`],
    });
};
const de_Deployment = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AutoDeployed: [, smithy_client_1.expectBoolean, `autoDeployed`],
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        DeploymentId: [, smithy_client_1.expectString, `deploymentId`],
        DeploymentStatus: [, smithy_client_1.expectString, `deploymentStatus`],
        DeploymentStatusMessage: [, smithy_client_1.expectString, `deploymentStatusMessage`],
        Description: [, smithy_client_1.expectString, `description`],
    });
};
const de_DomainName = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ApiMappingSelectionExpression: [, smithy_client_1.expectString, `apiMappingSelectionExpression`],
        DomainName: [, smithy_client_1.expectString, `domainName`],
        DomainNameConfigurations: [, (_) => de_DomainNameConfigurations(_, context), `domainNameConfigurations`],
        MutualTlsAuthentication: [, (_) => de_MutualTlsAuthentication(_, context), `mutualTlsAuthentication`],
        Tags: [, smithy_client_1._json, `tags`],
    });
};
const de_DomainNameConfiguration = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ApiGatewayDomainName: [, smithy_client_1.expectString, `apiGatewayDomainName`],
        CertificateArn: [, smithy_client_1.expectString, `certificateArn`],
        CertificateName: [, smithy_client_1.expectString, `certificateName`],
        CertificateUploadDate: [
            ,
            (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)),
            `certificateUploadDate`,
        ],
        DomainNameStatus: [, smithy_client_1.expectString, `domainNameStatus`],
        DomainNameStatusMessage: [, smithy_client_1.expectString, `domainNameStatusMessage`],
        EndpointType: [, smithy_client_1.expectString, `endpointType`],
        HostedZoneId: [, smithy_client_1.expectString, `hostedZoneId`],
        OwnershipVerificationCertificateArn: [, smithy_client_1.expectString, `ownershipVerificationCertificateArn`],
        SecurityPolicy: [, smithy_client_1.expectString, `securityPolicy`],
    });
};
const de_DomainNameConfigurations = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DomainNameConfiguration(entry, context);
    });
    return retVal;
};
const de_Integration = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        ConnectionId: [, smithy_client_1.expectString, `connectionId`],
        ConnectionType: [, smithy_client_1.expectString, `connectionType`],
        ContentHandlingStrategy: [, smithy_client_1.expectString, `contentHandlingStrategy`],
        CredentialsArn: [, smithy_client_1.expectString, `credentialsArn`],
        Description: [, smithy_client_1.expectString, `description`],
        IntegrationId: [, smithy_client_1.expectString, `integrationId`],
        IntegrationMethod: [, smithy_client_1.expectString, `integrationMethod`],
        IntegrationResponseSelectionExpression: [, smithy_client_1.expectString, `integrationResponseSelectionExpression`],
        IntegrationSubtype: [, smithy_client_1.expectString, `integrationSubtype`],
        IntegrationType: [, smithy_client_1.expectString, `integrationType`],
        IntegrationUri: [, smithy_client_1.expectString, `integrationUri`],
        PassthroughBehavior: [, smithy_client_1.expectString, `passthroughBehavior`],
        PayloadFormatVersion: [, smithy_client_1.expectString, `payloadFormatVersion`],
        RequestParameters: [, smithy_client_1._json, `requestParameters`],
        RequestTemplates: [, smithy_client_1._json, `requestTemplates`],
        ResponseParameters: [, smithy_client_1._json, `responseParameters`],
        TemplateSelectionExpression: [, smithy_client_1.expectString, `templateSelectionExpression`],
        TimeoutInMillis: [, smithy_client_1.expectInt32, `timeoutInMillis`],
        TlsConfig: [, (_) => de_TlsConfig(_, context), `tlsConfig`],
    });
};
const de_IntegrationResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ContentHandlingStrategy: [, smithy_client_1.expectString, `contentHandlingStrategy`],
        IntegrationResponseId: [, smithy_client_1.expectString, `integrationResponseId`],
        IntegrationResponseKey: [, smithy_client_1.expectString, `integrationResponseKey`],
        ResponseParameters: [, smithy_client_1._json, `responseParameters`],
        ResponseTemplates: [, smithy_client_1._json, `responseTemplates`],
        TemplateSelectionExpression: [, smithy_client_1.expectString, `templateSelectionExpression`],
    });
};
const de_JWTConfiguration = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Audience: [, smithy_client_1._json, `audience`],
        Issuer: [, smithy_client_1.expectString, `issuer`],
    });
};
const de_Model = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ContentType: [, smithy_client_1.expectString, `contentType`],
        Description: [, smithy_client_1.expectString, `description`],
        ModelId: [, smithy_client_1.expectString, `modelId`],
        Name: [, smithy_client_1.expectString, `name`],
        Schema: [, smithy_client_1.expectString, `schema`],
    });
};
const de_MutualTlsAuthentication = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        TruststoreUri: [, smithy_client_1.expectString, `truststoreUri`],
        TruststoreVersion: [, smithy_client_1.expectString, `truststoreVersion`],
        TruststoreWarnings: [, smithy_client_1._json, `truststoreWarnings`],
    });
};
const de_ParameterConstraints = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Required: [, smithy_client_1.expectBoolean, `required`],
    });
};
const de_Route = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        ApiKeyRequired: [, smithy_client_1.expectBoolean, `apiKeyRequired`],
        AuthorizationScopes: [, smithy_client_1._json, `authorizationScopes`],
        AuthorizationType: [, smithy_client_1.expectString, `authorizationType`],
        AuthorizerId: [, smithy_client_1.expectString, `authorizerId`],
        ModelSelectionExpression: [, smithy_client_1.expectString, `modelSelectionExpression`],
        OperationName: [, smithy_client_1.expectString, `operationName`],
        RequestModels: [, smithy_client_1._json, `requestModels`],
        RequestParameters: [, (_) => de_RouteParameters(_, context), `requestParameters`],
        RouteId: [, smithy_client_1.expectString, `routeId`],
        RouteKey: [, smithy_client_1.expectString, `routeKey`],
        RouteResponseSelectionExpression: [, smithy_client_1.expectString, `routeResponseSelectionExpression`],
        Target: [, smithy_client_1.expectString, `target`],
    });
};
const de_RouteParameters = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_ParameterConstraints(value, context);
        return acc;
    }, {});
};
const de_RouteResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ModelSelectionExpression: [, smithy_client_1.expectString, `modelSelectionExpression`],
        ResponseModels: [, smithy_client_1._json, `responseModels`],
        ResponseParameters: [, (_) => de_RouteParameters(_, context), `responseParameters`],
        RouteResponseId: [, smithy_client_1.expectString, `routeResponseId`],
        RouteResponseKey: [, smithy_client_1.expectString, `routeResponseKey`],
    });
};
const de_RouteSettings = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        DataTraceEnabled: [, smithy_client_1.expectBoolean, `dataTraceEnabled`],
        DetailedMetricsEnabled: [, smithy_client_1.expectBoolean, `detailedMetricsEnabled`],
        LoggingLevel: [, smithy_client_1.expectString, `loggingLevel`],
        ThrottlingBurstLimit: [, smithy_client_1.expectInt32, `throttlingBurstLimit`],
        ThrottlingRateLimit: [, smithy_client_1.limitedParseDouble, `throttlingRateLimit`],
    });
};
const de_RouteSettingsMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_RouteSettings(value, context);
        return acc;
    }, {});
};
const de_Stage = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AccessLogSettings: [, (_) => de_AccessLogSettings(_, context), `accessLogSettings`],
        ApiGatewayManaged: [, smithy_client_1.expectBoolean, `apiGatewayManaged`],
        AutoDeploy: [, smithy_client_1.expectBoolean, `autoDeploy`],
        ClientCertificateId: [, smithy_client_1.expectString, `clientCertificateId`],
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        DefaultRouteSettings: [, (_) => de_RouteSettings(_, context), `defaultRouteSettings`],
        DeploymentId: [, smithy_client_1.expectString, `deploymentId`],
        Description: [, smithy_client_1.expectString, `description`],
        LastDeploymentStatusMessage: [, smithy_client_1.expectString, `lastDeploymentStatusMessage`],
        LastUpdatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `lastUpdatedDate`],
        RouteSettings: [, (_) => de_RouteSettingsMap(_, context), `routeSettings`],
        StageName: [, smithy_client_1.expectString, `stageName`],
        StageVariables: [, smithy_client_1._json, `stageVariables`],
        Tags: [, smithy_client_1._json, `tags`],
    });
};
const de_TlsConfig = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ServerNameToVerify: [, smithy_client_1.expectString, `serverNameToVerify`],
    });
};
const de_VpcLink = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CreatedDate: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `createdDate`],
        Name: [, smithy_client_1.expectString, `name`],
        SecurityGroupIds: [, smithy_client_1._json, `securityGroupIds`],
        SubnetIds: [, smithy_client_1._json, `subnetIds`],
        Tags: [, smithy_client_1._json, `tags`],
        VpcLinkId: [, smithy_client_1.expectString, `vpcLinkId`],
        VpcLinkStatus: [, smithy_client_1.expectString, `vpcLinkStatus`],
        VpcLinkStatusMessage: [, smithy_client_1.expectString, `vpcLinkStatusMessage`],
        VpcLinkVersion: [, smithy_client_1.expectString, `vpcLinkVersion`],
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
