import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectNonNull as __expectNonNull, expectObject as __expectObject, expectString as __expectString, limitedParseDouble as __limitedParseDouble, map, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, resolvedPath as __resolvedPath, serializeFloat as __serializeFloat, take, withBaseException, } from "@smithy/smithy-client";
import { ApiGatewayV2ServiceException as __BaseException } from "../models/ApiGatewayV2ServiceException";
import { AccessDeniedException, BadRequestException, ConflictException, NotFoundException, TooManyRequestsException, } from "../models/models_0";
export const se_CreateApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis";
    let body;
    body = JSON.stringify(take(input, {
        apiKeySelectionExpression: [, , `ApiKeySelectionExpression`],
        corsConfiguration: [, (_) => se_Cors(_, context), `CorsConfiguration`],
        credentialsArn: [, , `CredentialsArn`],
        description: [, , `Description`],
        disableExecuteApiEndpoint: [, , `DisableExecuteApiEndpoint`],
        disableSchemaValidation: [, , `DisableSchemaValidation`],
        name: [, , `Name`],
        protocolType: [, , `ProtocolType`],
        routeKey: [, , `RouteKey`],
        routeSelectionExpression: [, , `RouteSelectionExpression`],
        tags: [, (_) => _json(_), `Tags`],
        target: [, , `Target`],
        version: [, , `Version`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateApiMappingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/domainnames/{DomainName}/apimappings";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        apiId: [, , `ApiId`],
        apiMappingKey: [, , `ApiMappingKey`],
        stage: [, , `Stage`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/authorizers";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        authorizerCredentialsArn: [, , `AuthorizerCredentialsArn`],
        authorizerPayloadFormatVersion: [, , `AuthorizerPayloadFormatVersion`],
        authorizerResultTtlInSeconds: [, , `AuthorizerResultTtlInSeconds`],
        authorizerType: [, , `AuthorizerType`],
        authorizerUri: [, , `AuthorizerUri`],
        enableSimpleResponses: [, , `EnableSimpleResponses`],
        identitySource: [, (_) => _json(_), `IdentitySource`],
        identityValidationExpression: [, , `IdentityValidationExpression`],
        jwtConfiguration: [, (_) => se_JWTConfiguration(_, context), `JwtConfiguration`],
        name: [, , `Name`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateDeploymentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/deployments";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [, , `Description`],
        stageName: [, , `StageName`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateDomainNameCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/domainnames";
    let body;
    body = JSON.stringify(take(input, {
        domainName: [, , `DomainName`],
        domainNameConfigurations: [, (_) => se_DomainNameConfigurations(_, context), `DomainNameConfigurations`],
        mutualTlsAuthentication: [, (_) => se_MutualTlsAuthenticationInput(_, context), `MutualTlsAuthentication`],
        tags: [, (_) => _json(_), `Tags`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateIntegrationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/integrations";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        connectionId: [, , `ConnectionId`],
        connectionType: [, , `ConnectionType`],
        contentHandlingStrategy: [, , `ContentHandlingStrategy`],
        credentialsArn: [, , `CredentialsArn`],
        description: [, , `Description`],
        integrationMethod: [, , `IntegrationMethod`],
        integrationSubtype: [, , `IntegrationSubtype`],
        integrationType: [, , `IntegrationType`],
        integrationUri: [, , `IntegrationUri`],
        passthroughBehavior: [, , `PassthroughBehavior`],
        payloadFormatVersion: [, , `PayloadFormatVersion`],
        requestParameters: [, (_) => _json(_), `RequestParameters`],
        requestTemplates: [, (_) => _json(_), `RequestTemplates`],
        responseParameters: [, (_) => _json(_), `ResponseParameters`],
        templateSelectionExpression: [, , `TemplateSelectionExpression`],
        timeoutInMillis: [, , `TimeoutInMillis`],
        tlsConfig: [, (_) => se_TlsConfigInput(_, context), `TlsConfig`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateIntegrationResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/integrations/{IntegrationId}/integrationresponses";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "IntegrationId", () => input.IntegrationId, "{IntegrationId}", false);
    let body;
    body = JSON.stringify(take(input, {
        contentHandlingStrategy: [, , `ContentHandlingStrategy`],
        integrationResponseKey: [, , `IntegrationResponseKey`],
        responseParameters: [, (_) => _json(_), `ResponseParameters`],
        responseTemplates: [, (_) => _json(_), `ResponseTemplates`],
        templateSelectionExpression: [, , `TemplateSelectionExpression`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateModelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/models";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        contentType: [, , `ContentType`],
        description: [, , `Description`],
        name: [, , `Name`],
        schema: [, , `Schema`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateRouteCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/routes";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        apiKeyRequired: [, , `ApiKeyRequired`],
        authorizationScopes: [, (_) => _json(_), `AuthorizationScopes`],
        authorizationType: [, , `AuthorizationType`],
        authorizerId: [, , `AuthorizerId`],
        modelSelectionExpression: [, , `ModelSelectionExpression`],
        operationName: [, , `OperationName`],
        requestModels: [, (_) => _json(_), `RequestModels`],
        requestParameters: [, (_) => se_RouteParameters(_, context), `RequestParameters`],
        routeKey: [, , `RouteKey`],
        routeResponseSelectionExpression: [, , `RouteResponseSelectionExpression`],
        target: [, , `Target`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateRouteResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/routes/{RouteId}/routeresponses";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    let body;
    body = JSON.stringify(take(input, {
        modelSelectionExpression: [, , `ModelSelectionExpression`],
        responseModels: [, (_) => _json(_), `ResponseModels`],
        responseParameters: [, (_) => se_RouteParameters(_, context), `ResponseParameters`],
        routeResponseKey: [, , `RouteResponseKey`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateStageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/stages";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        accessLogSettings: [, (_) => se_AccessLogSettings(_, context), `AccessLogSettings`],
        autoDeploy: [, , `AutoDeploy`],
        clientCertificateId: [, , `ClientCertificateId`],
        defaultRouteSettings: [, (_) => se_RouteSettings(_, context), `DefaultRouteSettings`],
        deploymentId: [, , `DeploymentId`],
        description: [, , `Description`],
        routeSettings: [, (_) => se_RouteSettingsMap(_, context), `RouteSettings`],
        stageName: [, , `StageName`],
        stageVariables: [, (_) => _json(_), `StageVariables`],
        tags: [, (_) => _json(_), `Tags`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateVpcLinkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/vpclinks";
    let body;
    body = JSON.stringify(take(input, {
        name: [, , `Name`],
        securityGroupIds: [, (_) => _json(_), `SecurityGroupIds`],
        subnetIds: [, (_) => _json(_), `SubnetIds`],
        tags: [, (_) => _json(_), `Tags`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteAccessLogSettingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/stages/{StageName}/accesslogsettings";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "StageName", () => input.StageName, "{StageName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteApiMappingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/domainnames/{DomainName}/apimappings/{ApiMappingId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiMappingId", () => input.ApiMappingId, "{ApiMappingId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/authorizers/{AuthorizerId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "AuthorizerId", () => input.AuthorizerId, "{AuthorizerId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteCorsConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/cors";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteDeploymentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/deployments/{DeploymentId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "DeploymentId", () => input.DeploymentId, "{DeploymentId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteDomainNameCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/domainnames/{DomainName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteIntegrationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/integrations/{IntegrationId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "IntegrationId", () => input.IntegrationId, "{IntegrationId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteIntegrationResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/integrations/{IntegrationId}/integrationresponses/{IntegrationResponseId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "IntegrationId", () => input.IntegrationId, "{IntegrationId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "IntegrationResponseId", () => input.IntegrationResponseId, "{IntegrationResponseId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteModelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/models/{ModelId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "ModelId", () => input.ModelId, "{ModelId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteRouteCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/routes/{RouteId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteRouteRequestParameterCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/routes/{RouteId}/requestparameters/{RequestParameterKey}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "RequestParameterKey", () => input.RequestParameterKey, "{RequestParameterKey}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteRouteResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/routes/{RouteId}/routeresponses/{RouteResponseId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "RouteResponseId", () => input.RouteResponseId, "{RouteResponseId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteRouteSettingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/stages/{StageName}/routesettings/{RouteKey}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "RouteKey", () => input.RouteKey, "{RouteKey}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "StageName", () => input.StageName, "{StageName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteStageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/stages/{StageName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "StageName", () => input.StageName, "{StageName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteVpcLinkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/vpclinks/{VpcLinkId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "VpcLinkId", () => input.VpcLinkId, "{VpcLinkId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_ExportApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/exports/{Specification}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "Specification", () => input.Specification, "{Specification}", false);
    const query = map({
        exportVersion: [, input.ExportVersion],
        includeExtensions: [() => input.IncludeExtensions !== void 0, () => input.IncludeExtensions.toString()],
        outputType: [, __expectNonNull(input.OutputType, `OutputType`)],
        stageName: [, input.StageName],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetApiMappingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/domainnames/{DomainName}/apimappings/{ApiMappingId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiMappingId", () => input.ApiMappingId, "{ApiMappingId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetApiMappingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/domainnames/{DomainName}/apimappings";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetApisCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis";
    const query = map({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/authorizers/{AuthorizerId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "AuthorizerId", () => input.AuthorizerId, "{AuthorizerId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetAuthorizersCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/authorizers";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    const query = map({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetDeploymentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/deployments/{DeploymentId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "DeploymentId", () => input.DeploymentId, "{DeploymentId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetDeploymentsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/deployments";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    const query = map({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetDomainNameCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/domainnames/{DomainName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetDomainNamesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/domainnames";
    const query = map({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetIntegrationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/integrations/{IntegrationId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "IntegrationId", () => input.IntegrationId, "{IntegrationId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetIntegrationResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/integrations/{IntegrationId}/integrationresponses/{IntegrationResponseId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "IntegrationId", () => input.IntegrationId, "{IntegrationId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "IntegrationResponseId", () => input.IntegrationResponseId, "{IntegrationResponseId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetIntegrationResponsesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/integrations/{IntegrationId}/integrationresponses";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "IntegrationId", () => input.IntegrationId, "{IntegrationId}", false);
    const query = map({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetIntegrationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/integrations";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    const query = map({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetModelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/models/{ModelId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "ModelId", () => input.ModelId, "{ModelId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetModelsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/models";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    const query = map({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetModelTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/models/{ModelId}/template";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "ModelId", () => input.ModelId, "{ModelId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetRouteCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/routes/{RouteId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetRouteResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/routes/{RouteId}/routeresponses/{RouteResponseId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "RouteResponseId", () => input.RouteResponseId, "{RouteResponseId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetRouteResponsesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/routes/{RouteId}/routeresponses";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    const query = map({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetRoutesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/routes";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    const query = map({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetStageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/stages/{StageName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "StageName", () => input.StageName, "{StageName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetStagesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/stages";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    const query = map({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetTagsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/tags/{ResourceArn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetVpcLinkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/vpclinks/{VpcLinkId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "VpcLinkId", () => input.VpcLinkId, "{VpcLinkId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetVpcLinksCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/vpclinks";
    const query = map({
        maxResults: [, input.MaxResults],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ImportApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis";
    const query = map({
        basepath: [, input.Basepath],
        failOnWarnings: [() => input.FailOnWarnings !== void 0, () => input.FailOnWarnings.toString()],
    });
    let body;
    body = JSON.stringify(take(input, {
        body: [, , `Body`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ReimportApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    const query = map({
        basepath: [, input.Basepath],
        failOnWarnings: [() => input.FailOnWarnings !== void 0, () => input.FailOnWarnings.toString()],
    });
    let body;
    body = JSON.stringify(take(input, {
        body: [, , `Body`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ResetAuthorizersCacheCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/stages/{StageName}/cache/authorizers";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "StageName", () => input.StageName, "{StageName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_TagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/tags/{ResourceArn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        tags: [, (_) => _json(_), `Tags`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UntagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/tags/{ResourceArn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    const query = map({
        tagKeys: [
            __expectNonNull(input.TagKeys, `TagKeys`) != null,
            () => (input.TagKeys || []).map((_entry) => _entry),
        ],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_UpdateApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        apiKeySelectionExpression: [, , `ApiKeySelectionExpression`],
        corsConfiguration: [, (_) => se_Cors(_, context), `CorsConfiguration`],
        credentialsArn: [, , `CredentialsArn`],
        description: [, , `Description`],
        disableExecuteApiEndpoint: [, , `DisableExecuteApiEndpoint`],
        disableSchemaValidation: [, , `DisableSchemaValidation`],
        name: [, , `Name`],
        routeKey: [, , `RouteKey`],
        routeSelectionExpression: [, , `RouteSelectionExpression`],
        target: [, , `Target`],
        version: [, , `Version`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateApiMappingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/domainnames/{DomainName}/apimappings/{ApiMappingId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiMappingId", () => input.ApiMappingId, "{ApiMappingId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        apiId: [, , `ApiId`],
        apiMappingKey: [, , `ApiMappingKey`],
        stage: [, , `Stage`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/authorizers/{AuthorizerId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "AuthorizerId", () => input.AuthorizerId, "{AuthorizerId}", false);
    let body;
    body = JSON.stringify(take(input, {
        authorizerCredentialsArn: [, , `AuthorizerCredentialsArn`],
        authorizerPayloadFormatVersion: [, , `AuthorizerPayloadFormatVersion`],
        authorizerResultTtlInSeconds: [, , `AuthorizerResultTtlInSeconds`],
        authorizerType: [, , `AuthorizerType`],
        authorizerUri: [, , `AuthorizerUri`],
        enableSimpleResponses: [, , `EnableSimpleResponses`],
        identitySource: [, (_) => _json(_), `IdentitySource`],
        identityValidationExpression: [, , `IdentityValidationExpression`],
        jwtConfiguration: [, (_) => se_JWTConfiguration(_, context), `JwtConfiguration`],
        name: [, , `Name`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateDeploymentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/deployments/{DeploymentId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "DeploymentId", () => input.DeploymentId, "{DeploymentId}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [, , `Description`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateDomainNameCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/domainnames/{DomainName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        domainNameConfigurations: [, (_) => se_DomainNameConfigurations(_, context), `DomainNameConfigurations`],
        mutualTlsAuthentication: [, (_) => se_MutualTlsAuthenticationInput(_, context), `MutualTlsAuthentication`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateIntegrationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/integrations/{IntegrationId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "IntegrationId", () => input.IntegrationId, "{IntegrationId}", false);
    let body;
    body = JSON.stringify(take(input, {
        connectionId: [, , `ConnectionId`],
        connectionType: [, , `ConnectionType`],
        contentHandlingStrategy: [, , `ContentHandlingStrategy`],
        credentialsArn: [, , `CredentialsArn`],
        description: [, , `Description`],
        integrationMethod: [, , `IntegrationMethod`],
        integrationSubtype: [, , `IntegrationSubtype`],
        integrationType: [, , `IntegrationType`],
        integrationUri: [, , `IntegrationUri`],
        passthroughBehavior: [, , `PassthroughBehavior`],
        payloadFormatVersion: [, , `PayloadFormatVersion`],
        requestParameters: [, (_) => _json(_), `RequestParameters`],
        requestTemplates: [, (_) => _json(_), `RequestTemplates`],
        responseParameters: [, (_) => _json(_), `ResponseParameters`],
        templateSelectionExpression: [, , `TemplateSelectionExpression`],
        timeoutInMillis: [, , `TimeoutInMillis`],
        tlsConfig: [, (_) => se_TlsConfigInput(_, context), `TlsConfig`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateIntegrationResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/integrations/{IntegrationId}/integrationresponses/{IntegrationResponseId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "IntegrationId", () => input.IntegrationId, "{IntegrationId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "IntegrationResponseId", () => input.IntegrationResponseId, "{IntegrationResponseId}", false);
    let body;
    body = JSON.stringify(take(input, {
        contentHandlingStrategy: [, , `ContentHandlingStrategy`],
        integrationResponseKey: [, , `IntegrationResponseKey`],
        responseParameters: [, (_) => _json(_), `ResponseParameters`],
        responseTemplates: [, (_) => _json(_), `ResponseTemplates`],
        templateSelectionExpression: [, , `TemplateSelectionExpression`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateModelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/models/{ModelId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "ModelId", () => input.ModelId, "{ModelId}", false);
    let body;
    body = JSON.stringify(take(input, {
        contentType: [, , `ContentType`],
        description: [, , `Description`],
        name: [, , `Name`],
        schema: [, , `Schema`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateRouteCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/routes/{RouteId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    let body;
    body = JSON.stringify(take(input, {
        apiKeyRequired: [, , `ApiKeyRequired`],
        authorizationScopes: [, (_) => _json(_), `AuthorizationScopes`],
        authorizationType: [, , `AuthorizationType`],
        authorizerId: [, , `AuthorizerId`],
        modelSelectionExpression: [, , `ModelSelectionExpression`],
        operationName: [, , `OperationName`],
        requestModels: [, (_) => _json(_), `RequestModels`],
        requestParameters: [, (_) => se_RouteParameters(_, context), `RequestParameters`],
        routeKey: [, , `RouteKey`],
        routeResponseSelectionExpression: [, , `RouteResponseSelectionExpression`],
        target: [, , `Target`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateRouteResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v2/apis/{ApiId}/routes/{RouteId}/routeresponses/{RouteResponseId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "RouteId", () => input.RouteId, "{RouteId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "RouteResponseId", () => input.RouteResponseId, "{RouteResponseId}", false);
    let body;
    body = JSON.stringify(take(input, {
        modelSelectionExpression: [, , `ModelSelectionExpression`],
        responseModels: [, (_) => _json(_), `ResponseModels`],
        responseParameters: [, (_) => se_RouteParameters(_, context), `ResponseParameters`],
        routeResponseKey: [, , `RouteResponseKey`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateStageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/apis/{ApiId}/stages/{StageName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ApiId", () => input.ApiId, "{ApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "StageName", () => input.StageName, "{StageName}", false);
    let body;
    body = JSON.stringify(take(input, {
        accessLogSettings: [, (_) => se_AccessLogSettings(_, context), `AccessLogSettings`],
        autoDeploy: [, , `AutoDeploy`],
        clientCertificateId: [, , `ClientCertificateId`],
        defaultRouteSettings: [, (_) => se_RouteSettings(_, context), `DefaultRouteSettings`],
        deploymentId: [, , `DeploymentId`],
        description: [, , `Description`],
        routeSettings: [, (_) => se_RouteSettingsMap(_, context), `RouteSettings`],
        stageVariables: [, (_) => _json(_), `StageVariables`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateVpcLinkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2/vpclinks/{VpcLinkId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "VpcLinkId", () => input.VpcLinkId, "{VpcLinkId}", false);
    let body;
    body = JSON.stringify(take(input, {
        name: [, , `Name`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const de_CreateApiCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateApiCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApiEndpoint: [, __expectString, `apiEndpoint`],
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        ApiId: [, __expectString, `apiId`],
        ApiKeySelectionExpression: [, __expectString, `apiKeySelectionExpression`],
        CorsConfiguration: [, (_) => de_Cors(_, context), `corsConfiguration`],
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        Description: [, __expectString, `description`],
        DisableExecuteApiEndpoint: [, __expectBoolean, `disableExecuteApiEndpoint`],
        DisableSchemaValidation: [, __expectBoolean, `disableSchemaValidation`],
        ImportInfo: [, _json, `importInfo`],
        Name: [, __expectString, `name`],
        ProtocolType: [, __expectString, `protocolType`],
        RouteSelectionExpression: [, __expectString, `routeSelectionExpression`],
        Tags: [, _json, `tags`],
        Version: [, __expectString, `version`],
        Warnings: [, _json, `warnings`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateApiMappingCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateApiMappingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApiId: [, __expectString, `apiId`],
        ApiMappingId: [, __expectString, `apiMappingId`],
        ApiMappingKey: [, __expectString, `apiMappingKey`],
        Stage: [, __expectString, `stage`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateApiMappingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AuthorizerCredentialsArn: [, __expectString, `authorizerCredentialsArn`],
        AuthorizerId: [, __expectString, `authorizerId`],
        AuthorizerPayloadFormatVersion: [, __expectString, `authorizerPayloadFormatVersion`],
        AuthorizerResultTtlInSeconds: [, __expectInt32, `authorizerResultTtlInSeconds`],
        AuthorizerType: [, __expectString, `authorizerType`],
        AuthorizerUri: [, __expectString, `authorizerUri`],
        EnableSimpleResponses: [, __expectBoolean, `enableSimpleResponses`],
        IdentitySource: [, _json, `identitySource`],
        IdentityValidationExpression: [, __expectString, `identityValidationExpression`],
        JwtConfiguration: [, (_) => de_JWTConfiguration(_, context), `jwtConfiguration`],
        Name: [, __expectString, `name`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateDeploymentCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AutoDeployed: [, __expectBoolean, `autoDeployed`],
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        DeploymentId: [, __expectString, `deploymentId`],
        DeploymentStatus: [, __expectString, `deploymentStatus`],
        DeploymentStatusMessage: [, __expectString, `deploymentStatusMessage`],
        Description: [, __expectString, `description`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateDomainNameCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApiMappingSelectionExpression: [, __expectString, `apiMappingSelectionExpression`],
        DomainName: [, __expectString, `domainName`],
        DomainNameConfigurations: [, (_) => de_DomainNameConfigurations(_, context), `domainNameConfigurations`],
        MutualTlsAuthentication: [, (_) => de_MutualTlsAuthentication(_, context), `mutualTlsAuthentication`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateDomainNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.apigatewayv2#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateIntegrationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        ConnectionId: [, __expectString, `connectionId`],
        ConnectionType: [, __expectString, `connectionType`],
        ContentHandlingStrategy: [, __expectString, `contentHandlingStrategy`],
        CredentialsArn: [, __expectString, `credentialsArn`],
        Description: [, __expectString, `description`],
        IntegrationId: [, __expectString, `integrationId`],
        IntegrationMethod: [, __expectString, `integrationMethod`],
        IntegrationResponseSelectionExpression: [, __expectString, `integrationResponseSelectionExpression`],
        IntegrationSubtype: [, __expectString, `integrationSubtype`],
        IntegrationType: [, __expectString, `integrationType`],
        IntegrationUri: [, __expectString, `integrationUri`],
        PassthroughBehavior: [, __expectString, `passthroughBehavior`],
        PayloadFormatVersion: [, __expectString, `payloadFormatVersion`],
        RequestParameters: [, _json, `requestParameters`],
        RequestTemplates: [, _json, `requestTemplates`],
        ResponseParameters: [, _json, `responseParameters`],
        TemplateSelectionExpression: [, __expectString, `templateSelectionExpression`],
        TimeoutInMillis: [, __expectInt32, `timeoutInMillis`],
        TlsConfig: [, (_) => de_TlsConfig(_, context), `tlsConfig`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateIntegrationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateIntegrationResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ContentHandlingStrategy: [, __expectString, `contentHandlingStrategy`],
        IntegrationResponseId: [, __expectString, `integrationResponseId`],
        IntegrationResponseKey: [, __expectString, `integrationResponseKey`],
        ResponseParameters: [, _json, `responseParameters`],
        ResponseTemplates: [, _json, `responseTemplates`],
        TemplateSelectionExpression: [, __expectString, `templateSelectionExpression`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateIntegrationResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateModelCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateModelCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ContentType: [, __expectString, `contentType`],
        Description: [, __expectString, `description`],
        ModelId: [, __expectString, `modelId`],
        Name: [, __expectString, `name`],
        Schema: [, __expectString, `schema`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateRouteCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateRouteCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        ApiKeyRequired: [, __expectBoolean, `apiKeyRequired`],
        AuthorizationScopes: [, _json, `authorizationScopes`],
        AuthorizationType: [, __expectString, `authorizationType`],
        AuthorizerId: [, __expectString, `authorizerId`],
        ModelSelectionExpression: [, __expectString, `modelSelectionExpression`],
        OperationName: [, __expectString, `operationName`],
        RequestModels: [, _json, `requestModels`],
        RequestParameters: [, (_) => de_RouteParameters(_, context), `requestParameters`],
        RouteId: [, __expectString, `routeId`],
        RouteKey: [, __expectString, `routeKey`],
        RouteResponseSelectionExpression: [, __expectString, `routeResponseSelectionExpression`],
        Target: [, __expectString, `target`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateRouteCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateRouteResponseCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateRouteResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ModelSelectionExpression: [, __expectString, `modelSelectionExpression`],
        ResponseModels: [, _json, `responseModels`],
        ResponseParameters: [, (_) => de_RouteParameters(_, context), `responseParameters`],
        RouteResponseId: [, __expectString, `routeResponseId`],
        RouteResponseKey: [, __expectString, `routeResponseKey`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateRouteResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateStageCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateStageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AccessLogSettings: [, (_) => de_AccessLogSettings(_, context), `accessLogSettings`],
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        AutoDeploy: [, __expectBoolean, `autoDeploy`],
        ClientCertificateId: [, __expectString, `clientCertificateId`],
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        DefaultRouteSettings: [, (_) => de_RouteSettings(_, context), `defaultRouteSettings`],
        DeploymentId: [, __expectString, `deploymentId`],
        Description: [, __expectString, `description`],
        LastDeploymentStatusMessage: [, __expectString, `lastDeploymentStatusMessage`],
        LastUpdatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `lastUpdatedDate`],
        RouteSettings: [, (_) => de_RouteSettingsMap(_, context), `routeSettings`],
        StageName: [, __expectString, `stageName`],
        StageVariables: [, _json, `stageVariables`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateStageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateVpcLinkCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        Name: [, __expectString, `name`],
        SecurityGroupIds: [, _json, `securityGroupIds`],
        SubnetIds: [, _json, `subnetIds`],
        Tags: [, _json, `tags`],
        VpcLinkId: [, __expectString, `vpcLinkId`],
        VpcLinkStatus: [, __expectString, `vpcLinkStatus`],
        VpcLinkStatusMessage: [, __expectString, `vpcLinkStatusMessage`],
        VpcLinkVersion: [, __expectString, `vpcLinkVersion`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateVpcLinkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteAccessLogSettingsCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteAccessLogSettingsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteAccessLogSettingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteApiCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteApiCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteApiMappingCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteApiMappingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteApiMappingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteCorsConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteCorsConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteCorsConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteDeploymentCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteDomainNameCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteDomainNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteIntegrationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteIntegrationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteIntegrationResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteIntegrationResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteModelCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteModelCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteRouteCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteRouteCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteRouteCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteRouteRequestParameterCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteRouteRequestParameterCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteRouteRequestParameterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteRouteResponseCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteRouteResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteRouteResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteRouteSettingsCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteRouteSettingsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteRouteSettingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteStageCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteStageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteStageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteVpcLinkCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteVpcLinkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ExportApiCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ExportApiCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = await collectBody(output.body, context);
    contents.body = data;
    return contents;
};
const de_ExportApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetApiCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetApiCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApiEndpoint: [, __expectString, `apiEndpoint`],
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        ApiId: [, __expectString, `apiId`],
        ApiKeySelectionExpression: [, __expectString, `apiKeySelectionExpression`],
        CorsConfiguration: [, (_) => de_Cors(_, context), `corsConfiguration`],
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        Description: [, __expectString, `description`],
        DisableExecuteApiEndpoint: [, __expectBoolean, `disableExecuteApiEndpoint`],
        DisableSchemaValidation: [, __expectBoolean, `disableSchemaValidation`],
        ImportInfo: [, _json, `importInfo`],
        Name: [, __expectString, `name`],
        ProtocolType: [, __expectString, `protocolType`],
        RouteSelectionExpression: [, __expectString, `routeSelectionExpression`],
        Tags: [, _json, `tags`],
        Version: [, __expectString, `version`],
        Warnings: [, _json, `warnings`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetApiMappingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetApiMappingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApiId: [, __expectString, `apiId`],
        ApiMappingId: [, __expectString, `apiMappingId`],
        ApiMappingKey: [, __expectString, `apiMappingKey`],
        Stage: [, __expectString, `stage`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetApiMappingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetApiMappingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetApiMappingsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: [, (_) => de___listOfApiMapping(_, context), `items`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetApiMappingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetApisCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetApisCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: [, (_) => de___listOfApi(_, context), `items`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetApisCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AuthorizerCredentialsArn: [, __expectString, `authorizerCredentialsArn`],
        AuthorizerId: [, __expectString, `authorizerId`],
        AuthorizerPayloadFormatVersion: [, __expectString, `authorizerPayloadFormatVersion`],
        AuthorizerResultTtlInSeconds: [, __expectInt32, `authorizerResultTtlInSeconds`],
        AuthorizerType: [, __expectString, `authorizerType`],
        AuthorizerUri: [, __expectString, `authorizerUri`],
        EnableSimpleResponses: [, __expectBoolean, `enableSimpleResponses`],
        IdentitySource: [, _json, `identitySource`],
        IdentityValidationExpression: [, __expectString, `identityValidationExpression`],
        JwtConfiguration: [, (_) => de_JWTConfiguration(_, context), `jwtConfiguration`],
        Name: [, __expectString, `name`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetAuthorizersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAuthorizersCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: [, (_) => de___listOfAuthorizer(_, context), `items`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetAuthorizersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDeploymentCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AutoDeployed: [, __expectBoolean, `autoDeployed`],
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        DeploymentId: [, __expectString, `deploymentId`],
        DeploymentStatus: [, __expectString, `deploymentStatus`],
        DeploymentStatusMessage: [, __expectString, `deploymentStatusMessage`],
        Description: [, __expectString, `description`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetDeploymentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDeploymentsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: [, (_) => de___listOfDeployment(_, context), `items`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetDeploymentsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDomainNameCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApiMappingSelectionExpression: [, __expectString, `apiMappingSelectionExpression`],
        DomainName: [, __expectString, `domainName`],
        DomainNameConfigurations: [, (_) => de_DomainNameConfigurations(_, context), `domainNameConfigurations`],
        MutualTlsAuthentication: [, (_) => de_MutualTlsAuthentication(_, context), `mutualTlsAuthentication`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetDomainNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetDomainNamesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDomainNamesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: [, (_) => de___listOfDomainName(_, context), `items`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetDomainNamesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetIntegrationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        ConnectionId: [, __expectString, `connectionId`],
        ConnectionType: [, __expectString, `connectionType`],
        ContentHandlingStrategy: [, __expectString, `contentHandlingStrategy`],
        CredentialsArn: [, __expectString, `credentialsArn`],
        Description: [, __expectString, `description`],
        IntegrationId: [, __expectString, `integrationId`],
        IntegrationMethod: [, __expectString, `integrationMethod`],
        IntegrationResponseSelectionExpression: [, __expectString, `integrationResponseSelectionExpression`],
        IntegrationSubtype: [, __expectString, `integrationSubtype`],
        IntegrationType: [, __expectString, `integrationType`],
        IntegrationUri: [, __expectString, `integrationUri`],
        PassthroughBehavior: [, __expectString, `passthroughBehavior`],
        PayloadFormatVersion: [, __expectString, `payloadFormatVersion`],
        RequestParameters: [, _json, `requestParameters`],
        RequestTemplates: [, _json, `requestTemplates`],
        ResponseParameters: [, _json, `responseParameters`],
        TemplateSelectionExpression: [, __expectString, `templateSelectionExpression`],
        TimeoutInMillis: [, __expectInt32, `timeoutInMillis`],
        TlsConfig: [, (_) => de_TlsConfig(_, context), `tlsConfig`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetIntegrationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetIntegrationResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ContentHandlingStrategy: [, __expectString, `contentHandlingStrategy`],
        IntegrationResponseId: [, __expectString, `integrationResponseId`],
        IntegrationResponseKey: [, __expectString, `integrationResponseKey`],
        ResponseParameters: [, _json, `responseParameters`],
        ResponseTemplates: [, _json, `responseTemplates`],
        TemplateSelectionExpression: [, __expectString, `templateSelectionExpression`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetIntegrationResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetIntegrationResponsesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetIntegrationResponsesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: [, (_) => de___listOfIntegrationResponse(_, context), `items`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetIntegrationResponsesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetIntegrationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetIntegrationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: [, (_) => de___listOfIntegration(_, context), `items`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetIntegrationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetModelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetModelCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ContentType: [, __expectString, `contentType`],
        Description: [, __expectString, `description`],
        ModelId: [, __expectString, `modelId`],
        Name: [, __expectString, `name`],
        Schema: [, __expectString, `schema`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetModelsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetModelsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: [, (_) => de___listOfModel(_, context), `items`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetModelsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetModelTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetModelTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Value: [, __expectString, `value`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetModelTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetRouteCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRouteCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        ApiKeyRequired: [, __expectBoolean, `apiKeyRequired`],
        AuthorizationScopes: [, _json, `authorizationScopes`],
        AuthorizationType: [, __expectString, `authorizationType`],
        AuthorizerId: [, __expectString, `authorizerId`],
        ModelSelectionExpression: [, __expectString, `modelSelectionExpression`],
        OperationName: [, __expectString, `operationName`],
        RequestModels: [, _json, `requestModels`],
        RequestParameters: [, (_) => de_RouteParameters(_, context), `requestParameters`],
        RouteId: [, __expectString, `routeId`],
        RouteKey: [, __expectString, `routeKey`],
        RouteResponseSelectionExpression: [, __expectString, `routeResponseSelectionExpression`],
        Target: [, __expectString, `target`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetRouteCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetRouteResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRouteResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ModelSelectionExpression: [, __expectString, `modelSelectionExpression`],
        ResponseModels: [, _json, `responseModels`],
        ResponseParameters: [, (_) => de_RouteParameters(_, context), `responseParameters`],
        RouteResponseId: [, __expectString, `routeResponseId`],
        RouteResponseKey: [, __expectString, `routeResponseKey`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetRouteResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetRouteResponsesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRouteResponsesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: [, (_) => de___listOfRouteResponse(_, context), `items`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetRouteResponsesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetRoutesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRoutesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: [, (_) => de___listOfRoute(_, context), `items`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetRoutesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetStageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetStageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AccessLogSettings: [, (_) => de_AccessLogSettings(_, context), `accessLogSettings`],
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        AutoDeploy: [, __expectBoolean, `autoDeploy`],
        ClientCertificateId: [, __expectString, `clientCertificateId`],
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        DefaultRouteSettings: [, (_) => de_RouteSettings(_, context), `defaultRouteSettings`],
        DeploymentId: [, __expectString, `deploymentId`],
        Description: [, __expectString, `description`],
        LastDeploymentStatusMessage: [, __expectString, `lastDeploymentStatusMessage`],
        LastUpdatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `lastUpdatedDate`],
        RouteSettings: [, (_) => de_RouteSettingsMap(_, context), `routeSettings`],
        StageName: [, __expectString, `stageName`],
        StageVariables: [, _json, `stageVariables`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetStageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetStagesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetStagesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: [, (_) => de___listOfStage(_, context), `items`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetStagesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetTagsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetTagsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetVpcLinkCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        Name: [, __expectString, `name`],
        SecurityGroupIds: [, _json, `securityGroupIds`],
        SubnetIds: [, _json, `subnetIds`],
        Tags: [, _json, `tags`],
        VpcLinkId: [, __expectString, `vpcLinkId`],
        VpcLinkStatus: [, __expectString, `vpcLinkStatus`],
        VpcLinkStatusMessage: [, __expectString, `vpcLinkStatusMessage`],
        VpcLinkVersion: [, __expectString, `vpcLinkVersion`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetVpcLinkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetVpcLinksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetVpcLinksCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: [, (_) => de___listOfVpcLink(_, context), `items`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetVpcLinksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ImportApiCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_ImportApiCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApiEndpoint: [, __expectString, `apiEndpoint`],
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        ApiId: [, __expectString, `apiId`],
        ApiKeySelectionExpression: [, __expectString, `apiKeySelectionExpression`],
        CorsConfiguration: [, (_) => de_Cors(_, context), `corsConfiguration`],
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        Description: [, __expectString, `description`],
        DisableExecuteApiEndpoint: [, __expectBoolean, `disableExecuteApiEndpoint`],
        DisableSchemaValidation: [, __expectBoolean, `disableSchemaValidation`],
        ImportInfo: [, _json, `importInfo`],
        Name: [, __expectString, `name`],
        ProtocolType: [, __expectString, `protocolType`],
        RouteSelectionExpression: [, __expectString, `routeSelectionExpression`],
        Tags: [, _json, `tags`],
        Version: [, __expectString, `version`],
        Warnings: [, _json, `warnings`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ImportApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ReimportApiCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_ReimportApiCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApiEndpoint: [, __expectString, `apiEndpoint`],
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        ApiId: [, __expectString, `apiId`],
        ApiKeySelectionExpression: [, __expectString, `apiKeySelectionExpression`],
        CorsConfiguration: [, (_) => de_Cors(_, context), `corsConfiguration`],
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        Description: [, __expectString, `description`],
        DisableExecuteApiEndpoint: [, __expectBoolean, `disableExecuteApiEndpoint`],
        DisableSchemaValidation: [, __expectBoolean, `disableSchemaValidation`],
        ImportInfo: [, _json, `importInfo`],
        Name: [, __expectString, `name`],
        ProtocolType: [, __expectString, `protocolType`],
        RouteSelectionExpression: [, __expectString, `routeSelectionExpression`],
        Tags: [, _json, `tags`],
        Version: [, __expectString, `version`],
        Warnings: [, _json, `warnings`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ReimportApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ResetAuthorizersCacheCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_ResetAuthorizersCacheCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_ResetAuthorizersCacheCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateApiCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateApiCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApiEndpoint: [, __expectString, `apiEndpoint`],
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        ApiId: [, __expectString, `apiId`],
        ApiKeySelectionExpression: [, __expectString, `apiKeySelectionExpression`],
        CorsConfiguration: [, (_) => de_Cors(_, context), `corsConfiguration`],
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        Description: [, __expectString, `description`],
        DisableExecuteApiEndpoint: [, __expectBoolean, `disableExecuteApiEndpoint`],
        DisableSchemaValidation: [, __expectBoolean, `disableSchemaValidation`],
        ImportInfo: [, _json, `importInfo`],
        Name: [, __expectString, `name`],
        ProtocolType: [, __expectString, `protocolType`],
        RouteSelectionExpression: [, __expectString, `routeSelectionExpression`],
        Tags: [, _json, `tags`],
        Version: [, __expectString, `version`],
        Warnings: [, _json, `warnings`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateApiMappingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateApiMappingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApiId: [, __expectString, `apiId`],
        ApiMappingId: [, __expectString, `apiMappingId`],
        ApiMappingKey: [, __expectString, `apiMappingKey`],
        Stage: [, __expectString, `stage`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateApiMappingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AuthorizerCredentialsArn: [, __expectString, `authorizerCredentialsArn`],
        AuthorizerId: [, __expectString, `authorizerId`],
        AuthorizerPayloadFormatVersion: [, __expectString, `authorizerPayloadFormatVersion`],
        AuthorizerResultTtlInSeconds: [, __expectInt32, `authorizerResultTtlInSeconds`],
        AuthorizerType: [, __expectString, `authorizerType`],
        AuthorizerUri: [, __expectString, `authorizerUri`],
        EnableSimpleResponses: [, __expectBoolean, `enableSimpleResponses`],
        IdentitySource: [, _json, `identitySource`],
        IdentityValidationExpression: [, __expectString, `identityValidationExpression`],
        JwtConfiguration: [, (_) => de_JWTConfiguration(_, context), `jwtConfiguration`],
        Name: [, __expectString, `name`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDeploymentCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AutoDeployed: [, __expectBoolean, `autoDeployed`],
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        DeploymentId: [, __expectString, `deploymentId`],
        DeploymentStatus: [, __expectString, `deploymentStatus`],
        DeploymentStatusMessage: [, __expectString, `deploymentStatusMessage`],
        Description: [, __expectString, `description`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDomainNameCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApiMappingSelectionExpression: [, __expectString, `apiMappingSelectionExpression`],
        DomainName: [, __expectString, `domainName`],
        DomainNameConfigurations: [, (_) => de_DomainNameConfigurations(_, context), `domainNameConfigurations`],
        MutualTlsAuthentication: [, (_) => de_MutualTlsAuthentication(_, context), `mutualTlsAuthentication`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateDomainNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateIntegrationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        ConnectionId: [, __expectString, `connectionId`],
        ConnectionType: [, __expectString, `connectionType`],
        ContentHandlingStrategy: [, __expectString, `contentHandlingStrategy`],
        CredentialsArn: [, __expectString, `credentialsArn`],
        Description: [, __expectString, `description`],
        IntegrationId: [, __expectString, `integrationId`],
        IntegrationMethod: [, __expectString, `integrationMethod`],
        IntegrationResponseSelectionExpression: [, __expectString, `integrationResponseSelectionExpression`],
        IntegrationSubtype: [, __expectString, `integrationSubtype`],
        IntegrationType: [, __expectString, `integrationType`],
        IntegrationUri: [, __expectString, `integrationUri`],
        PassthroughBehavior: [, __expectString, `passthroughBehavior`],
        PayloadFormatVersion: [, __expectString, `payloadFormatVersion`],
        RequestParameters: [, _json, `requestParameters`],
        RequestTemplates: [, _json, `requestTemplates`],
        ResponseParameters: [, _json, `responseParameters`],
        TemplateSelectionExpression: [, __expectString, `templateSelectionExpression`],
        TimeoutInMillis: [, __expectInt32, `timeoutInMillis`],
        TlsConfig: [, (_) => de_TlsConfig(_, context), `tlsConfig`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateIntegrationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateIntegrationResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ContentHandlingStrategy: [, __expectString, `contentHandlingStrategy`],
        IntegrationResponseId: [, __expectString, `integrationResponseId`],
        IntegrationResponseKey: [, __expectString, `integrationResponseKey`],
        ResponseParameters: [, _json, `responseParameters`],
        ResponseTemplates: [, _json, `responseTemplates`],
        TemplateSelectionExpression: [, __expectString, `templateSelectionExpression`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateIntegrationResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateModelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateModelCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ContentType: [, __expectString, `contentType`],
        Description: [, __expectString, `description`],
        ModelId: [, __expectString, `modelId`],
        Name: [, __expectString, `name`],
        Schema: [, __expectString, `schema`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateRouteCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateRouteCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        ApiKeyRequired: [, __expectBoolean, `apiKeyRequired`],
        AuthorizationScopes: [, _json, `authorizationScopes`],
        AuthorizationType: [, __expectString, `authorizationType`],
        AuthorizerId: [, __expectString, `authorizerId`],
        ModelSelectionExpression: [, __expectString, `modelSelectionExpression`],
        OperationName: [, __expectString, `operationName`],
        RequestModels: [, _json, `requestModels`],
        RequestParameters: [, (_) => de_RouteParameters(_, context), `requestParameters`],
        RouteId: [, __expectString, `routeId`],
        RouteKey: [, __expectString, `routeKey`],
        RouteResponseSelectionExpression: [, __expectString, `routeResponseSelectionExpression`],
        Target: [, __expectString, `target`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateRouteCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateRouteResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateRouteResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ModelSelectionExpression: [, __expectString, `modelSelectionExpression`],
        ResponseModels: [, _json, `responseModels`],
        ResponseParameters: [, (_) => de_RouteParameters(_, context), `responseParameters`],
        RouteResponseId: [, __expectString, `routeResponseId`],
        RouteResponseKey: [, __expectString, `routeResponseKey`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateRouteResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateStageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateStageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AccessLogSettings: [, (_) => de_AccessLogSettings(_, context), `accessLogSettings`],
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        AutoDeploy: [, __expectBoolean, `autoDeploy`],
        ClientCertificateId: [, __expectString, `clientCertificateId`],
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        DefaultRouteSettings: [, (_) => de_RouteSettings(_, context), `defaultRouteSettings`],
        DeploymentId: [, __expectString, `deploymentId`],
        Description: [, __expectString, `description`],
        LastDeploymentStatusMessage: [, __expectString, `lastDeploymentStatusMessage`],
        LastUpdatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `lastUpdatedDate`],
        RouteSettings: [, (_) => de_RouteSettingsMap(_, context), `routeSettings`],
        StageName: [, __expectString, `stageName`],
        StageVariables: [, _json, `stageVariables`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateStageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigatewayv2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateVpcLinkCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        Name: [, __expectString, `name`],
        SecurityGroupIds: [, _json, `securityGroupIds`],
        SubnetIds: [, _json, `subnetIds`],
        Tags: [, _json, `tags`],
        VpcLinkId: [, __expectString, `vpcLinkId`],
        VpcLinkStatus: [, __expectString, `vpcLinkStatus`],
        VpcLinkStatusMessage: [, __expectString, `vpcLinkStatusMessage`],
        VpcLinkVersion: [, __expectString, `vpcLinkVersion`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateVpcLinkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigatewayv2#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigatewayv2#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigatewayv2#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_BadRequestExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new BadRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_NotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
        ResourceType: [, __expectString, `resourceType`],
    });
    Object.assign(contents, doc);
    const exception = new NotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        LimitType: [, __expectString, `limitType`],
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_AccessLogSettings = (input, context) => {
    return take(input, {
        destinationArn: [, , `DestinationArn`],
        format: [, , `Format`],
    });
};
const se_Cors = (input, context) => {
    return take(input, {
        allowCredentials: [, , `AllowCredentials`],
        allowHeaders: [, _json, `AllowHeaders`],
        allowMethods: [, _json, `AllowMethods`],
        allowOrigins: [, _json, `AllowOrigins`],
        exposeHeaders: [, _json, `ExposeHeaders`],
        maxAge: [, , `MaxAge`],
    });
};
const se_DomainNameConfiguration = (input, context) => {
    return take(input, {
        apiGatewayDomainName: [, , `ApiGatewayDomainName`],
        certificateArn: [, , `CertificateArn`],
        certificateName: [, , `CertificateName`],
        certificateUploadDate: [, (_) => _.toISOString().split(".")[0] + "Z", `CertificateUploadDate`],
        domainNameStatus: [, , `DomainNameStatus`],
        domainNameStatusMessage: [, , `DomainNameStatusMessage`],
        endpointType: [, , `EndpointType`],
        hostedZoneId: [, , `HostedZoneId`],
        ownershipVerificationCertificateArn: [, , `OwnershipVerificationCertificateArn`],
        securityPolicy: [, , `SecurityPolicy`],
    });
};
const se_DomainNameConfigurations = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_DomainNameConfiguration(entry, context);
    });
};
const se_JWTConfiguration = (input, context) => {
    return take(input, {
        audience: [, _json, `Audience`],
        issuer: [, , `Issuer`],
    });
};
const se_MutualTlsAuthenticationInput = (input, context) => {
    return take(input, {
        truststoreUri: [, , `TruststoreUri`],
        truststoreVersion: [, , `TruststoreVersion`],
    });
};
const se_ParameterConstraints = (input, context) => {
    return take(input, {
        required: [, , `Required`],
    });
};
const se_RouteParameters = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_ParameterConstraints(value, context);
        return acc;
    }, {});
};
const se_RouteSettings = (input, context) => {
    return take(input, {
        dataTraceEnabled: [, , `DataTraceEnabled`],
        detailedMetricsEnabled: [, , `DetailedMetricsEnabled`],
        loggingLevel: [, , `LoggingLevel`],
        throttlingBurstLimit: [, , `ThrottlingBurstLimit`],
        throttlingRateLimit: [, __serializeFloat, `ThrottlingRateLimit`],
    });
};
const se_RouteSettingsMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_RouteSettings(value, context);
        return acc;
    }, {});
};
const se_TlsConfigInput = (input, context) => {
    return take(input, {
        serverNameToVerify: [, , `ServerNameToVerify`],
    });
};
const de___listOfApi = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Api(entry, context);
    });
    return retVal;
};
const de___listOfApiMapping = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ApiMapping(entry, context);
    });
    return retVal;
};
const de___listOfAuthorizer = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Authorizer(entry, context);
    });
    return retVal;
};
const de___listOfDeployment = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Deployment(entry, context);
    });
    return retVal;
};
const de___listOfDomainName = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DomainName(entry, context);
    });
    return retVal;
};
const de___listOfIntegration = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Integration(entry, context);
    });
    return retVal;
};
const de___listOfIntegrationResponse = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IntegrationResponse(entry, context);
    });
    return retVal;
};
const de___listOfModel = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Model(entry, context);
    });
    return retVal;
};
const de___listOfRoute = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Route(entry, context);
    });
    return retVal;
};
const de___listOfRouteResponse = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteResponse(entry, context);
    });
    return retVal;
};
const de___listOfStage = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Stage(entry, context);
    });
    return retVal;
};
const de___listOfVpcLink = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcLink(entry, context);
    });
    return retVal;
};
const de_AccessLogSettings = (output, context) => {
    return take(output, {
        DestinationArn: [, __expectString, `destinationArn`],
        Format: [, __expectString, `format`],
    });
};
const de_Api = (output, context) => {
    return take(output, {
        ApiEndpoint: [, __expectString, `apiEndpoint`],
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        ApiId: [, __expectString, `apiId`],
        ApiKeySelectionExpression: [, __expectString, `apiKeySelectionExpression`],
        CorsConfiguration: [, (_) => de_Cors(_, context), `corsConfiguration`],
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        Description: [, __expectString, `description`],
        DisableExecuteApiEndpoint: [, __expectBoolean, `disableExecuteApiEndpoint`],
        DisableSchemaValidation: [, __expectBoolean, `disableSchemaValidation`],
        ImportInfo: [, _json, `importInfo`],
        Name: [, __expectString, `name`],
        ProtocolType: [, __expectString, `protocolType`],
        RouteSelectionExpression: [, __expectString, `routeSelectionExpression`],
        Tags: [, _json, `tags`],
        Version: [, __expectString, `version`],
        Warnings: [, _json, `warnings`],
    });
};
const de_ApiMapping = (output, context) => {
    return take(output, {
        ApiId: [, __expectString, `apiId`],
        ApiMappingId: [, __expectString, `apiMappingId`],
        ApiMappingKey: [, __expectString, `apiMappingKey`],
        Stage: [, __expectString, `stage`],
    });
};
const de_Authorizer = (output, context) => {
    return take(output, {
        AuthorizerCredentialsArn: [, __expectString, `authorizerCredentialsArn`],
        AuthorizerId: [, __expectString, `authorizerId`],
        AuthorizerPayloadFormatVersion: [, __expectString, `authorizerPayloadFormatVersion`],
        AuthorizerResultTtlInSeconds: [, __expectInt32, `authorizerResultTtlInSeconds`],
        AuthorizerType: [, __expectString, `authorizerType`],
        AuthorizerUri: [, __expectString, `authorizerUri`],
        EnableSimpleResponses: [, __expectBoolean, `enableSimpleResponses`],
        IdentitySource: [, _json, `identitySource`],
        IdentityValidationExpression: [, __expectString, `identityValidationExpression`],
        JwtConfiguration: [, (_) => de_JWTConfiguration(_, context), `jwtConfiguration`],
        Name: [, __expectString, `name`],
    });
};
const de_Cors = (output, context) => {
    return take(output, {
        AllowCredentials: [, __expectBoolean, `allowCredentials`],
        AllowHeaders: [, _json, `allowHeaders`],
        AllowMethods: [, _json, `allowMethods`],
        AllowOrigins: [, _json, `allowOrigins`],
        ExposeHeaders: [, _json, `exposeHeaders`],
        MaxAge: [, __expectInt32, `maxAge`],
    });
};
const de_Deployment = (output, context) => {
    return take(output, {
        AutoDeployed: [, __expectBoolean, `autoDeployed`],
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        DeploymentId: [, __expectString, `deploymentId`],
        DeploymentStatus: [, __expectString, `deploymentStatus`],
        DeploymentStatusMessage: [, __expectString, `deploymentStatusMessage`],
        Description: [, __expectString, `description`],
    });
};
const de_DomainName = (output, context) => {
    return take(output, {
        ApiMappingSelectionExpression: [, __expectString, `apiMappingSelectionExpression`],
        DomainName: [, __expectString, `domainName`],
        DomainNameConfigurations: [, (_) => de_DomainNameConfigurations(_, context), `domainNameConfigurations`],
        MutualTlsAuthentication: [, (_) => de_MutualTlsAuthentication(_, context), `mutualTlsAuthentication`],
        Tags: [, _json, `tags`],
    });
};
const de_DomainNameConfiguration = (output, context) => {
    return take(output, {
        ApiGatewayDomainName: [, __expectString, `apiGatewayDomainName`],
        CertificateArn: [, __expectString, `certificateArn`],
        CertificateName: [, __expectString, `certificateName`],
        CertificateUploadDate: [
            ,
            (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
            `certificateUploadDate`,
        ],
        DomainNameStatus: [, __expectString, `domainNameStatus`],
        DomainNameStatusMessage: [, __expectString, `domainNameStatusMessage`],
        EndpointType: [, __expectString, `endpointType`],
        HostedZoneId: [, __expectString, `hostedZoneId`],
        OwnershipVerificationCertificateArn: [, __expectString, `ownershipVerificationCertificateArn`],
        SecurityPolicy: [, __expectString, `securityPolicy`],
    });
};
const de_DomainNameConfigurations = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DomainNameConfiguration(entry, context);
    });
    return retVal;
};
const de_Integration = (output, context) => {
    return take(output, {
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        ConnectionId: [, __expectString, `connectionId`],
        ConnectionType: [, __expectString, `connectionType`],
        ContentHandlingStrategy: [, __expectString, `contentHandlingStrategy`],
        CredentialsArn: [, __expectString, `credentialsArn`],
        Description: [, __expectString, `description`],
        IntegrationId: [, __expectString, `integrationId`],
        IntegrationMethod: [, __expectString, `integrationMethod`],
        IntegrationResponseSelectionExpression: [, __expectString, `integrationResponseSelectionExpression`],
        IntegrationSubtype: [, __expectString, `integrationSubtype`],
        IntegrationType: [, __expectString, `integrationType`],
        IntegrationUri: [, __expectString, `integrationUri`],
        PassthroughBehavior: [, __expectString, `passthroughBehavior`],
        PayloadFormatVersion: [, __expectString, `payloadFormatVersion`],
        RequestParameters: [, _json, `requestParameters`],
        RequestTemplates: [, _json, `requestTemplates`],
        ResponseParameters: [, _json, `responseParameters`],
        TemplateSelectionExpression: [, __expectString, `templateSelectionExpression`],
        TimeoutInMillis: [, __expectInt32, `timeoutInMillis`],
        TlsConfig: [, (_) => de_TlsConfig(_, context), `tlsConfig`],
    });
};
const de_IntegrationResponse = (output, context) => {
    return take(output, {
        ContentHandlingStrategy: [, __expectString, `contentHandlingStrategy`],
        IntegrationResponseId: [, __expectString, `integrationResponseId`],
        IntegrationResponseKey: [, __expectString, `integrationResponseKey`],
        ResponseParameters: [, _json, `responseParameters`],
        ResponseTemplates: [, _json, `responseTemplates`],
        TemplateSelectionExpression: [, __expectString, `templateSelectionExpression`],
    });
};
const de_JWTConfiguration = (output, context) => {
    return take(output, {
        Audience: [, _json, `audience`],
        Issuer: [, __expectString, `issuer`],
    });
};
const de_Model = (output, context) => {
    return take(output, {
        ContentType: [, __expectString, `contentType`],
        Description: [, __expectString, `description`],
        ModelId: [, __expectString, `modelId`],
        Name: [, __expectString, `name`],
        Schema: [, __expectString, `schema`],
    });
};
const de_MutualTlsAuthentication = (output, context) => {
    return take(output, {
        TruststoreUri: [, __expectString, `truststoreUri`],
        TruststoreVersion: [, __expectString, `truststoreVersion`],
        TruststoreWarnings: [, _json, `truststoreWarnings`],
    });
};
const de_ParameterConstraints = (output, context) => {
    return take(output, {
        Required: [, __expectBoolean, `required`],
    });
};
const de_Route = (output, context) => {
    return take(output, {
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        ApiKeyRequired: [, __expectBoolean, `apiKeyRequired`],
        AuthorizationScopes: [, _json, `authorizationScopes`],
        AuthorizationType: [, __expectString, `authorizationType`],
        AuthorizerId: [, __expectString, `authorizerId`],
        ModelSelectionExpression: [, __expectString, `modelSelectionExpression`],
        OperationName: [, __expectString, `operationName`],
        RequestModels: [, _json, `requestModels`],
        RequestParameters: [, (_) => de_RouteParameters(_, context), `requestParameters`],
        RouteId: [, __expectString, `routeId`],
        RouteKey: [, __expectString, `routeKey`],
        RouteResponseSelectionExpression: [, __expectString, `routeResponseSelectionExpression`],
        Target: [, __expectString, `target`],
    });
};
const de_RouteParameters = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_ParameterConstraints(value, context);
        return acc;
    }, {});
};
const de_RouteResponse = (output, context) => {
    return take(output, {
        ModelSelectionExpression: [, __expectString, `modelSelectionExpression`],
        ResponseModels: [, _json, `responseModels`],
        ResponseParameters: [, (_) => de_RouteParameters(_, context), `responseParameters`],
        RouteResponseId: [, __expectString, `routeResponseId`],
        RouteResponseKey: [, __expectString, `routeResponseKey`],
    });
};
const de_RouteSettings = (output, context) => {
    return take(output, {
        DataTraceEnabled: [, __expectBoolean, `dataTraceEnabled`],
        DetailedMetricsEnabled: [, __expectBoolean, `detailedMetricsEnabled`],
        LoggingLevel: [, __expectString, `loggingLevel`],
        ThrottlingBurstLimit: [, __expectInt32, `throttlingBurstLimit`],
        ThrottlingRateLimit: [, __limitedParseDouble, `throttlingRateLimit`],
    });
};
const de_RouteSettingsMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_RouteSettings(value, context);
        return acc;
    }, {});
};
const de_Stage = (output, context) => {
    return take(output, {
        AccessLogSettings: [, (_) => de_AccessLogSettings(_, context), `accessLogSettings`],
        ApiGatewayManaged: [, __expectBoolean, `apiGatewayManaged`],
        AutoDeploy: [, __expectBoolean, `autoDeploy`],
        ClientCertificateId: [, __expectString, `clientCertificateId`],
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        DefaultRouteSettings: [, (_) => de_RouteSettings(_, context), `defaultRouteSettings`],
        DeploymentId: [, __expectString, `deploymentId`],
        Description: [, __expectString, `description`],
        LastDeploymentStatusMessage: [, __expectString, `lastDeploymentStatusMessage`],
        LastUpdatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `lastUpdatedDate`],
        RouteSettings: [, (_) => de_RouteSettingsMap(_, context), `routeSettings`],
        StageName: [, __expectString, `stageName`],
        StageVariables: [, _json, `stageVariables`],
        Tags: [, _json, `tags`],
    });
};
const de_TlsConfig = (output, context) => {
    return take(output, {
        ServerNameToVerify: [, __expectString, `serverNameToVerify`],
    });
};
const de_VpcLink = (output, context) => {
    return take(output, {
        CreatedDate: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `createdDate`],
        Name: [, __expectString, `name`],
        SecurityGroupIds: [, _json, `securityGroupIds`],
        SubnetIds: [, _json, `subnetIds`],
        Tags: [, _json, `tags`],
        VpcLinkId: [, __expectString, `vpcLinkId`],
        VpcLinkStatus: [, __expectString, `vpcLinkStatus`],
        VpcLinkStatusMessage: [, __expectString, `vpcLinkStatusMessage`],
        VpcLinkVersion: [, __expectString, `vpcLinkVersion`],
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
