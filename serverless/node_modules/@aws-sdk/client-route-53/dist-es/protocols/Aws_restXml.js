import { XmlNode as __XmlNode } from "@aws-sdk/xml-builder";
import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { collectBody, decorateServiceException as __decorateServiceException, expectNonNull as __expectNonNull, expectObject as __expectObject, expectString as __expectString, getArrayIfSingleItem as __getArrayIfSingleItem, getValueFromTextNode as __getValueFromTextNode, map, parseBoolean as __parseBoolean, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, resolvedPath as __resolvedPath, strictParseFloat as __strictParseFloat, strictParseInt32 as __strictParseInt32, strictParseLong as __strictParseLong, withBaseException, } from "@smithy/smithy-client";
import { XMLParser } from "fast-xml-parser";
import { CidrBlockInUseException, CidrCollectionAlreadyExistsException, CidrCollectionInUseException, CidrCollectionVersionMismatchException, ConcurrentModification, ConflictingDomainExists, ConflictingTypes, DelegationSetAlreadyCreated, DelegationSetAlreadyReusable, DelegationSetInUse, DelegationSetNotAvailable, DelegationSetNotReusable, DNSSECNotFound, HealthCheckAlreadyExists, HealthCheckInUse, HealthCheckVersionMismatch, HostedZoneAlreadyExists, HostedZoneNotEmpty, HostedZoneNotFound, HostedZoneNotPrivate, HostedZonePartiallyDelegated, IncompatibleVersion, InsufficientCloudWatchLogsResourcePolicy, InvalidArgument, InvalidChangeBatch, InvalidDomainName, InvalidInput, InvalidKeySigningKeyName, InvalidKeySigningKeyStatus, InvalidKMSArn, InvalidPaginationToken, InvalidSigningStatus, InvalidTrafficPolicyDocument, InvalidVPCId, KeySigningKeyAlreadyExists, KeySigningKeyInParentDSRecord, KeySigningKeyInUse, KeySigningKeyWithActiveStatusNotFound, LastVPCAssociation, LimitsExceeded, NoSuchChange, NoSuchCidrCollectionException, NoSuchCidrLocationException, NoSuchCloudWatchLogsLogGroup, NoSuchDelegationSet, NoSuchGeoLocation, NoSuchHealthCheck, NoSuchHostedZone, NoSuchKeySigningKey, NoSuchQueryLoggingConfig, NoSuchTrafficPolicy, NoSuchTrafficPolicyInstance, NotAuthorizedException, PriorRequestNotComplete, PublicZoneVPCAssociation, QueryLoggingConfigAlreadyExists, ThrottlingException, TooManyHealthChecks, TooManyHostedZones, TooManyKeySigningKeys, TooManyTrafficPolicies, TooManyTrafficPolicyInstances, TooManyTrafficPolicyVersionsForCurrentPolicy, TooManyVPCAssociationAuthorizations, TrafficPolicyAlreadyExists, TrafficPolicyInstanceAlreadyExists, TrafficPolicyInUse, VPCAssociationAuthorizationNotFound, VPCAssociationNotFound, } from "../models/models_0";
import { Route53ServiceException as __BaseException } from "../models/Route53ServiceException";
export const se_ActivateKeySigningKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/keysigningkey/{HostedZoneId}/{Name}/activate";
    resolvedPath = __resolvedPath(resolvedPath, input, "HostedZoneId", () => input.HostedZoneId, "{HostedZoneId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_AssociateVPCWithHostedZoneCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/hostedzone/{HostedZoneId}/associatevpc";
    resolvedPath = __resolvedPath(resolvedPath, input, "HostedZoneId", () => input.HostedZoneId, "{HostedZoneId}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("AssociateVPCWithHostedZoneRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.Comment !== undefined) {
        const node = __XmlNode.of("AssociateVPCComment", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    if (input.VPC !== undefined) {
        const node = se_VPC(input.VPC, context).withName("VPC");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_ChangeCidrCollectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/cidrcollection/{Id}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("ChangeCidrCollectionRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.Changes !== undefined) {
        const nodes = se_CidrCollectionChanges(input.Changes, context);
        const containerNode = new __XmlNode("Changes");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.CollectionVersion !== undefined) {
        const node = __XmlNode.of("CollectionVersion", String(input.CollectionVersion)).withName("CollectionVersion");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_ChangeResourceRecordSetsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/hostedzone/{HostedZoneId}/rrset";
    resolvedPath = __resolvedPath(resolvedPath, input, "HostedZoneId", () => input.HostedZoneId, "{HostedZoneId}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("ChangeResourceRecordSetsRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.ChangeBatch !== undefined) {
        const node = se_ChangeBatch(input.ChangeBatch, context).withName("ChangeBatch");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_ChangeTagsForResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/tags/{ResourceType}/{ResourceId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ResourceType", () => input.ResourceType, "{ResourceType}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "ResourceId", () => input.ResourceId, "{ResourceId}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("ChangeTagsForResourceRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.AddTags !== undefined) {
        const nodes = se_TagList(input.AddTags, context);
        const containerNode = new __XmlNode("AddTags");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.RemoveTagKeys !== undefined) {
        const nodes = se_TagKeyList(input.RemoveTagKeys, context);
        const containerNode = new __XmlNode("RemoveTagKeys");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateCidrCollectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/cidrcollection";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateCidrCollectionRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.CallerReference !== undefined) {
        const node = __XmlNode.of("CidrNonce", input.CallerReference).withName("CallerReference");
        bodyNode.addChildNode(node);
    }
    if (input.Name !== undefined) {
        const node = __XmlNode.of("CollectionName", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateHealthCheckCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/healthcheck";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateHealthCheckRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.CallerReference !== undefined) {
        const node = __XmlNode.of("HealthCheckNonce", input.CallerReference).withName("CallerReference");
        bodyNode.addChildNode(node);
    }
    if (input.HealthCheckConfig !== undefined) {
        const node = se_HealthCheckConfig(input.HealthCheckConfig, context).withName("HealthCheckConfig");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateHostedZoneCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/hostedzone";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateHostedZoneRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.CallerReference !== undefined) {
        const node = __XmlNode.of("Nonce", input.CallerReference).withName("CallerReference");
        bodyNode.addChildNode(node);
    }
    if (input.DelegationSetId !== undefined) {
        const node = __XmlNode.of("ResourceId", input.DelegationSetId).withName("DelegationSetId");
        bodyNode.addChildNode(node);
    }
    if (input.HostedZoneConfig !== undefined) {
        const node = se_HostedZoneConfig(input.HostedZoneConfig, context).withName("HostedZoneConfig");
        bodyNode.addChildNode(node);
    }
    if (input.Name !== undefined) {
        const node = __XmlNode.of("DNSName", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    if (input.VPC !== undefined) {
        const node = se_VPC(input.VPC, context).withName("VPC");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateKeySigningKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/keysigningkey";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateKeySigningKeyRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.CallerReference !== undefined) {
        const node = __XmlNode.of("Nonce", input.CallerReference).withName("CallerReference");
        bodyNode.addChildNode(node);
    }
    if (input.HostedZoneId !== undefined) {
        const node = __XmlNode.of("ResourceId", input.HostedZoneId).withName("HostedZoneId");
        bodyNode.addChildNode(node);
    }
    if (input.KeyManagementServiceArn !== undefined) {
        const node = __XmlNode.of("SigningKeyString", input.KeyManagementServiceArn).withName("KeyManagementServiceArn");
        bodyNode.addChildNode(node);
    }
    if (input.Name !== undefined) {
        const node = __XmlNode.of("SigningKeyName", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    if (input.Status !== undefined) {
        const node = __XmlNode.of("SigningKeyStatus", input.Status).withName("Status");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateQueryLoggingConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/queryloggingconfig";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateQueryLoggingConfigRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.CloudWatchLogsLogGroupArn !== undefined) {
        const node = __XmlNode
            .of("CloudWatchLogsLogGroupArn", input.CloudWatchLogsLogGroupArn)
            .withName("CloudWatchLogsLogGroupArn");
        bodyNode.addChildNode(node);
    }
    if (input.HostedZoneId !== undefined) {
        const node = __XmlNode.of("ResourceId", input.HostedZoneId).withName("HostedZoneId");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateReusableDelegationSetCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/delegationset";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateReusableDelegationSetRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.CallerReference !== undefined) {
        const node = __XmlNode.of("Nonce", input.CallerReference).withName("CallerReference");
        bodyNode.addChildNode(node);
    }
    if (input.HostedZoneId !== undefined) {
        const node = __XmlNode.of("ResourceId", input.HostedZoneId).withName("HostedZoneId");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateTrafficPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/trafficpolicy";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateTrafficPolicyRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.Comment !== undefined) {
        const node = __XmlNode.of("TrafficPolicyComment", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    if (input.Document !== undefined) {
        const node = __XmlNode.of("TrafficPolicyDocument", input.Document).withName("Document");
        bodyNode.addChildNode(node);
    }
    if (input.Name !== undefined) {
        const node = __XmlNode.of("TrafficPolicyName", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateTrafficPolicyInstanceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/trafficpolicyinstance";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateTrafficPolicyInstanceRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.HostedZoneId !== undefined) {
        const node = __XmlNode.of("ResourceId", input.HostedZoneId).withName("HostedZoneId");
        bodyNode.addChildNode(node);
    }
    if (input.Name !== undefined) {
        const node = __XmlNode.of("DNSName", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    if (input.TTL !== undefined) {
        const node = __XmlNode.of("TTL", String(input.TTL)).withName("TTL");
        bodyNode.addChildNode(node);
    }
    if (input.TrafficPolicyId !== undefined) {
        const node = __XmlNode.of("TrafficPolicyId", input.TrafficPolicyId).withName("TrafficPolicyId");
        bodyNode.addChildNode(node);
    }
    if (input.TrafficPolicyVersion !== undefined) {
        const node = __XmlNode
            .of("TrafficPolicyVersion", String(input.TrafficPolicyVersion))
            .withName("TrafficPolicyVersion");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateTrafficPolicyVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/trafficpolicy/{Id}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateTrafficPolicyVersionRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.Comment !== undefined) {
        const node = __XmlNode.of("TrafficPolicyComment", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    if (input.Document !== undefined) {
        const node = __XmlNode.of("TrafficPolicyDocument", input.Document).withName("Document");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateVPCAssociationAuthorizationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/hostedzone/{HostedZoneId}/authorizevpcassociation";
    resolvedPath = __resolvedPath(resolvedPath, input, "HostedZoneId", () => input.HostedZoneId, "{HostedZoneId}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateVPCAssociationAuthorizationRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.VPC !== undefined) {
        const node = se_VPC(input.VPC, context).withName("VPC");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeactivateKeySigningKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/keysigningkey/{HostedZoneId}/{Name}/deactivate";
    resolvedPath = __resolvedPath(resolvedPath, input, "HostedZoneId", () => input.HostedZoneId, "{HostedZoneId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteCidrCollectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/cidrcollection/{Id}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteHealthCheckCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/healthcheck/{HealthCheckId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "HealthCheckId", () => input.HealthCheckId, "{HealthCheckId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteHostedZoneCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/hostedzone/{Id}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteKeySigningKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/keysigningkey/{HostedZoneId}/{Name}";
    resolvedPath = __resolvedPath(resolvedPath, input, "HostedZoneId", () => input.HostedZoneId, "{HostedZoneId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteQueryLoggingConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/queryloggingconfig/{Id}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteReusableDelegationSetCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/delegationset/{Id}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteTrafficPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/trafficpolicy/{Id}/{Version}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "Version", () => input.Version.toString(), "{Version}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteTrafficPolicyInstanceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/trafficpolicyinstance/{Id}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteVPCAssociationAuthorizationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/hostedzone/{HostedZoneId}/deauthorizevpcassociation";
    resolvedPath = __resolvedPath(resolvedPath, input, "HostedZoneId", () => input.HostedZoneId, "{HostedZoneId}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("DeleteVPCAssociationAuthorizationRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.VPC !== undefined) {
        const node = se_VPC(input.VPC, context).withName("VPC");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DisableHostedZoneDNSSECCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/hostedzone/{HostedZoneId}/disable-dnssec";
    resolvedPath = __resolvedPath(resolvedPath, input, "HostedZoneId", () => input.HostedZoneId, "{HostedZoneId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DisassociateVPCFromHostedZoneCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/hostedzone/{HostedZoneId}/disassociatevpc";
    resolvedPath = __resolvedPath(resolvedPath, input, "HostedZoneId", () => input.HostedZoneId, "{HostedZoneId}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("DisassociateVPCFromHostedZoneRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.Comment !== undefined) {
        const node = __XmlNode.of("DisassociateVPCComment", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    if (input.VPC !== undefined) {
        const node = se_VPC(input.VPC, context).withName("VPC");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_EnableHostedZoneDNSSECCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/hostedzone/{HostedZoneId}/enable-dnssec";
    resolvedPath = __resolvedPath(resolvedPath, input, "HostedZoneId", () => input.HostedZoneId, "{HostedZoneId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetAccountLimitCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/accountlimit/{Type}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Type", () => input.Type, "{Type}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetChangeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/change/{Id}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetCheckerIpRangesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/checkeripranges";
    let body;
    body = "";
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetDNSSECCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/hostedzone/{HostedZoneId}/dnssec";
    resolvedPath = __resolvedPath(resolvedPath, input, "HostedZoneId", () => input.HostedZoneId, "{HostedZoneId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetGeoLocationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/geolocation";
    const query = map({
        continentcode: [, input.ContinentCode],
        countrycode: [, input.CountryCode],
        subdivisioncode: [, input.SubdivisionCode],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetHealthCheckCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/healthcheck/{HealthCheckId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "HealthCheckId", () => input.HealthCheckId, "{HealthCheckId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetHealthCheckCountCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/healthcheckcount";
    let body;
    body = "";
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetHealthCheckLastFailureReasonCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/healthcheck/{HealthCheckId}/lastfailurereason";
    resolvedPath = __resolvedPath(resolvedPath, input, "HealthCheckId", () => input.HealthCheckId, "{HealthCheckId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetHealthCheckStatusCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/healthcheck/{HealthCheckId}/status";
    resolvedPath = __resolvedPath(resolvedPath, input, "HealthCheckId", () => input.HealthCheckId, "{HealthCheckId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetHostedZoneCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/hostedzone/{Id}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetHostedZoneCountCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/hostedzonecount";
    let body;
    body = "";
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetHostedZoneLimitCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/hostedzonelimit/{HostedZoneId}/{Type}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Type", () => input.Type, "{Type}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "HostedZoneId", () => input.HostedZoneId, "{HostedZoneId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetQueryLoggingConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/queryloggingconfig/{Id}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetReusableDelegationSetCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/delegationset/{Id}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetReusableDelegationSetLimitCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/reusabledelegationsetlimit/{DelegationSetId}/{Type}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Type", () => input.Type, "{Type}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "DelegationSetId", () => input.DelegationSetId, "{DelegationSetId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetTrafficPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/trafficpolicy/{Id}/{Version}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "Version", () => input.Version.toString(), "{Version}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetTrafficPolicyInstanceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/trafficpolicyinstance/{Id}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetTrafficPolicyInstanceCountCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/trafficpolicyinstancecount";
    let body;
    body = "";
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_ListCidrBlocksCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/cidrcollection/{CollectionId}/cidrblocks";
    resolvedPath = __resolvedPath(resolvedPath, input, "CollectionId", () => input.CollectionId, "{CollectionId}", false);
    const query = map({
        location: [, input.LocationName],
        nexttoken: [, input.NextToken],
        maxresults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListCidrCollectionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/cidrcollection";
    const query = map({
        nexttoken: [, input.NextToken],
        maxresults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListCidrLocationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/cidrcollection/{CollectionId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "CollectionId", () => input.CollectionId, "{CollectionId}", false);
    const query = map({
        nexttoken: [, input.NextToken],
        maxresults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListGeoLocationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/geolocations";
    const query = map({
        startcontinentcode: [, input.StartContinentCode],
        startcountrycode: [, input.StartCountryCode],
        startsubdivisioncode: [, input.StartSubdivisionCode],
        maxitems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListHealthChecksCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/healthcheck";
    const query = map({
        marker: [, input.Marker],
        maxitems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListHostedZonesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/hostedzone";
    const query = map({
        marker: [, input.Marker],
        maxitems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
        delegationsetid: [, input.DelegationSetId],
        hostedzonetype: [, input.HostedZoneType],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListHostedZonesByNameCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/hostedzonesbyname";
    const query = map({
        dnsname: [, input.DNSName],
        hostedzoneid: [, input.HostedZoneId],
        maxitems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListHostedZonesByVPCCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/hostedzonesbyvpc";
    const query = map({
        vpcid: [, __expectNonNull(input.VPCId, `VPCId`)],
        vpcregion: [, __expectNonNull(input.VPCRegion, `VPCRegion`)],
        maxitems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
        nexttoken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListQueryLoggingConfigsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/queryloggingconfig";
    const query = map({
        hostedzoneid: [, input.HostedZoneId],
        nexttoken: [, input.NextToken],
        maxresults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListResourceRecordSetsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/hostedzone/{HostedZoneId}/rrset";
    resolvedPath = __resolvedPath(resolvedPath, input, "HostedZoneId", () => input.HostedZoneId, "{HostedZoneId}", false);
    const query = map({
        name: [, input.StartRecordName],
        type: [, input.StartRecordType],
        identifier: [, input.StartRecordIdentifier],
        maxitems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListReusableDelegationSetsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/delegationset";
    const query = map({
        marker: [, input.Marker],
        maxitems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/tags/{ResourceType}/{ResourceId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ResourceType", () => input.ResourceType, "{ResourceType}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "ResourceId", () => input.ResourceId, "{ResourceId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_ListTagsForResourcesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/tags/{ResourceType}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ResourceType", () => input.ResourceType, "{ResourceType}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("ListTagsForResourcesRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.ResourceIds !== undefined) {
        const nodes = se_TagResourceIdList(input.ResourceIds, context);
        const containerNode = new __XmlNode("ResourceIds");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_ListTrafficPoliciesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/trafficpolicies";
    const query = map({
        trafficpolicyid: [, input.TrafficPolicyIdMarker],
        maxitems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListTrafficPolicyInstancesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/trafficpolicyinstances";
    const query = map({
        hostedzoneid: [, input.HostedZoneIdMarker],
        trafficpolicyinstancename: [, input.TrafficPolicyInstanceNameMarker],
        trafficpolicyinstancetype: [, input.TrafficPolicyInstanceTypeMarker],
        maxitems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListTrafficPolicyInstancesByHostedZoneCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/trafficpolicyinstances/hostedzone";
    const query = map({
        id: [, __expectNonNull(input.HostedZoneId, `HostedZoneId`)],
        trafficpolicyinstancename: [, input.TrafficPolicyInstanceNameMarker],
        trafficpolicyinstancetype: [, input.TrafficPolicyInstanceTypeMarker],
        maxitems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListTrafficPolicyInstancesByPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/trafficpolicyinstances/trafficpolicy";
    const query = map({
        id: [, __expectNonNull(input.TrafficPolicyId, `TrafficPolicyId`)],
        version: [
            __expectNonNull(input.TrafficPolicyVersion, `TrafficPolicyVersion`) != null,
            () => input.TrafficPolicyVersion.toString(),
        ],
        hostedzoneid: [, input.HostedZoneIdMarker],
        trafficpolicyinstancename: [, input.TrafficPolicyInstanceNameMarker],
        trafficpolicyinstancetype: [, input.TrafficPolicyInstanceTypeMarker],
        maxitems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListTrafficPolicyVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/trafficpolicies/{Id}/versions";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    const query = map({
        trafficpolicyversion: [, input.TrafficPolicyVersionMarker],
        maxitems: [() => input.MaxItems !== void 0, () => input.MaxItems.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListVPCAssociationAuthorizationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2013-04-01/hostedzone/{HostedZoneId}/authorizevpcassociation";
    resolvedPath = __resolvedPath(resolvedPath, input, "HostedZoneId", () => input.HostedZoneId, "{HostedZoneId}", false);
    const query = map({
        nexttoken: [, input.NextToken],
        maxresults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_TestDNSAnswerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/testdnsanswer";
    const query = map({
        hostedzoneid: [, __expectNonNull(input.HostedZoneId, `HostedZoneId`)],
        recordname: [, __expectNonNull(input.RecordName, `RecordName`)],
        recordtype: [, __expectNonNull(input.RecordType, `RecordType`)],
        resolverip: [, input.ResolverIP],
        edns0clientsubnetip: [, input.EDNS0ClientSubnetIP],
        edns0clientsubnetmask: [, input.EDNS0ClientSubnetMask],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_UpdateHealthCheckCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/healthcheck/{HealthCheckId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "HealthCheckId", () => input.HealthCheckId, "{HealthCheckId}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("UpdateHealthCheckRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.AlarmIdentifier !== undefined) {
        const node = se_AlarmIdentifier(input.AlarmIdentifier, context).withName("AlarmIdentifier");
        bodyNode.addChildNode(node);
    }
    if (input.ChildHealthChecks !== undefined) {
        const nodes = se_ChildHealthCheckList(input.ChildHealthChecks, context);
        const containerNode = new __XmlNode("ChildHealthChecks");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.Disabled !== undefined) {
        const node = __XmlNode.of("Disabled", String(input.Disabled)).withName("Disabled");
        bodyNode.addChildNode(node);
    }
    if (input.EnableSNI !== undefined) {
        const node = __XmlNode.of("EnableSNI", String(input.EnableSNI)).withName("EnableSNI");
        bodyNode.addChildNode(node);
    }
    if (input.FailureThreshold !== undefined) {
        const node = __XmlNode.of("FailureThreshold", String(input.FailureThreshold)).withName("FailureThreshold");
        bodyNode.addChildNode(node);
    }
    if (input.FullyQualifiedDomainName !== undefined) {
        const node = __XmlNode
            .of("FullyQualifiedDomainName", input.FullyQualifiedDomainName)
            .withName("FullyQualifiedDomainName");
        bodyNode.addChildNode(node);
    }
    if (input.HealthCheckVersion !== undefined) {
        const node = __XmlNode.of("HealthCheckVersion", String(input.HealthCheckVersion)).withName("HealthCheckVersion");
        bodyNode.addChildNode(node);
    }
    if (input.HealthThreshold !== undefined) {
        const node = __XmlNode.of("HealthThreshold", String(input.HealthThreshold)).withName("HealthThreshold");
        bodyNode.addChildNode(node);
    }
    if (input.IPAddress !== undefined) {
        const node = __XmlNode.of("IPAddress", input.IPAddress).withName("IPAddress");
        bodyNode.addChildNode(node);
    }
    if (input.InsufficientDataHealthStatus !== undefined) {
        const node = __XmlNode
            .of("InsufficientDataHealthStatus", input.InsufficientDataHealthStatus)
            .withName("InsufficientDataHealthStatus");
        bodyNode.addChildNode(node);
    }
    if (input.Inverted !== undefined) {
        const node = __XmlNode.of("Inverted", String(input.Inverted)).withName("Inverted");
        bodyNode.addChildNode(node);
    }
    if (input.Port !== undefined) {
        const node = __XmlNode.of("Port", String(input.Port)).withName("Port");
        bodyNode.addChildNode(node);
    }
    if (input.Regions !== undefined) {
        const nodes = se_HealthCheckRegionList(input.Regions, context);
        const containerNode = new __XmlNode("Regions");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.ResetElements !== undefined) {
        const nodes = se_ResettableElementNameList(input.ResetElements, context);
        const containerNode = new __XmlNode("ResetElements");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.ResourcePath !== undefined) {
        const node = __XmlNode.of("ResourcePath", input.ResourcePath).withName("ResourcePath");
        bodyNode.addChildNode(node);
    }
    if (input.SearchString !== undefined) {
        const node = __XmlNode.of("SearchString", input.SearchString).withName("SearchString");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateHostedZoneCommentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/hostedzone/{Id}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("UpdateHostedZoneCommentRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.Comment !== undefined) {
        const node = __XmlNode.of("ResourceDescription", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateTrafficPolicyCommentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/trafficpolicy/{Id}/{Version}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "Version", () => input.Version.toString(), "{Version}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("UpdateTrafficPolicyCommentRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.Comment !== undefined) {
        const node = __XmlNode.of("TrafficPolicyComment", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateTrafficPolicyInstanceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/xml",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2013-04-01/trafficpolicyinstance/{Id}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Id", () => input.Id, "{Id}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("UpdateTrafficPolicyInstanceRequest");
    bodyNode.addAttribute("xmlns", "https://route53.amazonaws.com/doc/2013-04-01/");
    if (input.TTL !== undefined) {
        const node = __XmlNode.of("TTL", String(input.TTL)).withName("TTL");
        bodyNode.addChildNode(node);
    }
    if (input.TrafficPolicyId !== undefined) {
        const node = __XmlNode.of("TrafficPolicyId", input.TrafficPolicyId).withName("TrafficPolicyId");
        bodyNode.addChildNode(node);
    }
    if (input.TrafficPolicyVersion !== undefined) {
        const node = __XmlNode
            .of("TrafficPolicyVersion", String(input.TrafficPolicyVersion))
            .withName("TrafficPolicyVersion");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const de_ActivateKeySigningKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ActivateKeySigningKeyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["ChangeInfo"] !== undefined) {
        contents.ChangeInfo = de_ChangeInfo(data["ChangeInfo"], context);
    }
    return contents;
};
const de_ActivateKeySigningKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.route53#ConcurrentModification":
            throw await de_ConcurrentModificationRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "InvalidKMSArn":
        case "com.amazonaws.route53#InvalidKMSArn":
            throw await de_InvalidKMSArnRes(parsedOutput, context);
        case "InvalidKeySigningKeyStatus":
        case "com.amazonaws.route53#InvalidKeySigningKeyStatus":
            throw await de_InvalidKeySigningKeyStatusRes(parsedOutput, context);
        case "InvalidSigningStatus":
        case "com.amazonaws.route53#InvalidSigningStatus":
            throw await de_InvalidSigningStatusRes(parsedOutput, context);
        case "NoSuchKeySigningKey":
        case "com.amazonaws.route53#NoSuchKeySigningKey":
            throw await de_NoSuchKeySigningKeyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_AssociateVPCWithHostedZoneCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AssociateVPCWithHostedZoneCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["ChangeInfo"] !== undefined) {
        contents.ChangeInfo = de_ChangeInfo(data["ChangeInfo"], context);
    }
    return contents;
};
const de_AssociateVPCWithHostedZoneCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingDomainExists":
        case "com.amazonaws.route53#ConflictingDomainExists":
            throw await de_ConflictingDomainExistsRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "InvalidVPCId":
        case "com.amazonaws.route53#InvalidVPCId":
            throw await de_InvalidVPCIdRes(parsedOutput, context);
        case "LimitsExceeded":
        case "com.amazonaws.route53#LimitsExceeded":
            throw await de_LimitsExceededRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.route53#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PriorRequestNotComplete":
        case "com.amazonaws.route53#PriorRequestNotComplete":
            throw await de_PriorRequestNotCompleteRes(parsedOutput, context);
        case "PublicZoneVPCAssociation":
        case "com.amazonaws.route53#PublicZoneVPCAssociation":
            throw await de_PublicZoneVPCAssociationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ChangeCidrCollectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ChangeCidrCollectionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Id"] !== undefined) {
        contents.Id = __expectString(data["Id"]);
    }
    return contents;
};
const de_ChangeCidrCollectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CidrBlockInUseException":
        case "com.amazonaws.route53#CidrBlockInUseException":
            throw await de_CidrBlockInUseExceptionRes(parsedOutput, context);
        case "CidrCollectionVersionMismatchException":
        case "com.amazonaws.route53#CidrCollectionVersionMismatchException":
            throw await de_CidrCollectionVersionMismatchExceptionRes(parsedOutput, context);
        case "ConcurrentModification":
        case "com.amazonaws.route53#ConcurrentModification":
            throw await de_ConcurrentModificationRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "LimitsExceeded":
        case "com.amazonaws.route53#LimitsExceeded":
            throw await de_LimitsExceededRes(parsedOutput, context);
        case "NoSuchCidrCollectionException":
        case "com.amazonaws.route53#NoSuchCidrCollectionException":
            throw await de_NoSuchCidrCollectionExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ChangeResourceRecordSetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ChangeResourceRecordSetsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["ChangeInfo"] !== undefined) {
        contents.ChangeInfo = de_ChangeInfo(data["ChangeInfo"], context);
    }
    return contents;
};
const de_ChangeResourceRecordSetsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidChangeBatch":
        case "com.amazonaws.route53#InvalidChangeBatch":
            throw await de_InvalidChangeBatchRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHealthCheck":
        case "com.amazonaws.route53#NoSuchHealthCheck":
            throw await de_NoSuchHealthCheckRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        case "PriorRequestNotComplete":
        case "com.amazonaws.route53#PriorRequestNotComplete":
            throw await de_PriorRequestNotCompleteRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ChangeTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ChangeTagsForResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_ChangeTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHealthCheck":
        case "com.amazonaws.route53#NoSuchHealthCheck":
            throw await de_NoSuchHealthCheckRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        case "PriorRequestNotComplete":
        case "com.amazonaws.route53#PriorRequestNotComplete":
            throw await de_PriorRequestNotCompleteRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.route53#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateCidrCollectionCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateCidrCollectionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Collection"] !== undefined) {
        contents.Collection = de_CidrCollection(data["Collection"], context);
    }
    return contents;
};
const de_CreateCidrCollectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CidrCollectionAlreadyExistsException":
        case "com.amazonaws.route53#CidrCollectionAlreadyExistsException":
            throw await de_CidrCollectionAlreadyExistsExceptionRes(parsedOutput, context);
        case "ConcurrentModification":
        case "com.amazonaws.route53#ConcurrentModification":
            throw await de_ConcurrentModificationRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "LimitsExceeded":
        case "com.amazonaws.route53#LimitsExceeded":
            throw await de_LimitsExceededRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateHealthCheckCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateHealthCheckCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["HealthCheck"] !== undefined) {
        contents.HealthCheck = de_HealthCheck(data["HealthCheck"], context);
    }
    return contents;
};
const de_CreateHealthCheckCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "HealthCheckAlreadyExists":
        case "com.amazonaws.route53#HealthCheckAlreadyExists":
            throw await de_HealthCheckAlreadyExistsRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "TooManyHealthChecks":
        case "com.amazonaws.route53#TooManyHealthChecks":
            throw await de_TooManyHealthChecksRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateHostedZoneCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateHostedZoneCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["ChangeInfo"] !== undefined) {
        contents.ChangeInfo = de_ChangeInfo(data["ChangeInfo"], context);
    }
    if (data["DelegationSet"] !== undefined) {
        contents.DelegationSet = de_DelegationSet(data["DelegationSet"], context);
    }
    if (data["HostedZone"] !== undefined) {
        contents.HostedZone = de_HostedZone(data["HostedZone"], context);
    }
    if (data["VPC"] !== undefined) {
        contents.VPC = de_VPC(data["VPC"], context);
    }
    return contents;
};
const de_CreateHostedZoneCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingDomainExists":
        case "com.amazonaws.route53#ConflictingDomainExists":
            throw await de_ConflictingDomainExistsRes(parsedOutput, context);
        case "DelegationSetNotAvailable":
        case "com.amazonaws.route53#DelegationSetNotAvailable":
            throw await de_DelegationSetNotAvailableRes(parsedOutput, context);
        case "DelegationSetNotReusable":
        case "com.amazonaws.route53#DelegationSetNotReusable":
            throw await de_DelegationSetNotReusableRes(parsedOutput, context);
        case "HostedZoneAlreadyExists":
        case "com.amazonaws.route53#HostedZoneAlreadyExists":
            throw await de_HostedZoneAlreadyExistsRes(parsedOutput, context);
        case "InvalidDomainName":
        case "com.amazonaws.route53#InvalidDomainName":
            throw await de_InvalidDomainNameRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "InvalidVPCId":
        case "com.amazonaws.route53#InvalidVPCId":
            throw await de_InvalidVPCIdRes(parsedOutput, context);
        case "NoSuchDelegationSet":
        case "com.amazonaws.route53#NoSuchDelegationSet":
            throw await de_NoSuchDelegationSetRes(parsedOutput, context);
        case "TooManyHostedZones":
        case "com.amazonaws.route53#TooManyHostedZones":
            throw await de_TooManyHostedZonesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateKeySigningKeyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateKeySigningKeyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["ChangeInfo"] !== undefined) {
        contents.ChangeInfo = de_ChangeInfo(data["ChangeInfo"], context);
    }
    if (data["KeySigningKey"] !== undefined) {
        contents.KeySigningKey = de_KeySigningKey(data["KeySigningKey"], context);
    }
    return contents;
};
const de_CreateKeySigningKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.route53#ConcurrentModification":
            throw await de_ConcurrentModificationRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.route53#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "InvalidKMSArn":
        case "com.amazonaws.route53#InvalidKMSArn":
            throw await de_InvalidKMSArnRes(parsedOutput, context);
        case "InvalidKeySigningKeyName":
        case "com.amazonaws.route53#InvalidKeySigningKeyName":
            throw await de_InvalidKeySigningKeyNameRes(parsedOutput, context);
        case "InvalidKeySigningKeyStatus":
        case "com.amazonaws.route53#InvalidKeySigningKeyStatus":
            throw await de_InvalidKeySigningKeyStatusRes(parsedOutput, context);
        case "InvalidSigningStatus":
        case "com.amazonaws.route53#InvalidSigningStatus":
            throw await de_InvalidSigningStatusRes(parsedOutput, context);
        case "KeySigningKeyAlreadyExists":
        case "com.amazonaws.route53#KeySigningKeyAlreadyExists":
            throw await de_KeySigningKeyAlreadyExistsRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        case "TooManyKeySigningKeys":
        case "com.amazonaws.route53#TooManyKeySigningKeys":
            throw await de_TooManyKeySigningKeysRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateQueryLoggingConfigCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateQueryLoggingConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["QueryLoggingConfig"] !== undefined) {
        contents.QueryLoggingConfig = de_QueryLoggingConfig(data["QueryLoggingConfig"], context);
    }
    return contents;
};
const de_CreateQueryLoggingConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.route53#ConcurrentModification":
            throw await de_ConcurrentModificationRes(parsedOutput, context);
        case "InsufficientCloudWatchLogsResourcePolicy":
        case "com.amazonaws.route53#InsufficientCloudWatchLogsResourcePolicy":
            throw await de_InsufficientCloudWatchLogsResourcePolicyRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchCloudWatchLogsLogGroup":
        case "com.amazonaws.route53#NoSuchCloudWatchLogsLogGroup":
            throw await de_NoSuchCloudWatchLogsLogGroupRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        case "QueryLoggingConfigAlreadyExists":
        case "com.amazonaws.route53#QueryLoggingConfigAlreadyExists":
            throw await de_QueryLoggingConfigAlreadyExistsRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateReusableDelegationSetCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateReusableDelegationSetCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["DelegationSet"] !== undefined) {
        contents.DelegationSet = de_DelegationSet(data["DelegationSet"], context);
    }
    return contents;
};
const de_CreateReusableDelegationSetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DelegationSetAlreadyCreated":
        case "com.amazonaws.route53#DelegationSetAlreadyCreated":
            throw await de_DelegationSetAlreadyCreatedRes(parsedOutput, context);
        case "DelegationSetAlreadyReusable":
        case "com.amazonaws.route53#DelegationSetAlreadyReusable":
            throw await de_DelegationSetAlreadyReusableRes(parsedOutput, context);
        case "DelegationSetNotAvailable":
        case "com.amazonaws.route53#DelegationSetNotAvailable":
            throw await de_DelegationSetNotAvailableRes(parsedOutput, context);
        case "HostedZoneNotFound":
        case "com.amazonaws.route53#HostedZoneNotFound":
            throw await de_HostedZoneNotFoundRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.route53#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "LimitsExceeded":
        case "com.amazonaws.route53#LimitsExceeded":
            throw await de_LimitsExceededRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateTrafficPolicyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateTrafficPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["TrafficPolicy"] !== undefined) {
        contents.TrafficPolicy = de_TrafficPolicy(data["TrafficPolicy"], context);
    }
    return contents;
};
const de_CreateTrafficPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "InvalidTrafficPolicyDocument":
        case "com.amazonaws.route53#InvalidTrafficPolicyDocument":
            throw await de_InvalidTrafficPolicyDocumentRes(parsedOutput, context);
        case "TooManyTrafficPolicies":
        case "com.amazonaws.route53#TooManyTrafficPolicies":
            throw await de_TooManyTrafficPoliciesRes(parsedOutput, context);
        case "TrafficPolicyAlreadyExists":
        case "com.amazonaws.route53#TrafficPolicyAlreadyExists":
            throw await de_TrafficPolicyAlreadyExistsRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateTrafficPolicyInstanceCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateTrafficPolicyInstanceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["TrafficPolicyInstance"] !== undefined) {
        contents.TrafficPolicyInstance = de_TrafficPolicyInstance(data["TrafficPolicyInstance"], context);
    }
    return contents;
};
const de_CreateTrafficPolicyInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        case "NoSuchTrafficPolicy":
        case "com.amazonaws.route53#NoSuchTrafficPolicy":
            throw await de_NoSuchTrafficPolicyRes(parsedOutput, context);
        case "TooManyTrafficPolicyInstances":
        case "com.amazonaws.route53#TooManyTrafficPolicyInstances":
            throw await de_TooManyTrafficPolicyInstancesRes(parsedOutput, context);
        case "TrafficPolicyInstanceAlreadyExists":
        case "com.amazonaws.route53#TrafficPolicyInstanceAlreadyExists":
            throw await de_TrafficPolicyInstanceAlreadyExistsRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateTrafficPolicyVersionCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateTrafficPolicyVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["TrafficPolicy"] !== undefined) {
        contents.TrafficPolicy = de_TrafficPolicy(data["TrafficPolicy"], context);
    }
    return contents;
};
const de_CreateTrafficPolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.route53#ConcurrentModification":
            throw await de_ConcurrentModificationRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "InvalidTrafficPolicyDocument":
        case "com.amazonaws.route53#InvalidTrafficPolicyDocument":
            throw await de_InvalidTrafficPolicyDocumentRes(parsedOutput, context);
        case "NoSuchTrafficPolicy":
        case "com.amazonaws.route53#NoSuchTrafficPolicy":
            throw await de_NoSuchTrafficPolicyRes(parsedOutput, context);
        case "TooManyTrafficPolicyVersionsForCurrentPolicy":
        case "com.amazonaws.route53#TooManyTrafficPolicyVersionsForCurrentPolicy":
            throw await de_TooManyTrafficPolicyVersionsForCurrentPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateVPCAssociationAuthorizationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateVPCAssociationAuthorizationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["HostedZoneId"] !== undefined) {
        contents.HostedZoneId = __expectString(data["HostedZoneId"]);
    }
    if (data["VPC"] !== undefined) {
        contents.VPC = de_VPC(data["VPC"], context);
    }
    return contents;
};
const de_CreateVPCAssociationAuthorizationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.route53#ConcurrentModification":
            throw await de_ConcurrentModificationRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "InvalidVPCId":
        case "com.amazonaws.route53#InvalidVPCId":
            throw await de_InvalidVPCIdRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        case "TooManyVPCAssociationAuthorizations":
        case "com.amazonaws.route53#TooManyVPCAssociationAuthorizations":
            throw await de_TooManyVPCAssociationAuthorizationsRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeactivateKeySigningKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeactivateKeySigningKeyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["ChangeInfo"] !== undefined) {
        contents.ChangeInfo = de_ChangeInfo(data["ChangeInfo"], context);
    }
    return contents;
};
const de_DeactivateKeySigningKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.route53#ConcurrentModification":
            throw await de_ConcurrentModificationRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "InvalidKeySigningKeyStatus":
        case "com.amazonaws.route53#InvalidKeySigningKeyStatus":
            throw await de_InvalidKeySigningKeyStatusRes(parsedOutput, context);
        case "InvalidSigningStatus":
        case "com.amazonaws.route53#InvalidSigningStatus":
            throw await de_InvalidSigningStatusRes(parsedOutput, context);
        case "KeySigningKeyInParentDSRecord":
        case "com.amazonaws.route53#KeySigningKeyInParentDSRecord":
            throw await de_KeySigningKeyInParentDSRecordRes(parsedOutput, context);
        case "KeySigningKeyInUse":
        case "com.amazonaws.route53#KeySigningKeyInUse":
            throw await de_KeySigningKeyInUseRes(parsedOutput, context);
        case "NoSuchKeySigningKey":
        case "com.amazonaws.route53#NoSuchKeySigningKey":
            throw await de_NoSuchKeySigningKeyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteCidrCollectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteCidrCollectionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteCidrCollectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CidrCollectionInUseException":
        case "com.amazonaws.route53#CidrCollectionInUseException":
            throw await de_CidrCollectionInUseExceptionRes(parsedOutput, context);
        case "ConcurrentModification":
        case "com.amazonaws.route53#ConcurrentModification":
            throw await de_ConcurrentModificationRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchCidrCollectionException":
        case "com.amazonaws.route53#NoSuchCidrCollectionException":
            throw await de_NoSuchCidrCollectionExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteHealthCheckCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteHealthCheckCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteHealthCheckCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "HealthCheckInUse":
        case "com.amazonaws.route53#HealthCheckInUse":
            throw await de_HealthCheckInUseRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHealthCheck":
        case "com.amazonaws.route53#NoSuchHealthCheck":
            throw await de_NoSuchHealthCheckRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteHostedZoneCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteHostedZoneCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["ChangeInfo"] !== undefined) {
        contents.ChangeInfo = de_ChangeInfo(data["ChangeInfo"], context);
    }
    return contents;
};
const de_DeleteHostedZoneCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "HostedZoneNotEmpty":
        case "com.amazonaws.route53#HostedZoneNotEmpty":
            throw await de_HostedZoneNotEmptyRes(parsedOutput, context);
        case "InvalidDomainName":
        case "com.amazonaws.route53#InvalidDomainName":
            throw await de_InvalidDomainNameRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        case "PriorRequestNotComplete":
        case "com.amazonaws.route53#PriorRequestNotComplete":
            throw await de_PriorRequestNotCompleteRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteKeySigningKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteKeySigningKeyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["ChangeInfo"] !== undefined) {
        contents.ChangeInfo = de_ChangeInfo(data["ChangeInfo"], context);
    }
    return contents;
};
const de_DeleteKeySigningKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.route53#ConcurrentModification":
            throw await de_ConcurrentModificationRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "InvalidKMSArn":
        case "com.amazonaws.route53#InvalidKMSArn":
            throw await de_InvalidKMSArnRes(parsedOutput, context);
        case "InvalidKeySigningKeyStatus":
        case "com.amazonaws.route53#InvalidKeySigningKeyStatus":
            throw await de_InvalidKeySigningKeyStatusRes(parsedOutput, context);
        case "InvalidSigningStatus":
        case "com.amazonaws.route53#InvalidSigningStatus":
            throw await de_InvalidSigningStatusRes(parsedOutput, context);
        case "NoSuchKeySigningKey":
        case "com.amazonaws.route53#NoSuchKeySigningKey":
            throw await de_NoSuchKeySigningKeyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteQueryLoggingConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteQueryLoggingConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteQueryLoggingConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.route53#ConcurrentModification":
            throw await de_ConcurrentModificationRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchQueryLoggingConfig":
        case "com.amazonaws.route53#NoSuchQueryLoggingConfig":
            throw await de_NoSuchQueryLoggingConfigRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteReusableDelegationSetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteReusableDelegationSetCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteReusableDelegationSetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DelegationSetInUse":
        case "com.amazonaws.route53#DelegationSetInUse":
            throw await de_DelegationSetInUseRes(parsedOutput, context);
        case "DelegationSetNotReusable":
        case "com.amazonaws.route53#DelegationSetNotReusable":
            throw await de_DelegationSetNotReusableRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchDelegationSet":
        case "com.amazonaws.route53#NoSuchDelegationSet":
            throw await de_NoSuchDelegationSetRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteTrafficPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteTrafficPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteTrafficPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.route53#ConcurrentModification":
            throw await de_ConcurrentModificationRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchTrafficPolicy":
        case "com.amazonaws.route53#NoSuchTrafficPolicy":
            throw await de_NoSuchTrafficPolicyRes(parsedOutput, context);
        case "TrafficPolicyInUse":
        case "com.amazonaws.route53#TrafficPolicyInUse":
            throw await de_TrafficPolicyInUseRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteTrafficPolicyInstanceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteTrafficPolicyInstanceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteTrafficPolicyInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchTrafficPolicyInstance":
        case "com.amazonaws.route53#NoSuchTrafficPolicyInstance":
            throw await de_NoSuchTrafficPolicyInstanceRes(parsedOutput, context);
        case "PriorRequestNotComplete":
        case "com.amazonaws.route53#PriorRequestNotComplete":
            throw await de_PriorRequestNotCompleteRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteVPCAssociationAuthorizationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteVPCAssociationAuthorizationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteVPCAssociationAuthorizationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.route53#ConcurrentModification":
            throw await de_ConcurrentModificationRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "InvalidVPCId":
        case "com.amazonaws.route53#InvalidVPCId":
            throw await de_InvalidVPCIdRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        case "VPCAssociationAuthorizationNotFound":
        case "com.amazonaws.route53#VPCAssociationAuthorizationNotFound":
            throw await de_VPCAssociationAuthorizationNotFoundRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DisableHostedZoneDNSSECCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DisableHostedZoneDNSSECCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["ChangeInfo"] !== undefined) {
        contents.ChangeInfo = de_ChangeInfo(data["ChangeInfo"], context);
    }
    return contents;
};
const de_DisableHostedZoneDNSSECCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.route53#ConcurrentModification":
            throw await de_ConcurrentModificationRes(parsedOutput, context);
        case "DNSSECNotFound":
        case "com.amazonaws.route53#DNSSECNotFound":
            throw await de_DNSSECNotFoundRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.route53#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "InvalidKMSArn":
        case "com.amazonaws.route53#InvalidKMSArn":
            throw await de_InvalidKMSArnRes(parsedOutput, context);
        case "InvalidKeySigningKeyStatus":
        case "com.amazonaws.route53#InvalidKeySigningKeyStatus":
            throw await de_InvalidKeySigningKeyStatusRes(parsedOutput, context);
        case "KeySigningKeyInParentDSRecord":
        case "com.amazonaws.route53#KeySigningKeyInParentDSRecord":
            throw await de_KeySigningKeyInParentDSRecordRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DisassociateVPCFromHostedZoneCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DisassociateVPCFromHostedZoneCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["ChangeInfo"] !== undefined) {
        contents.ChangeInfo = de_ChangeInfo(data["ChangeInfo"], context);
    }
    return contents;
};
const de_DisassociateVPCFromHostedZoneCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "InvalidVPCId":
        case "com.amazonaws.route53#InvalidVPCId":
            throw await de_InvalidVPCIdRes(parsedOutput, context);
        case "LastVPCAssociation":
        case "com.amazonaws.route53#LastVPCAssociation":
            throw await de_LastVPCAssociationRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        case "VPCAssociationNotFound":
        case "com.amazonaws.route53#VPCAssociationNotFound":
            throw await de_VPCAssociationNotFoundRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_EnableHostedZoneDNSSECCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_EnableHostedZoneDNSSECCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["ChangeInfo"] !== undefined) {
        contents.ChangeInfo = de_ChangeInfo(data["ChangeInfo"], context);
    }
    return contents;
};
const de_EnableHostedZoneDNSSECCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.route53#ConcurrentModification":
            throw await de_ConcurrentModificationRes(parsedOutput, context);
        case "DNSSECNotFound":
        case "com.amazonaws.route53#DNSSECNotFound":
            throw await de_DNSSECNotFoundRes(parsedOutput, context);
        case "HostedZonePartiallyDelegated":
        case "com.amazonaws.route53#HostedZonePartiallyDelegated":
            throw await de_HostedZonePartiallyDelegatedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.route53#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "InvalidKMSArn":
        case "com.amazonaws.route53#InvalidKMSArn":
            throw await de_InvalidKMSArnRes(parsedOutput, context);
        case "InvalidKeySigningKeyStatus":
        case "com.amazonaws.route53#InvalidKeySigningKeyStatus":
            throw await de_InvalidKeySigningKeyStatusRes(parsedOutput, context);
        case "KeySigningKeyWithActiveStatusNotFound":
        case "com.amazonaws.route53#KeySigningKeyWithActiveStatusNotFound":
            throw await de_KeySigningKeyWithActiveStatusNotFoundRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetAccountLimitCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAccountLimitCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Count"] !== undefined) {
        contents.Count = __strictParseLong(data["Count"]);
    }
    if (data["Limit"] !== undefined) {
        contents.Limit = de_AccountLimit(data["Limit"], context);
    }
    return contents;
};
const de_GetAccountLimitCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetChangeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetChangeCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["ChangeInfo"] !== undefined) {
        contents.ChangeInfo = de_ChangeInfo(data["ChangeInfo"], context);
    }
    return contents;
};
const de_GetChangeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchChange":
        case "com.amazonaws.route53#NoSuchChange":
            throw await de_NoSuchChangeRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetCheckerIpRangesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetCheckerIpRangesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.CheckerIpRanges === "") {
        contents.CheckerIpRanges = [];
    }
    else if (data["CheckerIpRanges"] !== undefined && data["CheckerIpRanges"]["member"] !== undefined) {
        contents.CheckerIpRanges = de_CheckerIpRanges(__getArrayIfSingleItem(data["CheckerIpRanges"]["member"]), context);
    }
    return contents;
};
const de_GetCheckerIpRangesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetDNSSECCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDNSSECCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.KeySigningKeys === "") {
        contents.KeySigningKeys = [];
    }
    else if (data["KeySigningKeys"] !== undefined && data["KeySigningKeys"]["member"] !== undefined) {
        contents.KeySigningKeys = de_KeySigningKeys(__getArrayIfSingleItem(data["KeySigningKeys"]["member"]), context);
    }
    if (data["Status"] !== undefined) {
        contents.Status = de_DNSSECStatus(data["Status"], context);
    }
    return contents;
};
const de_GetDNSSECCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.route53#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetGeoLocationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetGeoLocationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["GeoLocationDetails"] !== undefined) {
        contents.GeoLocationDetails = de_GeoLocationDetails(data["GeoLocationDetails"], context);
    }
    return contents;
};
const de_GetGeoLocationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchGeoLocation":
        case "com.amazonaws.route53#NoSuchGeoLocation":
            throw await de_NoSuchGeoLocationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetHealthCheckCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetHealthCheckCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["HealthCheck"] !== undefined) {
        contents.HealthCheck = de_HealthCheck(data["HealthCheck"], context);
    }
    return contents;
};
const de_GetHealthCheckCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IncompatibleVersion":
        case "com.amazonaws.route53#IncompatibleVersion":
            throw await de_IncompatibleVersionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHealthCheck":
        case "com.amazonaws.route53#NoSuchHealthCheck":
            throw await de_NoSuchHealthCheckRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetHealthCheckCountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetHealthCheckCountCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["HealthCheckCount"] !== undefined) {
        contents.HealthCheckCount = __strictParseLong(data["HealthCheckCount"]);
    }
    return contents;
};
const de_GetHealthCheckCountCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetHealthCheckLastFailureReasonCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetHealthCheckLastFailureReasonCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.HealthCheckObservations === "") {
        contents.HealthCheckObservations = [];
    }
    else if (data["HealthCheckObservations"] !== undefined &&
        data["HealthCheckObservations"]["HealthCheckObservation"] !== undefined) {
        contents.HealthCheckObservations = de_HealthCheckObservations(__getArrayIfSingleItem(data["HealthCheckObservations"]["HealthCheckObservation"]), context);
    }
    return contents;
};
const de_GetHealthCheckLastFailureReasonCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHealthCheck":
        case "com.amazonaws.route53#NoSuchHealthCheck":
            throw await de_NoSuchHealthCheckRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetHealthCheckStatusCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetHealthCheckStatusCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.HealthCheckObservations === "") {
        contents.HealthCheckObservations = [];
    }
    else if (data["HealthCheckObservations"] !== undefined &&
        data["HealthCheckObservations"]["HealthCheckObservation"] !== undefined) {
        contents.HealthCheckObservations = de_HealthCheckObservations(__getArrayIfSingleItem(data["HealthCheckObservations"]["HealthCheckObservation"]), context);
    }
    return contents;
};
const de_GetHealthCheckStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHealthCheck":
        case "com.amazonaws.route53#NoSuchHealthCheck":
            throw await de_NoSuchHealthCheckRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetHostedZoneCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetHostedZoneCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["DelegationSet"] !== undefined) {
        contents.DelegationSet = de_DelegationSet(data["DelegationSet"], context);
    }
    if (data["HostedZone"] !== undefined) {
        contents.HostedZone = de_HostedZone(data["HostedZone"], context);
    }
    if (data.VPCs === "") {
        contents.VPCs = [];
    }
    else if (data["VPCs"] !== undefined && data["VPCs"]["VPC"] !== undefined) {
        contents.VPCs = de_VPCs(__getArrayIfSingleItem(data["VPCs"]["VPC"]), context);
    }
    return contents;
};
const de_GetHostedZoneCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetHostedZoneCountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetHostedZoneCountCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["HostedZoneCount"] !== undefined) {
        contents.HostedZoneCount = __strictParseLong(data["HostedZoneCount"]);
    }
    return contents;
};
const de_GetHostedZoneCountCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetHostedZoneLimitCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetHostedZoneLimitCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Count"] !== undefined) {
        contents.Count = __strictParseLong(data["Count"]);
    }
    if (data["Limit"] !== undefined) {
        contents.Limit = de_HostedZoneLimit(data["Limit"], context);
    }
    return contents;
};
const de_GetHostedZoneLimitCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "HostedZoneNotPrivate":
        case "com.amazonaws.route53#HostedZoneNotPrivate":
            throw await de_HostedZoneNotPrivateRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetQueryLoggingConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetQueryLoggingConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["QueryLoggingConfig"] !== undefined) {
        contents.QueryLoggingConfig = de_QueryLoggingConfig(data["QueryLoggingConfig"], context);
    }
    return contents;
};
const de_GetQueryLoggingConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchQueryLoggingConfig":
        case "com.amazonaws.route53#NoSuchQueryLoggingConfig":
            throw await de_NoSuchQueryLoggingConfigRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetReusableDelegationSetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetReusableDelegationSetCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["DelegationSet"] !== undefined) {
        contents.DelegationSet = de_DelegationSet(data["DelegationSet"], context);
    }
    return contents;
};
const de_GetReusableDelegationSetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DelegationSetNotReusable":
        case "com.amazonaws.route53#DelegationSetNotReusable":
            throw await de_DelegationSetNotReusableRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchDelegationSet":
        case "com.amazonaws.route53#NoSuchDelegationSet":
            throw await de_NoSuchDelegationSetRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetReusableDelegationSetLimitCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetReusableDelegationSetLimitCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Count"] !== undefined) {
        contents.Count = __strictParseLong(data["Count"]);
    }
    if (data["Limit"] !== undefined) {
        contents.Limit = de_ReusableDelegationSetLimit(data["Limit"], context);
    }
    return contents;
};
const de_GetReusableDelegationSetLimitCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchDelegationSet":
        case "com.amazonaws.route53#NoSuchDelegationSet":
            throw await de_NoSuchDelegationSetRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetTrafficPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetTrafficPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["TrafficPolicy"] !== undefined) {
        contents.TrafficPolicy = de_TrafficPolicy(data["TrafficPolicy"], context);
    }
    return contents;
};
const de_GetTrafficPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchTrafficPolicy":
        case "com.amazonaws.route53#NoSuchTrafficPolicy":
            throw await de_NoSuchTrafficPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetTrafficPolicyInstanceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetTrafficPolicyInstanceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["TrafficPolicyInstance"] !== undefined) {
        contents.TrafficPolicyInstance = de_TrafficPolicyInstance(data["TrafficPolicyInstance"], context);
    }
    return contents;
};
const de_GetTrafficPolicyInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchTrafficPolicyInstance":
        case "com.amazonaws.route53#NoSuchTrafficPolicyInstance":
            throw await de_NoSuchTrafficPolicyInstanceRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetTrafficPolicyInstanceCountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetTrafficPolicyInstanceCountCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["TrafficPolicyInstanceCount"] !== undefined) {
        contents.TrafficPolicyInstanceCount = __strictParseInt32(data["TrafficPolicyInstanceCount"]);
    }
    return contents;
};
const de_GetTrafficPolicyInstanceCountCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_ListCidrBlocksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListCidrBlocksCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.CidrBlocks === "") {
        contents.CidrBlocks = [];
    }
    else if (data["CidrBlocks"] !== undefined && data["CidrBlocks"]["member"] !== undefined) {
        contents.CidrBlocks = de_CidrBlockSummaries(__getArrayIfSingleItem(data["CidrBlocks"]["member"]), context);
    }
    if (data["NextToken"] !== undefined) {
        contents.NextToken = __expectString(data["NextToken"]);
    }
    return contents;
};
const de_ListCidrBlocksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchCidrCollectionException":
        case "com.amazonaws.route53#NoSuchCidrCollectionException":
            throw await de_NoSuchCidrCollectionExceptionRes(parsedOutput, context);
        case "NoSuchCidrLocationException":
        case "com.amazonaws.route53#NoSuchCidrLocationException":
            throw await de_NoSuchCidrLocationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListCidrCollectionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListCidrCollectionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.CidrCollections === "") {
        contents.CidrCollections = [];
    }
    else if (data["CidrCollections"] !== undefined && data["CidrCollections"]["member"] !== undefined) {
        contents.CidrCollections = de_CollectionSummaries(__getArrayIfSingleItem(data["CidrCollections"]["member"]), context);
    }
    if (data["NextToken"] !== undefined) {
        contents.NextToken = __expectString(data["NextToken"]);
    }
    return contents;
};
const de_ListCidrCollectionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListCidrLocationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListCidrLocationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.CidrLocations === "") {
        contents.CidrLocations = [];
    }
    else if (data["CidrLocations"] !== undefined && data["CidrLocations"]["member"] !== undefined) {
        contents.CidrLocations = de_LocationSummaries(__getArrayIfSingleItem(data["CidrLocations"]["member"]), context);
    }
    if (data["NextToken"] !== undefined) {
        contents.NextToken = __expectString(data["NextToken"]);
    }
    return contents;
};
const de_ListCidrLocationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchCidrCollectionException":
        case "com.amazonaws.route53#NoSuchCidrCollectionException":
            throw await de_NoSuchCidrCollectionExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListGeoLocationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListGeoLocationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.GeoLocationDetailsList === "") {
        contents.GeoLocationDetailsList = [];
    }
    else if (data["GeoLocationDetailsList"] !== undefined &&
        data["GeoLocationDetailsList"]["GeoLocationDetails"] !== undefined) {
        contents.GeoLocationDetailsList = de_GeoLocationDetailsList(__getArrayIfSingleItem(data["GeoLocationDetailsList"]["GeoLocationDetails"]), context);
    }
    if (data["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(data["IsTruncated"]);
    }
    if (data["MaxItems"] !== undefined) {
        contents.MaxItems = __strictParseInt32(data["MaxItems"]);
    }
    if (data["NextContinentCode"] !== undefined) {
        contents.NextContinentCode = __expectString(data["NextContinentCode"]);
    }
    if (data["NextCountryCode"] !== undefined) {
        contents.NextCountryCode = __expectString(data["NextCountryCode"]);
    }
    if (data["NextSubdivisionCode"] !== undefined) {
        contents.NextSubdivisionCode = __expectString(data["NextSubdivisionCode"]);
    }
    return contents;
};
const de_ListGeoLocationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListHealthChecksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListHealthChecksCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.HealthChecks === "") {
        contents.HealthChecks = [];
    }
    else if (data["HealthChecks"] !== undefined && data["HealthChecks"]["HealthCheck"] !== undefined) {
        contents.HealthChecks = de_HealthChecks(__getArrayIfSingleItem(data["HealthChecks"]["HealthCheck"]), context);
    }
    if (data["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(data["IsTruncated"]);
    }
    if (data["Marker"] !== undefined) {
        contents.Marker = __expectString(data["Marker"]);
    }
    if (data["MaxItems"] !== undefined) {
        contents.MaxItems = __strictParseInt32(data["MaxItems"]);
    }
    if (data["NextMarker"] !== undefined) {
        contents.NextMarker = __expectString(data["NextMarker"]);
    }
    return contents;
};
const de_ListHealthChecksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IncompatibleVersion":
        case "com.amazonaws.route53#IncompatibleVersion":
            throw await de_IncompatibleVersionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListHostedZonesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListHostedZonesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.HostedZones === "") {
        contents.HostedZones = [];
    }
    else if (data["HostedZones"] !== undefined && data["HostedZones"]["HostedZone"] !== undefined) {
        contents.HostedZones = de_HostedZones(__getArrayIfSingleItem(data["HostedZones"]["HostedZone"]), context);
    }
    if (data["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(data["IsTruncated"]);
    }
    if (data["Marker"] !== undefined) {
        contents.Marker = __expectString(data["Marker"]);
    }
    if (data["MaxItems"] !== undefined) {
        contents.MaxItems = __strictParseInt32(data["MaxItems"]);
    }
    if (data["NextMarker"] !== undefined) {
        contents.NextMarker = __expectString(data["NextMarker"]);
    }
    return contents;
};
const de_ListHostedZonesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DelegationSetNotReusable":
        case "com.amazonaws.route53#DelegationSetNotReusable":
            throw await de_DelegationSetNotReusableRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchDelegationSet":
        case "com.amazonaws.route53#NoSuchDelegationSet":
            throw await de_NoSuchDelegationSetRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListHostedZonesByNameCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListHostedZonesByNameCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["DNSName"] !== undefined) {
        contents.DNSName = __expectString(data["DNSName"]);
    }
    if (data["HostedZoneId"] !== undefined) {
        contents.HostedZoneId = __expectString(data["HostedZoneId"]);
    }
    if (data.HostedZones === "") {
        contents.HostedZones = [];
    }
    else if (data["HostedZones"] !== undefined && data["HostedZones"]["HostedZone"] !== undefined) {
        contents.HostedZones = de_HostedZones(__getArrayIfSingleItem(data["HostedZones"]["HostedZone"]), context);
    }
    if (data["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(data["IsTruncated"]);
    }
    if (data["MaxItems"] !== undefined) {
        contents.MaxItems = __strictParseInt32(data["MaxItems"]);
    }
    if (data["NextDNSName"] !== undefined) {
        contents.NextDNSName = __expectString(data["NextDNSName"]);
    }
    if (data["NextHostedZoneId"] !== undefined) {
        contents.NextHostedZoneId = __expectString(data["NextHostedZoneId"]);
    }
    return contents;
};
const de_ListHostedZonesByNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidDomainName":
        case "com.amazonaws.route53#InvalidDomainName":
            throw await de_InvalidDomainNameRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListHostedZonesByVPCCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListHostedZonesByVPCCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.HostedZoneSummaries === "") {
        contents.HostedZoneSummaries = [];
    }
    else if (data["HostedZoneSummaries"] !== undefined &&
        data["HostedZoneSummaries"]["HostedZoneSummary"] !== undefined) {
        contents.HostedZoneSummaries = de_HostedZoneSummaries(__getArrayIfSingleItem(data["HostedZoneSummaries"]["HostedZoneSummary"]), context);
    }
    if (data["MaxItems"] !== undefined) {
        contents.MaxItems = __strictParseInt32(data["MaxItems"]);
    }
    if (data["NextToken"] !== undefined) {
        contents.NextToken = __expectString(data["NextToken"]);
    }
    return contents;
};
const de_ListHostedZonesByVPCCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "InvalidPaginationToken":
        case "com.amazonaws.route53#InvalidPaginationToken":
            throw await de_InvalidPaginationTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListQueryLoggingConfigsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListQueryLoggingConfigsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["NextToken"] !== undefined) {
        contents.NextToken = __expectString(data["NextToken"]);
    }
    if (data.QueryLoggingConfigs === "") {
        contents.QueryLoggingConfigs = [];
    }
    else if (data["QueryLoggingConfigs"] !== undefined &&
        data["QueryLoggingConfigs"]["QueryLoggingConfig"] !== undefined) {
        contents.QueryLoggingConfigs = de_QueryLoggingConfigs(__getArrayIfSingleItem(data["QueryLoggingConfigs"]["QueryLoggingConfig"]), context);
    }
    return contents;
};
const de_ListQueryLoggingConfigsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "InvalidPaginationToken":
        case "com.amazonaws.route53#InvalidPaginationToken":
            throw await de_InvalidPaginationTokenRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListResourceRecordSetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListResourceRecordSetsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(data["IsTruncated"]);
    }
    if (data["MaxItems"] !== undefined) {
        contents.MaxItems = __strictParseInt32(data["MaxItems"]);
    }
    if (data["NextRecordIdentifier"] !== undefined) {
        contents.NextRecordIdentifier = __expectString(data["NextRecordIdentifier"]);
    }
    if (data["NextRecordName"] !== undefined) {
        contents.NextRecordName = __expectString(data["NextRecordName"]);
    }
    if (data["NextRecordType"] !== undefined) {
        contents.NextRecordType = __expectString(data["NextRecordType"]);
    }
    if (data.ResourceRecordSets === "") {
        contents.ResourceRecordSets = [];
    }
    else if (data["ResourceRecordSets"] !== undefined &&
        data["ResourceRecordSets"]["ResourceRecordSet"] !== undefined) {
        contents.ResourceRecordSets = de_ResourceRecordSets(__getArrayIfSingleItem(data["ResourceRecordSets"]["ResourceRecordSet"]), context);
    }
    return contents;
};
const de_ListResourceRecordSetsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListReusableDelegationSetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListReusableDelegationSetsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.DelegationSets === "") {
        contents.DelegationSets = [];
    }
    else if (data["DelegationSets"] !== undefined && data["DelegationSets"]["DelegationSet"] !== undefined) {
        contents.DelegationSets = de_DelegationSets(__getArrayIfSingleItem(data["DelegationSets"]["DelegationSet"]), context);
    }
    if (data["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(data["IsTruncated"]);
    }
    if (data["Marker"] !== undefined) {
        contents.Marker = __expectString(data["Marker"]);
    }
    if (data["MaxItems"] !== undefined) {
        contents.MaxItems = __strictParseInt32(data["MaxItems"]);
    }
    if (data["NextMarker"] !== undefined) {
        contents.NextMarker = __expectString(data["NextMarker"]);
    }
    return contents;
};
const de_ListReusableDelegationSetsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTagsForResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["ResourceTagSet"] !== undefined) {
        contents.ResourceTagSet = de_ResourceTagSet(data["ResourceTagSet"], context);
    }
    return contents;
};
const de_ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHealthCheck":
        case "com.amazonaws.route53#NoSuchHealthCheck":
            throw await de_NoSuchHealthCheckRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        case "PriorRequestNotComplete":
        case "com.amazonaws.route53#PriorRequestNotComplete":
            throw await de_PriorRequestNotCompleteRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.route53#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListTagsForResourcesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTagsForResourcesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.ResourceTagSets === "") {
        contents.ResourceTagSets = [];
    }
    else if (data["ResourceTagSets"] !== undefined && data["ResourceTagSets"]["ResourceTagSet"] !== undefined) {
        contents.ResourceTagSets = de_ResourceTagSetList(__getArrayIfSingleItem(data["ResourceTagSets"]["ResourceTagSet"]), context);
    }
    return contents;
};
const de_ListTagsForResourcesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHealthCheck":
        case "com.amazonaws.route53#NoSuchHealthCheck":
            throw await de_NoSuchHealthCheckRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        case "PriorRequestNotComplete":
        case "com.amazonaws.route53#PriorRequestNotComplete":
            throw await de_PriorRequestNotCompleteRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.route53#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListTrafficPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTrafficPoliciesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(data["IsTruncated"]);
    }
    if (data["MaxItems"] !== undefined) {
        contents.MaxItems = __strictParseInt32(data["MaxItems"]);
    }
    if (data["TrafficPolicyIdMarker"] !== undefined) {
        contents.TrafficPolicyIdMarker = __expectString(data["TrafficPolicyIdMarker"]);
    }
    if (data.TrafficPolicySummaries === "") {
        contents.TrafficPolicySummaries = [];
    }
    else if (data["TrafficPolicySummaries"] !== undefined &&
        data["TrafficPolicySummaries"]["TrafficPolicySummary"] !== undefined) {
        contents.TrafficPolicySummaries = de_TrafficPolicySummaries(__getArrayIfSingleItem(data["TrafficPolicySummaries"]["TrafficPolicySummary"]), context);
    }
    return contents;
};
const de_ListTrafficPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListTrafficPolicyInstancesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTrafficPolicyInstancesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["HostedZoneIdMarker"] !== undefined) {
        contents.HostedZoneIdMarker = __expectString(data["HostedZoneIdMarker"]);
    }
    if (data["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(data["IsTruncated"]);
    }
    if (data["MaxItems"] !== undefined) {
        contents.MaxItems = __strictParseInt32(data["MaxItems"]);
    }
    if (data["TrafficPolicyInstanceNameMarker"] !== undefined) {
        contents.TrafficPolicyInstanceNameMarker = __expectString(data["TrafficPolicyInstanceNameMarker"]);
    }
    if (data["TrafficPolicyInstanceTypeMarker"] !== undefined) {
        contents.TrafficPolicyInstanceTypeMarker = __expectString(data["TrafficPolicyInstanceTypeMarker"]);
    }
    if (data.TrafficPolicyInstances === "") {
        contents.TrafficPolicyInstances = [];
    }
    else if (data["TrafficPolicyInstances"] !== undefined &&
        data["TrafficPolicyInstances"]["TrafficPolicyInstance"] !== undefined) {
        contents.TrafficPolicyInstances = de_TrafficPolicyInstances(__getArrayIfSingleItem(data["TrafficPolicyInstances"]["TrafficPolicyInstance"]), context);
    }
    return contents;
};
const de_ListTrafficPolicyInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchTrafficPolicyInstance":
        case "com.amazonaws.route53#NoSuchTrafficPolicyInstance":
            throw await de_NoSuchTrafficPolicyInstanceRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListTrafficPolicyInstancesByHostedZoneCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTrafficPolicyInstancesByHostedZoneCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(data["IsTruncated"]);
    }
    if (data["MaxItems"] !== undefined) {
        contents.MaxItems = __strictParseInt32(data["MaxItems"]);
    }
    if (data["TrafficPolicyInstanceNameMarker"] !== undefined) {
        contents.TrafficPolicyInstanceNameMarker = __expectString(data["TrafficPolicyInstanceNameMarker"]);
    }
    if (data["TrafficPolicyInstanceTypeMarker"] !== undefined) {
        contents.TrafficPolicyInstanceTypeMarker = __expectString(data["TrafficPolicyInstanceTypeMarker"]);
    }
    if (data.TrafficPolicyInstances === "") {
        contents.TrafficPolicyInstances = [];
    }
    else if (data["TrafficPolicyInstances"] !== undefined &&
        data["TrafficPolicyInstances"]["TrafficPolicyInstance"] !== undefined) {
        contents.TrafficPolicyInstances = de_TrafficPolicyInstances(__getArrayIfSingleItem(data["TrafficPolicyInstances"]["TrafficPolicyInstance"]), context);
    }
    return contents;
};
const de_ListTrafficPolicyInstancesByHostedZoneCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        case "NoSuchTrafficPolicyInstance":
        case "com.amazonaws.route53#NoSuchTrafficPolicyInstance":
            throw await de_NoSuchTrafficPolicyInstanceRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListTrafficPolicyInstancesByPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTrafficPolicyInstancesByPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["HostedZoneIdMarker"] !== undefined) {
        contents.HostedZoneIdMarker = __expectString(data["HostedZoneIdMarker"]);
    }
    if (data["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(data["IsTruncated"]);
    }
    if (data["MaxItems"] !== undefined) {
        contents.MaxItems = __strictParseInt32(data["MaxItems"]);
    }
    if (data["TrafficPolicyInstanceNameMarker"] !== undefined) {
        contents.TrafficPolicyInstanceNameMarker = __expectString(data["TrafficPolicyInstanceNameMarker"]);
    }
    if (data["TrafficPolicyInstanceTypeMarker"] !== undefined) {
        contents.TrafficPolicyInstanceTypeMarker = __expectString(data["TrafficPolicyInstanceTypeMarker"]);
    }
    if (data.TrafficPolicyInstances === "") {
        contents.TrafficPolicyInstances = [];
    }
    else if (data["TrafficPolicyInstances"] !== undefined &&
        data["TrafficPolicyInstances"]["TrafficPolicyInstance"] !== undefined) {
        contents.TrafficPolicyInstances = de_TrafficPolicyInstances(__getArrayIfSingleItem(data["TrafficPolicyInstances"]["TrafficPolicyInstance"]), context);
    }
    return contents;
};
const de_ListTrafficPolicyInstancesByPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchTrafficPolicy":
        case "com.amazonaws.route53#NoSuchTrafficPolicy":
            throw await de_NoSuchTrafficPolicyRes(parsedOutput, context);
        case "NoSuchTrafficPolicyInstance":
        case "com.amazonaws.route53#NoSuchTrafficPolicyInstance":
            throw await de_NoSuchTrafficPolicyInstanceRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListTrafficPolicyVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTrafficPolicyVersionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(data["IsTruncated"]);
    }
    if (data["MaxItems"] !== undefined) {
        contents.MaxItems = __strictParseInt32(data["MaxItems"]);
    }
    if (data.TrafficPolicies === "") {
        contents.TrafficPolicies = [];
    }
    else if (data["TrafficPolicies"] !== undefined && data["TrafficPolicies"]["TrafficPolicy"] !== undefined) {
        contents.TrafficPolicies = de_TrafficPolicies(__getArrayIfSingleItem(data["TrafficPolicies"]["TrafficPolicy"]), context);
    }
    if (data["TrafficPolicyVersionMarker"] !== undefined) {
        contents.TrafficPolicyVersionMarker = __expectString(data["TrafficPolicyVersionMarker"]);
    }
    return contents;
};
const de_ListTrafficPolicyVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchTrafficPolicy":
        case "com.amazonaws.route53#NoSuchTrafficPolicy":
            throw await de_NoSuchTrafficPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListVPCAssociationAuthorizationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListVPCAssociationAuthorizationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["HostedZoneId"] !== undefined) {
        contents.HostedZoneId = __expectString(data["HostedZoneId"]);
    }
    if (data["NextToken"] !== undefined) {
        contents.NextToken = __expectString(data["NextToken"]);
    }
    if (data.VPCs === "") {
        contents.VPCs = [];
    }
    else if (data["VPCs"] !== undefined && data["VPCs"]["VPC"] !== undefined) {
        contents.VPCs = de_VPCs(__getArrayIfSingleItem(data["VPCs"]["VPC"]), context);
    }
    return contents;
};
const de_ListVPCAssociationAuthorizationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "InvalidPaginationToken":
        case "com.amazonaws.route53#InvalidPaginationToken":
            throw await de_InvalidPaginationTokenRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_TestDNSAnswerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_TestDNSAnswerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Nameserver"] !== undefined) {
        contents.Nameserver = __expectString(data["Nameserver"]);
    }
    if (data["Protocol"] !== undefined) {
        contents.Protocol = __expectString(data["Protocol"]);
    }
    if (data.RecordData === "") {
        contents.RecordData = [];
    }
    else if (data["RecordData"] !== undefined && data["RecordData"]["RecordDataEntry"] !== undefined) {
        contents.RecordData = de_RecordData(__getArrayIfSingleItem(data["RecordData"]["RecordDataEntry"]), context);
    }
    if (data["RecordName"] !== undefined) {
        contents.RecordName = __expectString(data["RecordName"]);
    }
    if (data["RecordType"] !== undefined) {
        contents.RecordType = __expectString(data["RecordType"]);
    }
    if (data["ResponseCode"] !== undefined) {
        contents.ResponseCode = __expectString(data["ResponseCode"]);
    }
    return contents;
};
const de_TestDNSAnswerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateHealthCheckCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateHealthCheckCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["HealthCheck"] !== undefined) {
        contents.HealthCheck = de_HealthCheck(data["HealthCheck"], context);
    }
    return contents;
};
const de_UpdateHealthCheckCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "HealthCheckVersionMismatch":
        case "com.amazonaws.route53#HealthCheckVersionMismatch":
            throw await de_HealthCheckVersionMismatchRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHealthCheck":
        case "com.amazonaws.route53#NoSuchHealthCheck":
            throw await de_NoSuchHealthCheckRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateHostedZoneCommentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateHostedZoneCommentCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["HostedZone"] !== undefined) {
        contents.HostedZone = de_HostedZone(data["HostedZone"], context);
    }
    return contents;
};
const de_UpdateHostedZoneCommentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchHostedZone":
        case "com.amazonaws.route53#NoSuchHostedZone":
            throw await de_NoSuchHostedZoneRes(parsedOutput, context);
        case "PriorRequestNotComplete":
        case "com.amazonaws.route53#PriorRequestNotComplete":
            throw await de_PriorRequestNotCompleteRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateTrafficPolicyCommentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateTrafficPolicyCommentCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["TrafficPolicy"] !== undefined) {
        contents.TrafficPolicy = de_TrafficPolicy(data["TrafficPolicy"], context);
    }
    return contents;
};
const de_UpdateTrafficPolicyCommentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.route53#ConcurrentModification":
            throw await de_ConcurrentModificationRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchTrafficPolicy":
        case "com.amazonaws.route53#NoSuchTrafficPolicy":
            throw await de_NoSuchTrafficPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateTrafficPolicyInstanceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateTrafficPolicyInstanceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["TrafficPolicyInstance"] !== undefined) {
        contents.TrafficPolicyInstance = de_TrafficPolicyInstance(data["TrafficPolicyInstance"], context);
    }
    return contents;
};
const de_UpdateTrafficPolicyInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingTypes":
        case "com.amazonaws.route53#ConflictingTypes":
            throw await de_ConflictingTypesRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.route53#InvalidInput":
            throw await de_InvalidInputRes(parsedOutput, context);
        case "NoSuchTrafficPolicy":
        case "com.amazonaws.route53#NoSuchTrafficPolicy":
            throw await de_NoSuchTrafficPolicyRes(parsedOutput, context);
        case "NoSuchTrafficPolicyInstance":
        case "com.amazonaws.route53#NoSuchTrafficPolicyInstance":
            throw await de_NoSuchTrafficPolicyInstanceRes(parsedOutput, context);
        case "PriorRequestNotComplete":
        case "com.amazonaws.route53#PriorRequestNotComplete":
            throw await de_PriorRequestNotCompleteRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_CidrBlockInUseExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = __expectString(data["Message"]);
    }
    const exception = new CidrBlockInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_CidrCollectionAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = __expectString(data["Message"]);
    }
    const exception = new CidrCollectionAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_CidrCollectionInUseExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = __expectString(data["Message"]);
    }
    const exception = new CidrCollectionInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_CidrCollectionVersionMismatchExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = __expectString(data["Message"]);
    }
    const exception = new CidrCollectionVersionMismatchException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_ConcurrentModificationRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new ConcurrentModification({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_ConflictingDomainExistsRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new ConflictingDomainExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_ConflictingTypesRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new ConflictingTypes({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_DelegationSetAlreadyCreatedRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new DelegationSetAlreadyCreated({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_DelegationSetAlreadyReusableRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new DelegationSetAlreadyReusable({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_DelegationSetInUseRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new DelegationSetInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_DelegationSetNotAvailableRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new DelegationSetNotAvailable({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_DelegationSetNotReusableRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new DelegationSetNotReusable({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_DNSSECNotFoundRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new DNSSECNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_HealthCheckAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new HealthCheckAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_HealthCheckInUseRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new HealthCheckInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_HealthCheckVersionMismatchRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new HealthCheckVersionMismatch({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_HostedZoneAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new HostedZoneAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_HostedZoneNotEmptyRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new HostedZoneNotEmpty({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_HostedZoneNotFoundRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new HostedZoneNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_HostedZoneNotPrivateRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new HostedZoneNotPrivate({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_HostedZonePartiallyDelegatedRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new HostedZonePartiallyDelegated({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_IncompatibleVersionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new IncompatibleVersion({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_InsufficientCloudWatchLogsResourcePolicyRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new InsufficientCloudWatchLogsResourcePolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_InvalidArgumentRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new InvalidArgument({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_InvalidChangeBatchRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    if (data.messages === "") {
        contents.messages = [];
    }
    else if (data["messages"] !== undefined && data["messages"]["Message"] !== undefined) {
        contents.messages = de_ErrorMessages(__getArrayIfSingleItem(data["messages"]["Message"]), context);
    }
    const exception = new InvalidChangeBatch({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_InvalidDomainNameRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new InvalidDomainName({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_InvalidInputRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new InvalidInput({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_InvalidKeySigningKeyNameRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new InvalidKeySigningKeyName({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_InvalidKeySigningKeyStatusRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new InvalidKeySigningKeyStatus({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_InvalidKMSArnRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new InvalidKMSArn({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_InvalidPaginationTokenRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new InvalidPaginationToken({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_InvalidSigningStatusRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new InvalidSigningStatus({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_InvalidTrafficPolicyDocumentRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new InvalidTrafficPolicyDocument({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_InvalidVPCIdRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new InvalidVPCId({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_KeySigningKeyAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new KeySigningKeyAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_KeySigningKeyInParentDSRecordRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new KeySigningKeyInParentDSRecord({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_KeySigningKeyInUseRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new KeySigningKeyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_KeySigningKeyWithActiveStatusNotFoundRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new KeySigningKeyWithActiveStatusNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_LastVPCAssociationRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new LastVPCAssociation({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_LimitsExceededRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new LimitsExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_NoSuchChangeRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new NoSuchChange({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_NoSuchCidrCollectionExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = __expectString(data["Message"]);
    }
    const exception = new NoSuchCidrCollectionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_NoSuchCidrLocationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = __expectString(data["Message"]);
    }
    const exception = new NoSuchCidrLocationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_NoSuchCloudWatchLogsLogGroupRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new NoSuchCloudWatchLogsLogGroup({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_NoSuchDelegationSetRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new NoSuchDelegationSet({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_NoSuchGeoLocationRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new NoSuchGeoLocation({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_NoSuchHealthCheckRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new NoSuchHealthCheck({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_NoSuchHostedZoneRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new NoSuchHostedZone({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_NoSuchKeySigningKeyRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new NoSuchKeySigningKey({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_NoSuchQueryLoggingConfigRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new NoSuchQueryLoggingConfig({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_NoSuchTrafficPolicyRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new NoSuchTrafficPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_NoSuchTrafficPolicyInstanceRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new NoSuchTrafficPolicyInstance({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_NotAuthorizedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new NotAuthorizedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_PriorRequestNotCompleteRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new PriorRequestNotComplete({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_PublicZoneVPCAssociationRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new PublicZoneVPCAssociation({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_QueryLoggingConfigAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new QueryLoggingConfigAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_TooManyHealthChecksRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new TooManyHealthChecks({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_TooManyHostedZonesRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new TooManyHostedZones({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_TooManyKeySigningKeysRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new TooManyKeySigningKeys({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_TooManyTrafficPoliciesRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new TooManyTrafficPolicies({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_TooManyTrafficPolicyInstancesRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new TooManyTrafficPolicyInstances({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_TooManyTrafficPolicyVersionsForCurrentPolicyRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new TooManyTrafficPolicyVersionsForCurrentPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_TooManyVPCAssociationAuthorizationsRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new TooManyVPCAssociationAuthorizations({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_TrafficPolicyAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new TrafficPolicyAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_TrafficPolicyInstanceAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new TrafficPolicyInstanceAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_TrafficPolicyInUseRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new TrafficPolicyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_VPCAssociationAuthorizationNotFoundRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new VPCAssociationAuthorizationNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_VPCAssociationNotFoundRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["message"] !== undefined) {
        contents.message = __expectString(data["message"]);
    }
    const exception = new VPCAssociationNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const se_AlarmIdentifier = (input, context) => {
    const bodyNode = new __XmlNode("AlarmIdentifier");
    if (input.Region != null) {
        const node = __XmlNode.of("CloudWatchRegion", input.Region).withName("Region");
        bodyNode.addChildNode(node);
    }
    if (input.Name != null) {
        const node = __XmlNode.of("AlarmName", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_AliasTarget = (input, context) => {
    const bodyNode = new __XmlNode("AliasTarget");
    if (input.HostedZoneId != null) {
        const node = __XmlNode.of("ResourceId", input.HostedZoneId).withName("HostedZoneId");
        bodyNode.addChildNode(node);
    }
    if (input.DNSName != null) {
        const node = __XmlNode.of("DNSName", input.DNSName).withName("DNSName");
        bodyNode.addChildNode(node);
    }
    if (input.EvaluateTargetHealth != null) {
        const node = __XmlNode
            .of("AliasHealthEnabled", String(input.EvaluateTargetHealth))
            .withName("EvaluateTargetHealth");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_Change = (input, context) => {
    const bodyNode = new __XmlNode("Change");
    if (input.Action != null) {
        const node = __XmlNode.of("ChangeAction", input.Action).withName("Action");
        bodyNode.addChildNode(node);
    }
    if (input.ResourceRecordSet != null) {
        const node = se_ResourceRecordSet(input.ResourceRecordSet, context).withName("ResourceRecordSet");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_ChangeBatch = (input, context) => {
    const bodyNode = new __XmlNode("ChangeBatch");
    if (input.Comment != null) {
        const node = __XmlNode.of("ResourceDescription", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    if (input.Changes != null) {
        const nodes = se_Changes(input.Changes, context);
        const containerNode = new __XmlNode("Changes");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const se_Changes = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = se_Change(entry, context);
        return node.withName("Change");
    });
};
const se_ChildHealthCheckList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("HealthCheckId", entry);
        return node.withName("ChildHealthCheck");
    });
};
const se_CidrCollectionChange = (input, context) => {
    const bodyNode = new __XmlNode("CidrCollectionChange");
    if (input.LocationName != null) {
        const node = __XmlNode.of("CidrLocationNameDefaultNotAllowed", input.LocationName).withName("LocationName");
        bodyNode.addChildNode(node);
    }
    if (input.Action != null) {
        const node = __XmlNode.of("CidrCollectionChangeAction", input.Action).withName("Action");
        bodyNode.addChildNode(node);
    }
    if (input.CidrList != null) {
        const nodes = se_CidrList(input.CidrList, context);
        const containerNode = new __XmlNode("CidrList");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const se_CidrCollectionChanges = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = se_CidrCollectionChange(entry, context);
        return node.withName("member");
    });
};
const se_CidrList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("Cidr", entry);
        return node.withName("Cidr");
    });
};
const se_CidrRoutingConfig = (input, context) => {
    const bodyNode = new __XmlNode("CidrRoutingConfig");
    if (input.CollectionId != null) {
        const node = __XmlNode.of("UUID", input.CollectionId).withName("CollectionId");
        bodyNode.addChildNode(node);
    }
    if (input.LocationName != null) {
        const node = __XmlNode.of("CidrLocationNameDefaultAllowed", input.LocationName).withName("LocationName");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_GeoLocation = (input, context) => {
    const bodyNode = new __XmlNode("GeoLocation");
    if (input.ContinentCode != null) {
        const node = __XmlNode.of("GeoLocationContinentCode", input.ContinentCode).withName("ContinentCode");
        bodyNode.addChildNode(node);
    }
    if (input.CountryCode != null) {
        const node = __XmlNode.of("GeoLocationCountryCode", input.CountryCode).withName("CountryCode");
        bodyNode.addChildNode(node);
    }
    if (input.SubdivisionCode != null) {
        const node = __XmlNode.of("GeoLocationSubdivisionCode", input.SubdivisionCode).withName("SubdivisionCode");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_HealthCheckConfig = (input, context) => {
    const bodyNode = new __XmlNode("HealthCheckConfig");
    if (input.IPAddress != null) {
        const node = __XmlNode.of("IPAddress", input.IPAddress).withName("IPAddress");
        bodyNode.addChildNode(node);
    }
    if (input.Port != null) {
        const node = __XmlNode.of("Port", String(input.Port)).withName("Port");
        bodyNode.addChildNode(node);
    }
    if (input.Type != null) {
        const node = __XmlNode.of("HealthCheckType", input.Type).withName("Type");
        bodyNode.addChildNode(node);
    }
    if (input.ResourcePath != null) {
        const node = __XmlNode.of("ResourcePath", input.ResourcePath).withName("ResourcePath");
        bodyNode.addChildNode(node);
    }
    if (input.FullyQualifiedDomainName != null) {
        const node = __XmlNode
            .of("FullyQualifiedDomainName", input.FullyQualifiedDomainName)
            .withName("FullyQualifiedDomainName");
        bodyNode.addChildNode(node);
    }
    if (input.SearchString != null) {
        const node = __XmlNode.of("SearchString", input.SearchString).withName("SearchString");
        bodyNode.addChildNode(node);
    }
    if (input.RequestInterval != null) {
        const node = __XmlNode.of("RequestInterval", String(input.RequestInterval)).withName("RequestInterval");
        bodyNode.addChildNode(node);
    }
    if (input.FailureThreshold != null) {
        const node = __XmlNode.of("FailureThreshold", String(input.FailureThreshold)).withName("FailureThreshold");
        bodyNode.addChildNode(node);
    }
    if (input.MeasureLatency != null) {
        const node = __XmlNode.of("MeasureLatency", String(input.MeasureLatency)).withName("MeasureLatency");
        bodyNode.addChildNode(node);
    }
    if (input.Inverted != null) {
        const node = __XmlNode.of("Inverted", String(input.Inverted)).withName("Inverted");
        bodyNode.addChildNode(node);
    }
    if (input.Disabled != null) {
        const node = __XmlNode.of("Disabled", String(input.Disabled)).withName("Disabled");
        bodyNode.addChildNode(node);
    }
    if (input.HealthThreshold != null) {
        const node = __XmlNode.of("HealthThreshold", String(input.HealthThreshold)).withName("HealthThreshold");
        bodyNode.addChildNode(node);
    }
    if (input.ChildHealthChecks != null) {
        const nodes = se_ChildHealthCheckList(input.ChildHealthChecks, context);
        const containerNode = new __XmlNode("ChildHealthChecks");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.EnableSNI != null) {
        const node = __XmlNode.of("EnableSNI", String(input.EnableSNI)).withName("EnableSNI");
        bodyNode.addChildNode(node);
    }
    if (input.Regions != null) {
        const nodes = se_HealthCheckRegionList(input.Regions, context);
        const containerNode = new __XmlNode("Regions");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.AlarmIdentifier != null) {
        const node = se_AlarmIdentifier(input.AlarmIdentifier, context).withName("AlarmIdentifier");
        bodyNode.addChildNode(node);
    }
    if (input.InsufficientDataHealthStatus != null) {
        const node = __XmlNode
            .of("InsufficientDataHealthStatus", input.InsufficientDataHealthStatus)
            .withName("InsufficientDataHealthStatus");
        bodyNode.addChildNode(node);
    }
    if (input.RoutingControlArn != null) {
        const node = __XmlNode.of("RoutingControlArn", input.RoutingControlArn).withName("RoutingControlArn");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_HealthCheckRegionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("HealthCheckRegion", entry);
        return node.withName("Region");
    });
};
const se_HostedZoneConfig = (input, context) => {
    const bodyNode = new __XmlNode("HostedZoneConfig");
    if (input.Comment != null) {
        const node = __XmlNode.of("ResourceDescription", input.Comment).withName("Comment");
        bodyNode.addChildNode(node);
    }
    if (input.PrivateZone != null) {
        const node = __XmlNode.of("IsPrivateZone", String(input.PrivateZone)).withName("PrivateZone");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_ResettableElementNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("ResettableElementName", entry);
        return node.withName("ResettableElementName");
    });
};
const se_ResourceRecord = (input, context) => {
    const bodyNode = new __XmlNode("ResourceRecord");
    if (input.Value != null) {
        const node = __XmlNode.of("RData", input.Value).withName("Value");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_ResourceRecords = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = se_ResourceRecord(entry, context);
        return node.withName("ResourceRecord");
    });
};
const se_ResourceRecordSet = (input, context) => {
    const bodyNode = new __XmlNode("ResourceRecordSet");
    if (input.Name != null) {
        const node = __XmlNode.of("DNSName", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    if (input.Type != null) {
        const node = __XmlNode.of("RRType", input.Type).withName("Type");
        bodyNode.addChildNode(node);
    }
    if (input.SetIdentifier != null) {
        const node = __XmlNode.of("ResourceRecordSetIdentifier", input.SetIdentifier).withName("SetIdentifier");
        bodyNode.addChildNode(node);
    }
    if (input.Weight != null) {
        const node = __XmlNode.of("ResourceRecordSetWeight", String(input.Weight)).withName("Weight");
        bodyNode.addChildNode(node);
    }
    if (input.Region != null) {
        const node = __XmlNode.of("ResourceRecordSetRegion", input.Region).withName("Region");
        bodyNode.addChildNode(node);
    }
    if (input.GeoLocation != null) {
        const node = se_GeoLocation(input.GeoLocation, context).withName("GeoLocation");
        bodyNode.addChildNode(node);
    }
    if (input.Failover != null) {
        const node = __XmlNode.of("ResourceRecordSetFailover", input.Failover).withName("Failover");
        bodyNode.addChildNode(node);
    }
    if (input.MultiValueAnswer != null) {
        const node = __XmlNode
            .of("ResourceRecordSetMultiValueAnswer", String(input.MultiValueAnswer))
            .withName("MultiValueAnswer");
        bodyNode.addChildNode(node);
    }
    if (input.TTL != null) {
        const node = __XmlNode.of("TTL", String(input.TTL)).withName("TTL");
        bodyNode.addChildNode(node);
    }
    if (input.ResourceRecords != null) {
        const nodes = se_ResourceRecords(input.ResourceRecords, context);
        const containerNode = new __XmlNode("ResourceRecords");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.AliasTarget != null) {
        const node = se_AliasTarget(input.AliasTarget, context).withName("AliasTarget");
        bodyNode.addChildNode(node);
    }
    if (input.HealthCheckId != null) {
        const node = __XmlNode.of("HealthCheckId", input.HealthCheckId).withName("HealthCheckId");
        bodyNode.addChildNode(node);
    }
    if (input.TrafficPolicyInstanceId != null) {
        const node = __XmlNode
            .of("TrafficPolicyInstanceId", input.TrafficPolicyInstanceId)
            .withName("TrafficPolicyInstanceId");
        bodyNode.addChildNode(node);
    }
    if (input.CidrRoutingConfig != null) {
        const node = se_CidrRoutingConfig(input.CidrRoutingConfig, context).withName("CidrRoutingConfig");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_Tag = (input, context) => {
    const bodyNode = new __XmlNode("Tag");
    if (input.Key != null) {
        const node = __XmlNode.of("TagKey", input.Key).withName("Key");
        bodyNode.addChildNode(node);
    }
    if (input.Value != null) {
        const node = __XmlNode.of("TagValue", input.Value).withName("Value");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_TagKeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("TagKey", entry);
        return node.withName("Key");
    });
};
const se_TagList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = se_Tag(entry, context);
        return node.withName("Tag");
    });
};
const se_TagResourceIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("TagResourceId", entry);
        return node.withName("ResourceId");
    });
};
const se_VPC = (input, context) => {
    const bodyNode = new __XmlNode("VPC");
    if (input.VPCRegion != null) {
        const node = __XmlNode.of("VPCRegion", input.VPCRegion).withName("VPCRegion");
        bodyNode.addChildNode(node);
    }
    if (input.VPCId != null) {
        const node = __XmlNode.of("VPCId", input.VPCId).withName("VPCId");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const de_AccountLimit = (output, context) => {
    const contents = {};
    if (output["Type"] !== undefined) {
        contents.Type = __expectString(output["Type"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = __strictParseLong(output["Value"]);
    }
    return contents;
};
const de_AlarmIdentifier = (output, context) => {
    const contents = {};
    if (output["Region"] !== undefined) {
        contents.Region = __expectString(output["Region"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    return contents;
};
const de_AliasTarget = (output, context) => {
    const contents = {};
    if (output["HostedZoneId"] !== undefined) {
        contents.HostedZoneId = __expectString(output["HostedZoneId"]);
    }
    if (output["DNSName"] !== undefined) {
        contents.DNSName = __expectString(output["DNSName"]);
    }
    if (output["EvaluateTargetHealth"] !== undefined) {
        contents.EvaluateTargetHealth = __parseBoolean(output["EvaluateTargetHealth"]);
    }
    return contents;
};
const de_ChangeInfo = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
        contents.Id = __expectString(output["Id"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output["SubmittedAt"] !== undefined) {
        contents.SubmittedAt = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["SubmittedAt"]));
    }
    if (output["Comment"] !== undefined) {
        contents.Comment = __expectString(output["Comment"]);
    }
    return contents;
};
const de_CheckerIpRanges = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ChildHealthCheckList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_CidrBlockSummaries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CidrBlockSummary(entry, context);
    });
};
const de_CidrBlockSummary = (output, context) => {
    const contents = {};
    if (output["CidrBlock"] !== undefined) {
        contents.CidrBlock = __expectString(output["CidrBlock"]);
    }
    if (output["LocationName"] !== undefined) {
        contents.LocationName = __expectString(output["LocationName"]);
    }
    return contents;
};
const de_CidrCollection = (output, context) => {
    const contents = {};
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    if (output["Id"] !== undefined) {
        contents.Id = __expectString(output["Id"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["Version"] !== undefined) {
        contents.Version = __strictParseLong(output["Version"]);
    }
    return contents;
};
const de_CidrRoutingConfig = (output, context) => {
    const contents = {};
    if (output["CollectionId"] !== undefined) {
        contents.CollectionId = __expectString(output["CollectionId"]);
    }
    if (output["LocationName"] !== undefined) {
        contents.LocationName = __expectString(output["LocationName"]);
    }
    return contents;
};
const de_CloudWatchAlarmConfiguration = (output, context) => {
    const contents = {};
    if (output["EvaluationPeriods"] !== undefined) {
        contents.EvaluationPeriods = __strictParseInt32(output["EvaluationPeriods"]);
    }
    if (output["Threshold"] !== undefined) {
        contents.Threshold = __strictParseFloat(output["Threshold"]);
    }
    if (output["ComparisonOperator"] !== undefined) {
        contents.ComparisonOperator = __expectString(output["ComparisonOperator"]);
    }
    if (output["Period"] !== undefined) {
        contents.Period = __strictParseInt32(output["Period"]);
    }
    if (output["MetricName"] !== undefined) {
        contents.MetricName = __expectString(output["MetricName"]);
    }
    if (output["Namespace"] !== undefined) {
        contents.Namespace = __expectString(output["Namespace"]);
    }
    if (output["Statistic"] !== undefined) {
        contents.Statistic = __expectString(output["Statistic"]);
    }
    if (output.Dimensions === "") {
        contents.Dimensions = [];
    }
    else if (output["Dimensions"] !== undefined && output["Dimensions"]["Dimension"] !== undefined) {
        contents.Dimensions = de_DimensionList(__getArrayIfSingleItem(output["Dimensions"]["Dimension"]), context);
    }
    return contents;
};
const de_CollectionSummaries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CollectionSummary(entry, context);
    });
};
const de_CollectionSummary = (output, context) => {
    const contents = {};
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    if (output["Id"] !== undefined) {
        contents.Id = __expectString(output["Id"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["Version"] !== undefined) {
        contents.Version = __strictParseLong(output["Version"]);
    }
    return contents;
};
const de_DelegationSet = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
        contents.Id = __expectString(output["Id"]);
    }
    if (output["CallerReference"] !== undefined) {
        contents.CallerReference = __expectString(output["CallerReference"]);
    }
    if (output.NameServers === "") {
        contents.NameServers = [];
    }
    else if (output["NameServers"] !== undefined && output["NameServers"]["NameServer"] !== undefined) {
        contents.NameServers = de_DelegationSetNameServers(__getArrayIfSingleItem(output["NameServers"]["NameServer"]), context);
    }
    return contents;
};
const de_DelegationSetNameServers = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_DelegationSets = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DelegationSet(entry, context);
    });
};
const de_Dimension = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = __expectString(output["Value"]);
    }
    return contents;
};
const de_DimensionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Dimension(entry, context);
    });
};
const de_DNSSECStatus = (output, context) => {
    const contents = {};
    if (output["ServeSignature"] !== undefined) {
        contents.ServeSignature = __expectString(output["ServeSignature"]);
    }
    if (output["StatusMessage"] !== undefined) {
        contents.StatusMessage = __expectString(output["StatusMessage"]);
    }
    return contents;
};
const de_ErrorMessages = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_GeoLocation = (output, context) => {
    const contents = {};
    if (output["ContinentCode"] !== undefined) {
        contents.ContinentCode = __expectString(output["ContinentCode"]);
    }
    if (output["CountryCode"] !== undefined) {
        contents.CountryCode = __expectString(output["CountryCode"]);
    }
    if (output["SubdivisionCode"] !== undefined) {
        contents.SubdivisionCode = __expectString(output["SubdivisionCode"]);
    }
    return contents;
};
const de_GeoLocationDetails = (output, context) => {
    const contents = {};
    if (output["ContinentCode"] !== undefined) {
        contents.ContinentCode = __expectString(output["ContinentCode"]);
    }
    if (output["ContinentName"] !== undefined) {
        contents.ContinentName = __expectString(output["ContinentName"]);
    }
    if (output["CountryCode"] !== undefined) {
        contents.CountryCode = __expectString(output["CountryCode"]);
    }
    if (output["CountryName"] !== undefined) {
        contents.CountryName = __expectString(output["CountryName"]);
    }
    if (output["SubdivisionCode"] !== undefined) {
        contents.SubdivisionCode = __expectString(output["SubdivisionCode"]);
    }
    if (output["SubdivisionName"] !== undefined) {
        contents.SubdivisionName = __expectString(output["SubdivisionName"]);
    }
    return contents;
};
const de_GeoLocationDetailsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_GeoLocationDetails(entry, context);
    });
};
const de_HealthCheck = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
        contents.Id = __expectString(output["Id"]);
    }
    if (output["CallerReference"] !== undefined) {
        contents.CallerReference = __expectString(output["CallerReference"]);
    }
    if (output["LinkedService"] !== undefined) {
        contents.LinkedService = de_LinkedService(output["LinkedService"], context);
    }
    if (output["HealthCheckConfig"] !== undefined) {
        contents.HealthCheckConfig = de_HealthCheckConfig(output["HealthCheckConfig"], context);
    }
    if (output["HealthCheckVersion"] !== undefined) {
        contents.HealthCheckVersion = __strictParseLong(output["HealthCheckVersion"]);
    }
    if (output["CloudWatchAlarmConfiguration"] !== undefined) {
        contents.CloudWatchAlarmConfiguration = de_CloudWatchAlarmConfiguration(output["CloudWatchAlarmConfiguration"], context);
    }
    return contents;
};
const de_HealthCheckConfig = (output, context) => {
    const contents = {};
    if (output["IPAddress"] !== undefined) {
        contents.IPAddress = __expectString(output["IPAddress"]);
    }
    if (output["Port"] !== undefined) {
        contents.Port = __strictParseInt32(output["Port"]);
    }
    if (output["Type"] !== undefined) {
        contents.Type = __expectString(output["Type"]);
    }
    if (output["ResourcePath"] !== undefined) {
        contents.ResourcePath = __expectString(output["ResourcePath"]);
    }
    if (output["FullyQualifiedDomainName"] !== undefined) {
        contents.FullyQualifiedDomainName = __expectString(output["FullyQualifiedDomainName"]);
    }
    if (output["SearchString"] !== undefined) {
        contents.SearchString = __expectString(output["SearchString"]);
    }
    if (output["RequestInterval"] !== undefined) {
        contents.RequestInterval = __strictParseInt32(output["RequestInterval"]);
    }
    if (output["FailureThreshold"] !== undefined) {
        contents.FailureThreshold = __strictParseInt32(output["FailureThreshold"]);
    }
    if (output["MeasureLatency"] !== undefined) {
        contents.MeasureLatency = __parseBoolean(output["MeasureLatency"]);
    }
    if (output["Inverted"] !== undefined) {
        contents.Inverted = __parseBoolean(output["Inverted"]);
    }
    if (output["Disabled"] !== undefined) {
        contents.Disabled = __parseBoolean(output["Disabled"]);
    }
    if (output["HealthThreshold"] !== undefined) {
        contents.HealthThreshold = __strictParseInt32(output["HealthThreshold"]);
    }
    if (output.ChildHealthChecks === "") {
        contents.ChildHealthChecks = [];
    }
    else if (output["ChildHealthChecks"] !== undefined &&
        output["ChildHealthChecks"]["ChildHealthCheck"] !== undefined) {
        contents.ChildHealthChecks = de_ChildHealthCheckList(__getArrayIfSingleItem(output["ChildHealthChecks"]["ChildHealthCheck"]), context);
    }
    if (output["EnableSNI"] !== undefined) {
        contents.EnableSNI = __parseBoolean(output["EnableSNI"]);
    }
    if (output.Regions === "") {
        contents.Regions = [];
    }
    else if (output["Regions"] !== undefined && output["Regions"]["Region"] !== undefined) {
        contents.Regions = de_HealthCheckRegionList(__getArrayIfSingleItem(output["Regions"]["Region"]), context);
    }
    if (output["AlarmIdentifier"] !== undefined) {
        contents.AlarmIdentifier = de_AlarmIdentifier(output["AlarmIdentifier"], context);
    }
    if (output["InsufficientDataHealthStatus"] !== undefined) {
        contents.InsufficientDataHealthStatus = __expectString(output["InsufficientDataHealthStatus"]);
    }
    if (output["RoutingControlArn"] !== undefined) {
        contents.RoutingControlArn = __expectString(output["RoutingControlArn"]);
    }
    return contents;
};
const de_HealthCheckObservation = (output, context) => {
    const contents = {};
    if (output["Region"] !== undefined) {
        contents.Region = __expectString(output["Region"]);
    }
    if (output["IPAddress"] !== undefined) {
        contents.IPAddress = __expectString(output["IPAddress"]);
    }
    if (output["StatusReport"] !== undefined) {
        contents.StatusReport = de_StatusReport(output["StatusReport"], context);
    }
    return contents;
};
const de_HealthCheckObservations = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_HealthCheckObservation(entry, context);
    });
};
const de_HealthCheckRegionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_HealthChecks = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_HealthCheck(entry, context);
    });
};
const de_HostedZone = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
        contents.Id = __expectString(output["Id"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["CallerReference"] !== undefined) {
        contents.CallerReference = __expectString(output["CallerReference"]);
    }
    if (output["Config"] !== undefined) {
        contents.Config = de_HostedZoneConfig(output["Config"], context);
    }
    if (output["ResourceRecordSetCount"] !== undefined) {
        contents.ResourceRecordSetCount = __strictParseLong(output["ResourceRecordSetCount"]);
    }
    if (output["LinkedService"] !== undefined) {
        contents.LinkedService = de_LinkedService(output["LinkedService"], context);
    }
    return contents;
};
const de_HostedZoneConfig = (output, context) => {
    const contents = {};
    if (output["Comment"] !== undefined) {
        contents.Comment = __expectString(output["Comment"]);
    }
    if (output["PrivateZone"] !== undefined) {
        contents.PrivateZone = __parseBoolean(output["PrivateZone"]);
    }
    return contents;
};
const de_HostedZoneLimit = (output, context) => {
    const contents = {};
    if (output["Type"] !== undefined) {
        contents.Type = __expectString(output["Type"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = __strictParseLong(output["Value"]);
    }
    return contents;
};
const de_HostedZoneOwner = (output, context) => {
    const contents = {};
    if (output["OwningAccount"] !== undefined) {
        contents.OwningAccount = __expectString(output["OwningAccount"]);
    }
    if (output["OwningService"] !== undefined) {
        contents.OwningService = __expectString(output["OwningService"]);
    }
    return contents;
};
const de_HostedZones = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_HostedZone(entry, context);
    });
};
const de_HostedZoneSummaries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_HostedZoneSummary(entry, context);
    });
};
const de_HostedZoneSummary = (output, context) => {
    const contents = {};
    if (output["HostedZoneId"] !== undefined) {
        contents.HostedZoneId = __expectString(output["HostedZoneId"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["Owner"] !== undefined) {
        contents.Owner = de_HostedZoneOwner(output["Owner"], context);
    }
    return contents;
};
const de_KeySigningKey = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["KmsArn"] !== undefined) {
        contents.KmsArn = __expectString(output["KmsArn"]);
    }
    if (output["Flag"] !== undefined) {
        contents.Flag = __strictParseInt32(output["Flag"]);
    }
    if (output["SigningAlgorithmMnemonic"] !== undefined) {
        contents.SigningAlgorithmMnemonic = __expectString(output["SigningAlgorithmMnemonic"]);
    }
    if (output["SigningAlgorithmType"] !== undefined) {
        contents.SigningAlgorithmType = __strictParseInt32(output["SigningAlgorithmType"]);
    }
    if (output["DigestAlgorithmMnemonic"] !== undefined) {
        contents.DigestAlgorithmMnemonic = __expectString(output["DigestAlgorithmMnemonic"]);
    }
    if (output["DigestAlgorithmType"] !== undefined) {
        contents.DigestAlgorithmType = __strictParseInt32(output["DigestAlgorithmType"]);
    }
    if (output["KeyTag"] !== undefined) {
        contents.KeyTag = __strictParseInt32(output["KeyTag"]);
    }
    if (output["DigestValue"] !== undefined) {
        contents.DigestValue = __expectString(output["DigestValue"]);
    }
    if (output["PublicKey"] !== undefined) {
        contents.PublicKey = __expectString(output["PublicKey"]);
    }
    if (output["DSRecord"] !== undefined) {
        contents.DSRecord = __expectString(output["DSRecord"]);
    }
    if (output["DNSKEYRecord"] !== undefined) {
        contents.DNSKEYRecord = __expectString(output["DNSKEYRecord"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output["StatusMessage"] !== undefined) {
        contents.StatusMessage = __expectString(output["StatusMessage"]);
    }
    if (output["CreatedDate"] !== undefined) {
        contents.CreatedDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreatedDate"]));
    }
    if (output["LastModifiedDate"] !== undefined) {
        contents.LastModifiedDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["LastModifiedDate"]));
    }
    return contents;
};
const de_KeySigningKeys = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KeySigningKey(entry, context);
    });
};
const de_LinkedService = (output, context) => {
    const contents = {};
    if (output["ServicePrincipal"] !== undefined) {
        contents.ServicePrincipal = __expectString(output["ServicePrincipal"]);
    }
    if (output["Description"] !== undefined) {
        contents.Description = __expectString(output["Description"]);
    }
    return contents;
};
const de_LocationSummaries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LocationSummary(entry, context);
    });
};
const de_LocationSummary = (output, context) => {
    const contents = {};
    if (output["LocationName"] !== undefined) {
        contents.LocationName = __expectString(output["LocationName"]);
    }
    return contents;
};
const de_QueryLoggingConfig = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
        contents.Id = __expectString(output["Id"]);
    }
    if (output["HostedZoneId"] !== undefined) {
        contents.HostedZoneId = __expectString(output["HostedZoneId"]);
    }
    if (output["CloudWatchLogsLogGroupArn"] !== undefined) {
        contents.CloudWatchLogsLogGroupArn = __expectString(output["CloudWatchLogsLogGroupArn"]);
    }
    return contents;
};
const de_QueryLoggingConfigs = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_QueryLoggingConfig(entry, context);
    });
};
const de_RecordData = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ResourceRecord = (output, context) => {
    const contents = {};
    if (output["Value"] !== undefined) {
        contents.Value = __expectString(output["Value"]);
    }
    return contents;
};
const de_ResourceRecords = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResourceRecord(entry, context);
    });
};
const de_ResourceRecordSet = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["Type"] !== undefined) {
        contents.Type = __expectString(output["Type"]);
    }
    if (output["SetIdentifier"] !== undefined) {
        contents.SetIdentifier = __expectString(output["SetIdentifier"]);
    }
    if (output["Weight"] !== undefined) {
        contents.Weight = __strictParseLong(output["Weight"]);
    }
    if (output["Region"] !== undefined) {
        contents.Region = __expectString(output["Region"]);
    }
    if (output["GeoLocation"] !== undefined) {
        contents.GeoLocation = de_GeoLocation(output["GeoLocation"], context);
    }
    if (output["Failover"] !== undefined) {
        contents.Failover = __expectString(output["Failover"]);
    }
    if (output["MultiValueAnswer"] !== undefined) {
        contents.MultiValueAnswer = __parseBoolean(output["MultiValueAnswer"]);
    }
    if (output["TTL"] !== undefined) {
        contents.TTL = __strictParseLong(output["TTL"]);
    }
    if (output.ResourceRecords === "") {
        contents.ResourceRecords = [];
    }
    else if (output["ResourceRecords"] !== undefined && output["ResourceRecords"]["ResourceRecord"] !== undefined) {
        contents.ResourceRecords = de_ResourceRecords(__getArrayIfSingleItem(output["ResourceRecords"]["ResourceRecord"]), context);
    }
    if (output["AliasTarget"] !== undefined) {
        contents.AliasTarget = de_AliasTarget(output["AliasTarget"], context);
    }
    if (output["HealthCheckId"] !== undefined) {
        contents.HealthCheckId = __expectString(output["HealthCheckId"]);
    }
    if (output["TrafficPolicyInstanceId"] !== undefined) {
        contents.TrafficPolicyInstanceId = __expectString(output["TrafficPolicyInstanceId"]);
    }
    if (output["CidrRoutingConfig"] !== undefined) {
        contents.CidrRoutingConfig = de_CidrRoutingConfig(output["CidrRoutingConfig"], context);
    }
    return contents;
};
const de_ResourceRecordSets = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResourceRecordSet(entry, context);
    });
};
const de_ResourceTagSet = (output, context) => {
    const contents = {};
    if (output["ResourceType"] !== undefined) {
        contents.ResourceType = __expectString(output["ResourceType"]);
    }
    if (output["ResourceId"] !== undefined) {
        contents.ResourceId = __expectString(output["ResourceId"]);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["Tag"] !== undefined) {
        contents.Tags = de_TagList(__getArrayIfSingleItem(output["Tags"]["Tag"]), context);
    }
    return contents;
};
const de_ResourceTagSetList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResourceTagSet(entry, context);
    });
};
const de_ReusableDelegationSetLimit = (output, context) => {
    const contents = {};
    if (output["Type"] !== undefined) {
        contents.Type = __expectString(output["Type"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = __strictParseLong(output["Value"]);
    }
    return contents;
};
const de_StatusReport = (output, context) => {
    const contents = {};
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output["CheckedTime"] !== undefined) {
        contents.CheckedTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CheckedTime"]));
    }
    return contents;
};
const de_Tag = (output, context) => {
    const contents = {};
    if (output["Key"] !== undefined) {
        contents.Key = __expectString(output["Key"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = __expectString(output["Value"]);
    }
    return contents;
};
const de_TagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tag(entry, context);
    });
};
const de_TrafficPolicies = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrafficPolicy(entry, context);
    });
};
const de_TrafficPolicy = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
        contents.Id = __expectString(output["Id"]);
    }
    if (output["Version"] !== undefined) {
        contents.Version = __strictParseInt32(output["Version"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["Type"] !== undefined) {
        contents.Type = __expectString(output["Type"]);
    }
    if (output["Document"] !== undefined) {
        contents.Document = __expectString(output["Document"]);
    }
    if (output["Comment"] !== undefined) {
        contents.Comment = __expectString(output["Comment"]);
    }
    return contents;
};
const de_TrafficPolicyInstance = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
        contents.Id = __expectString(output["Id"]);
    }
    if (output["HostedZoneId"] !== undefined) {
        contents.HostedZoneId = __expectString(output["HostedZoneId"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["TTL"] !== undefined) {
        contents.TTL = __strictParseLong(output["TTL"]);
    }
    if (output["State"] !== undefined) {
        contents.State = __expectString(output["State"]);
    }
    if (output["Message"] !== undefined) {
        contents.Message = __expectString(output["Message"]);
    }
    if (output["TrafficPolicyId"] !== undefined) {
        contents.TrafficPolicyId = __expectString(output["TrafficPolicyId"]);
    }
    if (output["TrafficPolicyVersion"] !== undefined) {
        contents.TrafficPolicyVersion = __strictParseInt32(output["TrafficPolicyVersion"]);
    }
    if (output["TrafficPolicyType"] !== undefined) {
        contents.TrafficPolicyType = __expectString(output["TrafficPolicyType"]);
    }
    return contents;
};
const de_TrafficPolicyInstances = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrafficPolicyInstance(entry, context);
    });
};
const de_TrafficPolicySummaries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrafficPolicySummary(entry, context);
    });
};
const de_TrafficPolicySummary = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
        contents.Id = __expectString(output["Id"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["Type"] !== undefined) {
        contents.Type = __expectString(output["Type"]);
    }
    if (output["LatestVersion"] !== undefined) {
        contents.LatestVersion = __strictParseInt32(output["LatestVersion"]);
    }
    if (output["TrafficPolicyCount"] !== undefined) {
        contents.TrafficPolicyCount = __strictParseInt32(output["TrafficPolicyCount"]);
    }
    return contents;
};
const de_VPC = (output, context) => {
    const contents = {};
    if (output["VPCRegion"] !== undefined) {
        contents.VPCRegion = __expectString(output["VPCRegion"]);
    }
    if (output["VPCId"] !== undefined) {
        contents.VPCId = __expectString(output["VPCId"]);
    }
    return contents;
};
const de_VPCs = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VPC(entry, context);
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return __getValueFromTextNode(parsedObjToReturn);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const loadRestXmlErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};
