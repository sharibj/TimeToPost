"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.se_GetDeploymentsCommand = exports.se_GetDeploymentCommand = exports.se_GetClientCertificatesCommand = exports.se_GetClientCertificateCommand = exports.se_GetBasePathMappingsCommand = exports.se_GetBasePathMappingCommand = exports.se_GetAuthorizersCommand = exports.se_GetAuthorizerCommand = exports.se_GetApiKeysCommand = exports.se_GetApiKeyCommand = exports.se_GetAccountCommand = exports.se_GenerateClientCertificateCommand = exports.se_FlushStageCacheCommand = exports.se_FlushStageAuthorizersCacheCommand = exports.se_DeleteVpcLinkCommand = exports.se_DeleteUsagePlanKeyCommand = exports.se_DeleteUsagePlanCommand = exports.se_DeleteStageCommand = exports.se_DeleteRestApiCommand = exports.se_DeleteResourceCommand = exports.se_DeleteRequestValidatorCommand = exports.se_DeleteModelCommand = exports.se_DeleteMethodResponseCommand = exports.se_DeleteMethodCommand = exports.se_DeleteIntegrationResponseCommand = exports.se_DeleteIntegrationCommand = exports.se_DeleteGatewayResponseCommand = exports.se_DeleteDomainNameCommand = exports.se_DeleteDocumentationVersionCommand = exports.se_DeleteDocumentationPartCommand = exports.se_DeleteDeploymentCommand = exports.se_DeleteClientCertificateCommand = exports.se_DeleteBasePathMappingCommand = exports.se_DeleteAuthorizerCommand = exports.se_DeleteApiKeyCommand = exports.se_CreateVpcLinkCommand = exports.se_CreateUsagePlanKeyCommand = exports.se_CreateUsagePlanCommand = exports.se_CreateStageCommand = exports.se_CreateRestApiCommand = exports.se_CreateResourceCommand = exports.se_CreateRequestValidatorCommand = exports.se_CreateModelCommand = exports.se_CreateDomainNameCommand = exports.se_CreateDocumentationVersionCommand = exports.se_CreateDocumentationPartCommand = exports.se_CreateDeploymentCommand = exports.se_CreateBasePathMappingCommand = exports.se_CreateAuthorizerCommand = exports.se_CreateApiKeyCommand = void 0;
exports.se_UpdateApiKeyCommand = exports.se_UpdateAccountCommand = exports.se_UntagResourceCommand = exports.se_TestInvokeMethodCommand = exports.se_TestInvokeAuthorizerCommand = exports.se_TagResourceCommand = exports.se_PutRestApiCommand = exports.se_PutMethodResponseCommand = exports.se_PutMethodCommand = exports.se_PutIntegrationResponseCommand = exports.se_PutIntegrationCommand = exports.se_PutGatewayResponseCommand = exports.se_ImportRestApiCommand = exports.se_ImportDocumentationPartsCommand = exports.se_ImportApiKeysCommand = exports.se_GetVpcLinksCommand = exports.se_GetVpcLinkCommand = exports.se_GetUsagePlansCommand = exports.se_GetUsagePlanKeysCommand = exports.se_GetUsagePlanKeyCommand = exports.se_GetUsagePlanCommand = exports.se_GetUsageCommand = exports.se_GetTagsCommand = exports.se_GetStagesCommand = exports.se_GetStageCommand = exports.se_GetSdkTypesCommand = exports.se_GetSdkTypeCommand = exports.se_GetSdkCommand = exports.se_GetRestApisCommand = exports.se_GetRestApiCommand = exports.se_GetResourcesCommand = exports.se_GetResourceCommand = exports.se_GetRequestValidatorsCommand = exports.se_GetRequestValidatorCommand = exports.se_GetModelTemplateCommand = exports.se_GetModelsCommand = exports.se_GetModelCommand = exports.se_GetMethodResponseCommand = exports.se_GetMethodCommand = exports.se_GetIntegrationResponseCommand = exports.se_GetIntegrationCommand = exports.se_GetGatewayResponsesCommand = exports.se_GetGatewayResponseCommand = exports.se_GetExportCommand = exports.se_GetDomainNamesCommand = exports.se_GetDomainNameCommand = exports.se_GetDocumentationVersionsCommand = exports.se_GetDocumentationVersionCommand = exports.se_GetDocumentationPartsCommand = exports.se_GetDocumentationPartCommand = void 0;
exports.de_DeleteRequestValidatorCommand = exports.de_DeleteModelCommand = exports.de_DeleteMethodResponseCommand = exports.de_DeleteMethodCommand = exports.de_DeleteIntegrationResponseCommand = exports.de_DeleteIntegrationCommand = exports.de_DeleteGatewayResponseCommand = exports.de_DeleteDomainNameCommand = exports.de_DeleteDocumentationVersionCommand = exports.de_DeleteDocumentationPartCommand = exports.de_DeleteDeploymentCommand = exports.de_DeleteClientCertificateCommand = exports.de_DeleteBasePathMappingCommand = exports.de_DeleteAuthorizerCommand = exports.de_DeleteApiKeyCommand = exports.de_CreateVpcLinkCommand = exports.de_CreateUsagePlanKeyCommand = exports.de_CreateUsagePlanCommand = exports.de_CreateStageCommand = exports.de_CreateRestApiCommand = exports.de_CreateResourceCommand = exports.de_CreateRequestValidatorCommand = exports.de_CreateModelCommand = exports.de_CreateDomainNameCommand = exports.de_CreateDocumentationVersionCommand = exports.de_CreateDocumentationPartCommand = exports.de_CreateDeploymentCommand = exports.de_CreateBasePathMappingCommand = exports.de_CreateAuthorizerCommand = exports.de_CreateApiKeyCommand = exports.se_UpdateVpcLinkCommand = exports.se_UpdateUsagePlanCommand = exports.se_UpdateUsageCommand = exports.se_UpdateStageCommand = exports.se_UpdateRestApiCommand = exports.se_UpdateResourceCommand = exports.se_UpdateRequestValidatorCommand = exports.se_UpdateModelCommand = exports.se_UpdateMethodResponseCommand = exports.se_UpdateMethodCommand = exports.se_UpdateIntegrationResponseCommand = exports.se_UpdateIntegrationCommand = exports.se_UpdateGatewayResponseCommand = exports.se_UpdateDomainNameCommand = exports.se_UpdateDocumentationVersionCommand = exports.se_UpdateDocumentationPartCommand = exports.se_UpdateDeploymentCommand = exports.se_UpdateClientCertificateCommand = exports.se_UpdateBasePathMappingCommand = exports.se_UpdateAuthorizerCommand = void 0;
exports.de_GetUsagePlanCommand = exports.de_GetUsageCommand = exports.de_GetTagsCommand = exports.de_GetStagesCommand = exports.de_GetStageCommand = exports.de_GetSdkTypesCommand = exports.de_GetSdkTypeCommand = exports.de_GetSdkCommand = exports.de_GetRestApisCommand = exports.de_GetRestApiCommand = exports.de_GetResourcesCommand = exports.de_GetResourceCommand = exports.de_GetRequestValidatorsCommand = exports.de_GetRequestValidatorCommand = exports.de_GetModelTemplateCommand = exports.de_GetModelsCommand = exports.de_GetModelCommand = exports.de_GetMethodResponseCommand = exports.de_GetMethodCommand = exports.de_GetIntegrationResponseCommand = exports.de_GetIntegrationCommand = exports.de_GetGatewayResponsesCommand = exports.de_GetGatewayResponseCommand = exports.de_GetExportCommand = exports.de_GetDomainNamesCommand = exports.de_GetDomainNameCommand = exports.de_GetDocumentationVersionsCommand = exports.de_GetDocumentationVersionCommand = exports.de_GetDocumentationPartsCommand = exports.de_GetDocumentationPartCommand = exports.de_GetDeploymentsCommand = exports.de_GetDeploymentCommand = exports.de_GetClientCertificatesCommand = exports.de_GetClientCertificateCommand = exports.de_GetBasePathMappingsCommand = exports.de_GetBasePathMappingCommand = exports.de_GetAuthorizersCommand = exports.de_GetAuthorizerCommand = exports.de_GetApiKeysCommand = exports.de_GetApiKeyCommand = exports.de_GetAccountCommand = exports.de_GenerateClientCertificateCommand = exports.de_FlushStageCacheCommand = exports.de_FlushStageAuthorizersCacheCommand = exports.de_DeleteVpcLinkCommand = exports.de_DeleteUsagePlanKeyCommand = exports.de_DeleteUsagePlanCommand = exports.de_DeleteStageCommand = exports.de_DeleteRestApiCommand = exports.de_DeleteResourceCommand = void 0;
exports.de_UpdateVpcLinkCommand = exports.de_UpdateUsagePlanCommand = exports.de_UpdateUsageCommand = exports.de_UpdateStageCommand = exports.de_UpdateRestApiCommand = exports.de_UpdateResourceCommand = exports.de_UpdateRequestValidatorCommand = exports.de_UpdateModelCommand = exports.de_UpdateMethodResponseCommand = exports.de_UpdateMethodCommand = exports.de_UpdateIntegrationResponseCommand = exports.de_UpdateIntegrationCommand = exports.de_UpdateGatewayResponseCommand = exports.de_UpdateDomainNameCommand = exports.de_UpdateDocumentationVersionCommand = exports.de_UpdateDocumentationPartCommand = exports.de_UpdateDeploymentCommand = exports.de_UpdateClientCertificateCommand = exports.de_UpdateBasePathMappingCommand = exports.de_UpdateAuthorizerCommand = exports.de_UpdateApiKeyCommand = exports.de_UpdateAccountCommand = exports.de_UntagResourceCommand = exports.de_TestInvokeMethodCommand = exports.de_TestInvokeAuthorizerCommand = exports.de_TagResourceCommand = exports.de_PutRestApiCommand = exports.de_PutMethodResponseCommand = exports.de_PutMethodCommand = exports.de_PutIntegrationResponseCommand = exports.de_PutIntegrationCommand = exports.de_PutGatewayResponseCommand = exports.de_ImportRestApiCommand = exports.de_ImportDocumentationPartsCommand = exports.de_ImportApiKeysCommand = exports.de_GetVpcLinksCommand = exports.de_GetVpcLinkCommand = exports.de_GetUsagePlansCommand = exports.de_GetUsagePlanKeysCommand = exports.de_GetUsagePlanKeyCommand = void 0;
const protocol_http_1 = require("@smithy/protocol-http");
const smithy_client_1 = require("@smithy/smithy-client");
const APIGatewayServiceException_1 = require("../models/APIGatewayServiceException");
const models_0_1 = require("../models/models_0");
const se_CreateApiKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/apikeys";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        customerId: [],
        description: [],
        enabled: [],
        generateDistinctId: [],
        name: [],
        stageKeys: (_) => (0, smithy_client_1._json)(_),
        tags: (_) => (0, smithy_client_1._json)(_),
        value: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateApiKeyCommand = se_CreateApiKeyCommand;
const se_CreateAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/authorizers";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        authType: [],
        authorizerCredentials: [],
        authorizerResultTtlInSeconds: [],
        authorizerUri: [],
        identitySource: [],
        identityValidationExpression: [],
        name: [],
        providerARNs: (_) => (0, smithy_client_1._json)(_),
        type: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateAuthorizerCommand = se_CreateAuthorizerCommand;
const se_CreateBasePathMappingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainnames/{domainName}/basepathmappings";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "domainName", () => input.domainName, "{domainName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        basePath: [],
        restApiId: [],
        stage: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateBasePathMappingCommand = se_CreateBasePathMappingCommand;
const se_CreateDeploymentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/deployments";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        cacheClusterEnabled: [],
        cacheClusterSize: [],
        canarySettings: (_) => se_DeploymentCanarySettings(_, context),
        description: [],
        stageDescription: [],
        stageName: [],
        tracingEnabled: [],
        variables: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateDeploymentCommand = se_CreateDeploymentCommand;
const se_CreateDocumentationPartCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/documentation/parts";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        location: (_) => (0, smithy_client_1._json)(_),
        properties: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateDocumentationPartCommand = se_CreateDocumentationPartCommand;
const se_CreateDocumentationVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/documentation/versions";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        description: [],
        documentationVersion: [],
        stageName: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateDocumentationVersionCommand = se_CreateDocumentationVersionCommand;
const se_CreateDomainNameCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/domainnames";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        certificateArn: [],
        certificateBody: [],
        certificateChain: [],
        certificateName: [],
        certificatePrivateKey: [],
        domainName: [],
        endpointConfiguration: (_) => (0, smithy_client_1._json)(_),
        mutualTlsAuthentication: (_) => (0, smithy_client_1._json)(_),
        ownershipVerificationCertificateArn: [],
        regionalCertificateArn: [],
        regionalCertificateName: [],
        securityPolicy: [],
        tags: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateDomainNameCommand = se_CreateDomainNameCommand;
const se_CreateModelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/models";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        contentType: [],
        description: [],
        name: [],
        schema: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateModelCommand = se_CreateModelCommand;
const se_CreateRequestValidatorCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/requestvalidators";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        name: [],
        validateRequestBody: [],
        validateRequestParameters: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateRequestValidatorCommand = se_CreateRequestValidatorCommand;
const se_CreateResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{parentId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "parentId", () => input.parentId, "{parentId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        pathPart: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateResourceCommand = se_CreateResourceCommand;
const se_CreateRestApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        apiKeySource: [],
        binaryMediaTypes: (_) => (0, smithy_client_1._json)(_),
        cloneFrom: [],
        description: [],
        disableExecuteApiEndpoint: [],
        endpointConfiguration: (_) => (0, smithy_client_1._json)(_),
        minimumCompressionSize: [],
        name: [],
        policy: [],
        tags: (_) => (0, smithy_client_1._json)(_),
        version: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateRestApiCommand = se_CreateRestApiCommand;
const se_CreateStageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/stages";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        cacheClusterEnabled: [],
        cacheClusterSize: [],
        canarySettings: (_) => se_CanarySettings(_, context),
        deploymentId: [],
        description: [],
        documentationVersion: [],
        stageName: [],
        tags: (_) => (0, smithy_client_1._json)(_),
        tracingEnabled: [],
        variables: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateStageCommand = se_CreateStageCommand;
const se_CreateUsagePlanCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        apiStages: (_) => se_ListOfApiStage(_, context),
        description: [],
        name: [],
        quota: (_) => (0, smithy_client_1._json)(_),
        tags: (_) => (0, smithy_client_1._json)(_),
        throttle: (_) => se_ThrottleSettings(_, context),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateUsagePlanCommand = se_CreateUsagePlanCommand;
const se_CreateUsagePlanKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans/{usagePlanId}/keys";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        keyId: [],
        keyType: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateUsagePlanKeyCommand = se_CreateUsagePlanKeyCommand;
const se_CreateVpcLinkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/vpclinks";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        description: [],
        name: [],
        tags: (_) => (0, smithy_client_1._json)(_),
        targetArns: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateVpcLinkCommand = se_CreateVpcLinkCommand;
const se_DeleteApiKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/apikeys/{apiKey}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "apiKey", () => input.apiKey, "{apiKey}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteApiKeyCommand = se_DeleteApiKeyCommand;
const se_DeleteAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/authorizers/{authorizerId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "authorizerId", () => input.authorizerId, "{authorizerId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteAuthorizerCommand = se_DeleteAuthorizerCommand;
const se_DeleteBasePathMappingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainnames/{domainName}/basepathmappings/{basePath}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "domainName", () => input.domainName, "{domainName}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "basePath", () => input.basePath, "{basePath}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteBasePathMappingCommand = se_DeleteBasePathMappingCommand;
const se_DeleteClientCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/clientcertificates/{clientCertificateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "clientCertificateId", () => input.clientCertificateId, "{clientCertificateId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteClientCertificateCommand = se_DeleteClientCertificateCommand;
const se_DeleteDeploymentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/deployments/{deploymentId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "deploymentId", () => input.deploymentId, "{deploymentId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteDeploymentCommand = se_DeleteDeploymentCommand;
const se_DeleteDocumentationPartCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/documentation/parts/{documentationPartId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "documentationPartId", () => input.documentationPartId, "{documentationPartId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteDocumentationPartCommand = se_DeleteDocumentationPartCommand;
const se_DeleteDocumentationVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/documentation/versions/{documentationVersion}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "documentationVersion", () => input.documentationVersion, "{documentationVersion}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteDocumentationVersionCommand = se_DeleteDocumentationVersionCommand;
const se_DeleteDomainNameCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/domainnames/{domainName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "domainName", () => input.domainName, "{domainName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteDomainNameCommand = se_DeleteDomainNameCommand;
const se_DeleteGatewayResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/gatewayresponses/{responseType}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "responseType", () => input.responseType, "{responseType}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteGatewayResponseCommand = se_DeleteGatewayResponseCommand;
const se_DeleteIntegrationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteIntegrationCommand = se_DeleteIntegrationCommand;
const se_DeleteIntegrationResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteIntegrationResponseCommand = se_DeleteIntegrationResponseCommand;
const se_DeleteMethodCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteMethodCommand = se_DeleteMethodCommand;
const se_DeleteMethodResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteMethodResponseCommand = se_DeleteMethodResponseCommand;
const se_DeleteModelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/models/{modelName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "modelName", () => input.modelName, "{modelName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteModelCommand = se_DeleteModelCommand;
const se_DeleteRequestValidatorCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/requestvalidators/{requestValidatorId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "requestValidatorId", () => input.requestValidatorId, "{requestValidatorId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteRequestValidatorCommand = se_DeleteRequestValidatorCommand;
const se_DeleteResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteResourceCommand = se_DeleteResourceCommand;
const se_DeleteRestApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteRestApiCommand = se_DeleteRestApiCommand;
const se_DeleteStageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/stages/{stageName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "stageName", () => input.stageName, "{stageName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteStageCommand = se_DeleteStageCommand;
const se_DeleteUsagePlanCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans/{usagePlanId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteUsagePlanCommand = se_DeleteUsagePlanCommand;
const se_DeleteUsagePlanKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans/{usagePlanId}/keys/{keyId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "keyId", () => input.keyId, "{keyId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteUsagePlanKeyCommand = se_DeleteUsagePlanKeyCommand;
const se_DeleteVpcLinkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/vpclinks/{vpcLinkId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "vpcLinkId", () => input.vpcLinkId, "{vpcLinkId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteVpcLinkCommand = se_DeleteVpcLinkCommand;
const se_FlushStageAuthorizersCacheCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/stages/{stageName}/cache/authorizers";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "stageName", () => input.stageName, "{stageName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_FlushStageAuthorizersCacheCommand = se_FlushStageAuthorizersCacheCommand;
const se_FlushStageCacheCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/stages/{stageName}/cache/data";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "stageName", () => input.stageName, "{stageName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_FlushStageCacheCommand = se_FlushStageCacheCommand;
const se_GenerateClientCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/clientcertificates";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        description: [],
        tags: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GenerateClientCertificateCommand = se_GenerateClientCertificateCommand;
const se_GetAccountCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/account";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetAccountCommand = se_GetAccountCommand;
const se_GetApiKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/apikeys/{apiKey}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "apiKey", () => input.apiKey, "{apiKey}", false);
    const query = (0, smithy_client_1.map)({
        includeValue: [() => input.includeValue !== void 0, () => input.includeValue.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetApiKeyCommand = se_GetApiKeyCommand;
const se_GetApiKeysCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/apikeys";
    const query = (0, smithy_client_1.map)({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
        name: [, input.nameQuery],
        customerId: [, input.customerId],
        includeValues: [() => input.includeValues !== void 0, () => input.includeValues.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetApiKeysCommand = se_GetApiKeysCommand;
const se_GetAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/authorizers/{authorizerId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "authorizerId", () => input.authorizerId, "{authorizerId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetAuthorizerCommand = se_GetAuthorizerCommand;
const se_GetAuthorizersCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/authorizers";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = (0, smithy_client_1.map)({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetAuthorizersCommand = se_GetAuthorizersCommand;
const se_GetBasePathMappingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainnames/{domainName}/basepathmappings/{basePath}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "domainName", () => input.domainName, "{domainName}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "basePath", () => input.basePath, "{basePath}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetBasePathMappingCommand = se_GetBasePathMappingCommand;
const se_GetBasePathMappingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainnames/{domainName}/basepathmappings";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "domainName", () => input.domainName, "{domainName}", false);
    const query = (0, smithy_client_1.map)({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetBasePathMappingsCommand = se_GetBasePathMappingsCommand;
const se_GetClientCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/clientcertificates/{clientCertificateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "clientCertificateId", () => input.clientCertificateId, "{clientCertificateId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetClientCertificateCommand = se_GetClientCertificateCommand;
const se_GetClientCertificatesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/clientcertificates";
    const query = (0, smithy_client_1.map)({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetClientCertificatesCommand = se_GetClientCertificatesCommand;
const se_GetDeploymentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/deployments/{deploymentId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "deploymentId", () => input.deploymentId, "{deploymentId}", false);
    const query = (0, smithy_client_1.map)({
        embed: [() => input.embed !== void 0, () => (input.embed || []).map((_entry) => _entry)],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetDeploymentCommand = se_GetDeploymentCommand;
const se_GetDeploymentsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/deployments";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = (0, smithy_client_1.map)({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetDeploymentsCommand = se_GetDeploymentsCommand;
const se_GetDocumentationPartCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/documentation/parts/{documentationPartId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "documentationPartId", () => input.documentationPartId, "{documentationPartId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetDocumentationPartCommand = se_GetDocumentationPartCommand;
const se_GetDocumentationPartsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/documentation/parts";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = (0, smithy_client_1.map)({
        type: [, input.type],
        name: [, input.nameQuery],
        path: [, input.path],
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
        locationStatus: [, input.locationStatus],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetDocumentationPartsCommand = se_GetDocumentationPartsCommand;
const se_GetDocumentationVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/documentation/versions/{documentationVersion}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "documentationVersion", () => input.documentationVersion, "{documentationVersion}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetDocumentationVersionCommand = se_GetDocumentationVersionCommand;
const se_GetDocumentationVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/documentation/versions";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = (0, smithy_client_1.map)({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetDocumentationVersionsCommand = se_GetDocumentationVersionsCommand;
const se_GetDomainNameCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/domainnames/{domainName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "domainName", () => input.domainName, "{domainName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetDomainNameCommand = se_GetDomainNameCommand;
const se_GetDomainNamesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/domainnames";
    const query = (0, smithy_client_1.map)({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetDomainNamesCommand = se_GetDomainNamesCommand;
const se_GetExportCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        accept: input.accepts,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/stages/{stageName}/exports/{exportType}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "stageName", () => input.stageName, "{stageName}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "exportType", () => input.exportType, "{exportType}", false);
    const query = (0, smithy_client_1.map)({
        ...(0, smithy_client_1.convertMap)(input.parameters),
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetExportCommand = se_GetExportCommand;
const se_GetGatewayResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/gatewayresponses/{responseType}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "responseType", () => input.responseType, "{responseType}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetGatewayResponseCommand = se_GetGatewayResponseCommand;
const se_GetGatewayResponsesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/gatewayresponses";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = (0, smithy_client_1.map)({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetGatewayResponsesCommand = se_GetGatewayResponsesCommand;
const se_GetIntegrationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetIntegrationCommand = se_GetIntegrationCommand;
const se_GetIntegrationResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetIntegrationResponseCommand = se_GetIntegrationResponseCommand;
const se_GetMethodCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetMethodCommand = se_GetMethodCommand;
const se_GetMethodResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetMethodResponseCommand = se_GetMethodResponseCommand;
const se_GetModelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/models/{modelName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "modelName", () => input.modelName, "{modelName}", false);
    const query = (0, smithy_client_1.map)({
        flatten: [() => input.flatten !== void 0, () => input.flatten.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetModelCommand = se_GetModelCommand;
const se_GetModelsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/models";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = (0, smithy_client_1.map)({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetModelsCommand = se_GetModelsCommand;
const se_GetModelTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/models/{modelName}/default_template";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "modelName", () => input.modelName, "{modelName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetModelTemplateCommand = se_GetModelTemplateCommand;
const se_GetRequestValidatorCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/requestvalidators/{requestValidatorId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "requestValidatorId", () => input.requestValidatorId, "{requestValidatorId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetRequestValidatorCommand = se_GetRequestValidatorCommand;
const se_GetRequestValidatorsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/requestvalidators";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = (0, smithy_client_1.map)({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetRequestValidatorsCommand = se_GetRequestValidatorsCommand;
const se_GetResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    const query = (0, smithy_client_1.map)({
        embed: [() => input.embed !== void 0, () => (input.embed || []).map((_entry) => _entry)],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetResourceCommand = se_GetResourceCommand;
const se_GetResourcesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/resources";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = (0, smithy_client_1.map)({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
        embed: [() => input.embed !== void 0, () => (input.embed || []).map((_entry) => _entry)],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetResourcesCommand = se_GetResourcesCommand;
const se_GetRestApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetRestApiCommand = se_GetRestApiCommand;
const se_GetRestApisCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis";
    const query = (0, smithy_client_1.map)({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetRestApisCommand = se_GetRestApisCommand;
const se_GetSdkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/stages/{stageName}/sdks/{sdkType}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "stageName", () => input.stageName, "{stageName}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "sdkType", () => input.sdkType, "{sdkType}", false);
    const query = (0, smithy_client_1.map)({
        ...(0, smithy_client_1.convertMap)(input.parameters),
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetSdkCommand = se_GetSdkCommand;
const se_GetSdkTypeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/sdktypes/{id}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "id", () => input.id, "{id}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetSdkTypeCommand = se_GetSdkTypeCommand;
const se_GetSdkTypesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/sdktypes";
    const query = (0, smithy_client_1.map)({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetSdkTypesCommand = se_GetSdkTypesCommand;
const se_GetStageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/stages/{stageName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "stageName", () => input.stageName, "{stageName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetStageCommand = se_GetStageCommand;
const se_GetStagesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/stages";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = (0, smithy_client_1.map)({
        deploymentId: [, input.deploymentId],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetStagesCommand = se_GetStagesCommand;
const se_GetTagsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/tags/{resourceArn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceArn", () => input.resourceArn, "{resourceArn}", false);
    const query = (0, smithy_client_1.map)({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetTagsCommand = se_GetTagsCommand;
const se_GetUsageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans/{usagePlanId}/usage";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    const query = (0, smithy_client_1.map)({
        keyId: [, input.keyId],
        startDate: [, (0, smithy_client_1.expectNonNull)(input.startDate, `startDate`)],
        endDate: [, (0, smithy_client_1.expectNonNull)(input.endDate, `endDate`)],
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetUsageCommand = se_GetUsageCommand;
const se_GetUsagePlanCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans/{usagePlanId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetUsagePlanCommand = se_GetUsagePlanCommand;
const se_GetUsagePlanKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans/{usagePlanId}/keys/{keyId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "keyId", () => input.keyId, "{keyId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetUsagePlanKeyCommand = se_GetUsagePlanKeyCommand;
const se_GetUsagePlanKeysCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans/{usagePlanId}/keys";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    const query = (0, smithy_client_1.map)({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
        name: [, input.nameQuery],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetUsagePlanKeysCommand = se_GetUsagePlanKeysCommand;
const se_GetUsagePlansCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans";
    const query = (0, smithy_client_1.map)({
        position: [, input.position],
        keyId: [, input.keyId],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetUsagePlansCommand = se_GetUsagePlansCommand;
const se_GetVpcLinkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/vpclinks/{vpcLinkId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "vpcLinkId", () => input.vpcLinkId, "{vpcLinkId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetVpcLinkCommand = se_GetVpcLinkCommand;
const se_GetVpcLinksCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/vpclinks";
    const query = (0, smithy_client_1.map)({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetVpcLinksCommand = se_GetVpcLinksCommand;
const se_ImportApiKeysCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/octet-stream",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/apikeys";
    const query = (0, smithy_client_1.map)({
        mode: [, "import"],
        format: [, (0, smithy_client_1.expectNonNull)(input.format, `format`)],
        failonwarnings: [() => input.failOnWarnings !== void 0, () => input.failOnWarnings.toString()],
    });
    let body;
    if (input.body !== undefined) {
        body = input.body;
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ImportApiKeysCommand = se_ImportApiKeysCommand;
const se_ImportDocumentationPartsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/octet-stream",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/documentation/parts";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = (0, smithy_client_1.map)({
        mode: [, input.mode],
        failonwarnings: [() => input.failOnWarnings !== void 0, () => input.failOnWarnings.toString()],
    });
    let body;
    if (input.body !== undefined) {
        body = input.body;
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ImportDocumentationPartsCommand = se_ImportDocumentationPartsCommand;
const se_ImportRestApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/octet-stream",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis";
    const query = (0, smithy_client_1.map)({
        mode: [, "import"],
        ...(0, smithy_client_1.convertMap)(input.parameters),
        failonwarnings: [() => input.failOnWarnings !== void 0, () => input.failOnWarnings.toString()],
    });
    let body;
    if (input.body !== undefined) {
        body = input.body;
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ImportRestApiCommand = se_ImportRestApiCommand;
const se_PutGatewayResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/gatewayresponses/{responseType}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "responseType", () => input.responseType, "{responseType}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        responseParameters: (_) => (0, smithy_client_1._json)(_),
        responseTemplates: (_) => (0, smithy_client_1._json)(_),
        statusCode: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_PutGatewayResponseCommand = se_PutGatewayResponseCommand;
const se_PutIntegrationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        cacheKeyParameters: (_) => (0, smithy_client_1._json)(_),
        cacheNamespace: [],
        connectionId: [],
        connectionType: [],
        contentHandling: [],
        credentials: [],
        httpMethod: [, , `integrationHttpMethod`],
        passthroughBehavior: [],
        requestParameters: (_) => (0, smithy_client_1._json)(_),
        requestTemplates: (_) => (0, smithy_client_1._json)(_),
        timeoutInMillis: [],
        tlsConfig: (_) => (0, smithy_client_1._json)(_),
        type: [],
        uri: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_PutIntegrationCommand = se_PutIntegrationCommand;
const se_PutIntegrationResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        contentHandling: [],
        responseParameters: (_) => (0, smithy_client_1._json)(_),
        responseTemplates: (_) => (0, smithy_client_1._json)(_),
        selectionPattern: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_PutIntegrationResponseCommand = se_PutIntegrationResponseCommand;
const se_PutMethodCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        apiKeyRequired: [],
        authorizationScopes: (_) => (0, smithy_client_1._json)(_),
        authorizationType: [],
        authorizerId: [],
        operationName: [],
        requestModels: (_) => (0, smithy_client_1._json)(_),
        requestParameters: (_) => (0, smithy_client_1._json)(_),
        requestValidatorId: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_PutMethodCommand = se_PutMethodCommand;
const se_PutMethodResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        responseModels: (_) => (0, smithy_client_1._json)(_),
        responseParameters: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_PutMethodResponseCommand = se_PutMethodResponseCommand;
const se_PutRestApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/octet-stream",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = (0, smithy_client_1.map)({
        ...(0, smithy_client_1.convertMap)(input.parameters),
        mode: [, input.mode],
        failonwarnings: [() => input.failOnWarnings !== void 0, () => input.failOnWarnings.toString()],
    });
    let body;
    if (input.body !== undefined) {
        body = input.body;
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_PutRestApiCommand = se_PutRestApiCommand;
const se_TagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/tags/{resourceArn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceArn", () => input.resourceArn, "{resourceArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        tags: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_TagResourceCommand = se_TagResourceCommand;
const se_TestInvokeAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/authorizers/{authorizerId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "authorizerId", () => input.authorizerId, "{authorizerId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        additionalContext: (_) => (0, smithy_client_1._json)(_),
        body: [],
        headers: (_) => (0, smithy_client_1._json)(_),
        multiValueHeaders: (_) => (0, smithy_client_1._json)(_),
        pathWithQueryString: [],
        stageVariables: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_TestInvokeAuthorizerCommand = se_TestInvokeAuthorizerCommand;
const se_TestInvokeMethodCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        body: [],
        clientCertificateId: [],
        headers: (_) => (0, smithy_client_1._json)(_),
        multiValueHeaders: (_) => (0, smithy_client_1._json)(_),
        pathWithQueryString: [],
        stageVariables: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_TestInvokeMethodCommand = se_TestInvokeMethodCommand;
const se_UntagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/tags/{resourceArn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceArn", () => input.resourceArn, "{resourceArn}", false);
    const query = (0, smithy_client_1.map)({
        tagKeys: [
            (0, smithy_client_1.expectNonNull)(input.tagKeys, `tagKeys`) != null,
            () => (input.tagKeys || []).map((_entry) => _entry),
        ],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_UntagResourceCommand = se_UntagResourceCommand;
const se_UpdateAccountCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/account";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateAccountCommand = se_UpdateAccountCommand;
const se_UpdateApiKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/apikeys/{apiKey}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "apiKey", () => input.apiKey, "{apiKey}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateApiKeyCommand = se_UpdateApiKeyCommand;
const se_UpdateAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/authorizers/{authorizerId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "authorizerId", () => input.authorizerId, "{authorizerId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateAuthorizerCommand = se_UpdateAuthorizerCommand;
const se_UpdateBasePathMappingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainnames/{domainName}/basepathmappings/{basePath}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "domainName", () => input.domainName, "{domainName}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "basePath", () => input.basePath, "{basePath}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateBasePathMappingCommand = se_UpdateBasePathMappingCommand;
const se_UpdateClientCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/clientcertificates/{clientCertificateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "clientCertificateId", () => input.clientCertificateId, "{clientCertificateId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateClientCertificateCommand = se_UpdateClientCertificateCommand;
const se_UpdateDeploymentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/deployments/{deploymentId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "deploymentId", () => input.deploymentId, "{deploymentId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateDeploymentCommand = se_UpdateDeploymentCommand;
const se_UpdateDocumentationPartCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/documentation/parts/{documentationPartId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "documentationPartId", () => input.documentationPartId, "{documentationPartId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateDocumentationPartCommand = se_UpdateDocumentationPartCommand;
const se_UpdateDocumentationVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/documentation/versions/{documentationVersion}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "documentationVersion", () => input.documentationVersion, "{documentationVersion}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateDocumentationVersionCommand = se_UpdateDocumentationVersionCommand;
const se_UpdateDomainNameCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/domainnames/{domainName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "domainName", () => input.domainName, "{domainName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateDomainNameCommand = se_UpdateDomainNameCommand;
const se_UpdateGatewayResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/gatewayresponses/{responseType}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "responseType", () => input.responseType, "{responseType}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateGatewayResponseCommand = se_UpdateGatewayResponseCommand;
const se_UpdateIntegrationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateIntegrationCommand = se_UpdateIntegrationCommand;
const se_UpdateIntegrationResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateIntegrationResponseCommand = se_UpdateIntegrationResponseCommand;
const se_UpdateMethodCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateMethodCommand = se_UpdateMethodCommand;
const se_UpdateMethodResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateMethodResponseCommand = se_UpdateMethodResponseCommand;
const se_UpdateModelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/models/{modelName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "modelName", () => input.modelName, "{modelName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateModelCommand = se_UpdateModelCommand;
const se_UpdateRequestValidatorCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/requestvalidators/{requestValidatorId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "requestValidatorId", () => input.requestValidatorId, "{requestValidatorId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateRequestValidatorCommand = se_UpdateRequestValidatorCommand;
const se_UpdateResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateResourceCommand = se_UpdateResourceCommand;
const se_UpdateRestApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateRestApiCommand = se_UpdateRestApiCommand;
const se_UpdateStageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/stages/{stageName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "stageName", () => input.stageName, "{stageName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateStageCommand = se_UpdateStageCommand;
const se_UpdateUsageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/usageplans/{usagePlanId}/keys/{keyId}/usage";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "keyId", () => input.keyId, "{keyId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateUsageCommand = se_UpdateUsageCommand;
const se_UpdateUsagePlanCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans/{usagePlanId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateUsagePlanCommand = se_UpdateUsagePlanCommand;
const se_UpdateVpcLinkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/vpclinks/{vpcLinkId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "vpcLinkId", () => input.vpcLinkId, "{vpcLinkId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        patchOperations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateVpcLinkCommand = se_UpdateVpcLinkCommand;
const de_CreateApiKeyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateApiKeyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        customerId: smithy_client_1.expectString,
        description: smithy_client_1.expectString,
        enabled: smithy_client_1.expectBoolean,
        id: smithy_client_1.expectString,
        lastUpdatedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        name: smithy_client_1.expectString,
        stageKeys: smithy_client_1._json,
        tags: smithy_client_1._json,
        value: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateApiKeyCommand = de_CreateApiKeyCommand;
const de_CreateApiKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateAuthorizerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        authType: smithy_client_1.expectString,
        authorizerCredentials: smithy_client_1.expectString,
        authorizerResultTtlInSeconds: smithy_client_1.expectInt32,
        authorizerUri: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
        identitySource: smithy_client_1.expectString,
        identityValidationExpression: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        providerARNs: smithy_client_1._json,
        type: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateAuthorizerCommand = de_CreateAuthorizerCommand;
const de_CreateAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateBasePathMappingCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateBasePathMappingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        basePath: smithy_client_1.expectString,
        restApiId: smithy_client_1.expectString,
        stage: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateBasePathMappingCommand = de_CreateBasePathMappingCommand;
const de_CreateBasePathMappingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateDeploymentCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        apiSummary: smithy_client_1._json,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateDeploymentCommand = de_CreateDeploymentCommand;
const de_CreateDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.apigateway#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateDocumentationPartCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateDocumentationPartCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        id: smithy_client_1.expectString,
        location: smithy_client_1._json,
        properties: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateDocumentationPartCommand = de_CreateDocumentationPartCommand;
const de_CreateDocumentationPartCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateDocumentationVersionCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateDocumentationVersionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        version: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateDocumentationVersionCommand = de_CreateDocumentationVersionCommand;
const de_CreateDocumentationVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateDomainNameCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        certificateArn: smithy_client_1.expectString,
        certificateName: smithy_client_1.expectString,
        certificateUploadDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        distributionDomainName: smithy_client_1.expectString,
        distributionHostedZoneId: smithy_client_1.expectString,
        domainName: smithy_client_1.expectString,
        domainNameStatus: smithy_client_1.expectString,
        domainNameStatusMessage: smithy_client_1.expectString,
        endpointConfiguration: smithy_client_1._json,
        mutualTlsAuthentication: smithy_client_1._json,
        ownershipVerificationCertificateArn: smithy_client_1.expectString,
        regionalCertificateArn: smithy_client_1.expectString,
        regionalCertificateName: smithy_client_1.expectString,
        regionalDomainName: smithy_client_1.expectString,
        regionalHostedZoneId: smithy_client_1.expectString,
        securityPolicy: smithy_client_1.expectString,
        tags: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateDomainNameCommand = de_CreateDomainNameCommand;
const de_CreateDomainNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateModelCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateModelCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        contentType: smithy_client_1.expectString,
        description: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        schema: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateModelCommand = de_CreateModelCommand;
const de_CreateModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateRequestValidatorCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateRequestValidatorCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        id: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        validateRequestBody: smithy_client_1.expectBoolean,
        validateRequestParameters: smithy_client_1.expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateRequestValidatorCommand = de_CreateRequestValidatorCommand;
const de_CreateRequestValidatorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateResourceCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        id: smithy_client_1.expectString,
        parentId: smithy_client_1.expectString,
        path: smithy_client_1.expectString,
        pathPart: smithy_client_1.expectString,
        resourceMethods: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateResourceCommand = de_CreateResourceCommand;
const de_CreateResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateRestApiCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateRestApiCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        apiKeySource: smithy_client_1.expectString,
        binaryMediaTypes: smithy_client_1._json,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        disableExecuteApiEndpoint: smithy_client_1.expectBoolean,
        endpointConfiguration: smithy_client_1._json,
        id: smithy_client_1.expectString,
        minimumCompressionSize: smithy_client_1.expectInt32,
        name: smithy_client_1.expectString,
        policy: smithy_client_1.expectString,
        rootResourceId: smithy_client_1.expectString,
        tags: smithy_client_1._json,
        version: smithy_client_1.expectString,
        warnings: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateRestApiCommand = de_CreateRestApiCommand;
const de_CreateRestApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateStageCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateStageCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        accessLogSettings: smithy_client_1._json,
        cacheClusterEnabled: smithy_client_1.expectBoolean,
        cacheClusterSize: smithy_client_1.expectString,
        cacheClusterStatus: smithy_client_1.expectString,
        canarySettings: (_) => de_CanarySettings(_, context),
        clientCertificateId: smithy_client_1.expectString,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        deploymentId: smithy_client_1.expectString,
        description: smithy_client_1.expectString,
        documentationVersion: smithy_client_1.expectString,
        lastUpdatedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        methodSettings: (_) => de_MapOfMethodSettings(_, context),
        stageName: smithy_client_1.expectString,
        tags: smithy_client_1._json,
        tracingEnabled: smithy_client_1.expectBoolean,
        variables: smithy_client_1._json,
        webAclArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateStageCommand = de_CreateStageCommand;
const de_CreateStageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateUsagePlanCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateUsagePlanCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        apiStages: (_) => de_ListOfApiStage(_, context),
        description: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        productCode: smithy_client_1.expectString,
        quota: smithy_client_1._json,
        tags: smithy_client_1._json,
        throttle: (_) => de_ThrottleSettings(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateUsagePlanCommand = de_CreateUsagePlanCommand;
const de_CreateUsagePlanCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateUsagePlanKeyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateUsagePlanKeyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        id: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        type: smithy_client_1.expectString,
        value: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateUsagePlanKeyCommand = de_CreateUsagePlanKeyCommand;
const de_CreateUsagePlanKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CreateVpcLinkCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        description: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        status: smithy_client_1.expectString,
        statusMessage: smithy_client_1.expectString,
        tags: smithy_client_1._json,
        targetArns: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateVpcLinkCommand = de_CreateVpcLinkCommand;
const de_CreateVpcLinkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteApiKeyCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteApiKeyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteApiKeyCommand = de_DeleteApiKeyCommand;
const de_DeleteApiKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteAuthorizerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteAuthorizerCommand = de_DeleteAuthorizerCommand;
const de_DeleteAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteBasePathMappingCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteBasePathMappingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteBasePathMappingCommand = de_DeleteBasePathMappingCommand;
const de_DeleteBasePathMappingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteClientCertificateCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteClientCertificateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteClientCertificateCommand = de_DeleteClientCertificateCommand;
const de_DeleteClientCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteDeploymentCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteDeploymentCommand = de_DeleteDeploymentCommand;
const de_DeleteDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteDocumentationPartCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteDocumentationPartCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteDocumentationPartCommand = de_DeleteDocumentationPartCommand;
const de_DeleteDocumentationPartCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteDocumentationVersionCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteDocumentationVersionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteDocumentationVersionCommand = de_DeleteDocumentationVersionCommand;
const de_DeleteDocumentationVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteDomainNameCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteDomainNameCommand = de_DeleteDomainNameCommand;
const de_DeleteDomainNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteGatewayResponseCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteGatewayResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteGatewayResponseCommand = de_DeleteGatewayResponseCommand;
const de_DeleteGatewayResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteIntegrationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteIntegrationCommand = de_DeleteIntegrationCommand;
const de_DeleteIntegrationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteIntegrationResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteIntegrationResponseCommand = de_DeleteIntegrationResponseCommand;
const de_DeleteIntegrationResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteMethodCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteMethodCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteMethodCommand = de_DeleteMethodCommand;
const de_DeleteMethodCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteMethodResponseCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteMethodResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteMethodResponseCommand = de_DeleteMethodResponseCommand;
const de_DeleteMethodResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteModelCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteModelCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteModelCommand = de_DeleteModelCommand;
const de_DeleteModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteRequestValidatorCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteRequestValidatorCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteRequestValidatorCommand = de_DeleteRequestValidatorCommand;
const de_DeleteRequestValidatorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteResourceCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteResourceCommand = de_DeleteResourceCommand;
const de_DeleteResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteRestApiCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteRestApiCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteRestApiCommand = de_DeleteRestApiCommand;
const de_DeleteRestApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteStageCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteStageCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteStageCommand = de_DeleteStageCommand;
const de_DeleteStageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteUsagePlanCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteUsagePlanCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteUsagePlanCommand = de_DeleteUsagePlanCommand;
const de_DeleteUsagePlanCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteUsagePlanKeyCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteUsagePlanKeyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteUsagePlanKeyCommand = de_DeleteUsagePlanKeyCommand;
const de_DeleteUsagePlanKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteVpcLinkCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteVpcLinkCommand = de_DeleteVpcLinkCommand;
const de_DeleteVpcLinkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_FlushStageAuthorizersCacheCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_FlushStageAuthorizersCacheCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_FlushStageAuthorizersCacheCommand = de_FlushStageAuthorizersCacheCommand;
const de_FlushStageAuthorizersCacheCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_FlushStageCacheCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_FlushStageCacheCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_FlushStageCacheCommand = de_FlushStageCacheCommand;
const de_FlushStageCacheCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GenerateClientCertificateCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_GenerateClientCertificateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        clientCertificateId: smithy_client_1.expectString,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        expirationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        pemEncodedCertificate: smithy_client_1.expectString,
        tags: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GenerateClientCertificateCommand = de_GenerateClientCertificateCommand;
const de_GenerateClientCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetAccountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAccountCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        apiKeyVersion: smithy_client_1.expectString,
        cloudwatchRoleArn: smithy_client_1.expectString,
        features: smithy_client_1._json,
        throttleSettings: (_) => de_ThrottleSettings(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetAccountCommand = de_GetAccountCommand;
const de_GetAccountCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetApiKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetApiKeyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        customerId: smithy_client_1.expectString,
        description: smithy_client_1.expectString,
        enabled: smithy_client_1.expectBoolean,
        id: smithy_client_1.expectString,
        lastUpdatedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        name: smithy_client_1.expectString,
        stageKeys: smithy_client_1._json,
        tags: smithy_client_1._json,
        value: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetApiKeyCommand = de_GetApiKeyCommand;
const de_GetApiKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetApiKeysCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetApiKeysCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        items: [, (_) => de_ListOfApiKey(_, context), `item`],
        position: smithy_client_1.expectString,
        warnings: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetApiKeysCommand = de_GetApiKeysCommand;
const de_GetApiKeysCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAuthorizerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        authType: smithy_client_1.expectString,
        authorizerCredentials: smithy_client_1.expectString,
        authorizerResultTtlInSeconds: smithy_client_1.expectInt32,
        authorizerUri: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
        identitySource: smithy_client_1.expectString,
        identityValidationExpression: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        providerARNs: smithy_client_1._json,
        type: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetAuthorizerCommand = de_GetAuthorizerCommand;
const de_GetAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetAuthorizersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAuthorizersCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        items: [, smithy_client_1._json, `item`],
        position: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetAuthorizersCommand = de_GetAuthorizersCommand;
const de_GetAuthorizersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetBasePathMappingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBasePathMappingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        basePath: smithy_client_1.expectString,
        restApiId: smithy_client_1.expectString,
        stage: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetBasePathMappingCommand = de_GetBasePathMappingCommand;
const de_GetBasePathMappingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetBasePathMappingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBasePathMappingsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        items: [, smithy_client_1._json, `item`],
        position: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetBasePathMappingsCommand = de_GetBasePathMappingsCommand;
const de_GetBasePathMappingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetClientCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetClientCertificateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        clientCertificateId: smithy_client_1.expectString,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        expirationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        pemEncodedCertificate: smithy_client_1.expectString,
        tags: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetClientCertificateCommand = de_GetClientCertificateCommand;
const de_GetClientCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetClientCertificatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetClientCertificatesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        items: [, (_) => de_ListOfClientCertificate(_, context), `item`],
        position: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetClientCertificatesCommand = de_GetClientCertificatesCommand;
const de_GetClientCertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDeploymentCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        apiSummary: smithy_client_1._json,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetDeploymentCommand = de_GetDeploymentCommand;
const de_GetDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.apigateway#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDeploymentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDeploymentsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        items: [, (_) => de_ListOfDeployment(_, context), `item`],
        position: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetDeploymentsCommand = de_GetDeploymentsCommand;
const de_GetDeploymentsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.apigateway#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDocumentationPartCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDocumentationPartCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        id: smithy_client_1.expectString,
        location: smithy_client_1._json,
        properties: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetDocumentationPartCommand = de_GetDocumentationPartCommand;
const de_GetDocumentationPartCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDocumentationPartsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDocumentationPartsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        items: [, smithy_client_1._json, `item`],
        position: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetDocumentationPartsCommand = de_GetDocumentationPartsCommand;
const de_GetDocumentationPartsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDocumentationVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDocumentationVersionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        version: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetDocumentationVersionCommand = de_GetDocumentationVersionCommand;
const de_GetDocumentationVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDocumentationVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDocumentationVersionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        items: [, (_) => de_ListOfDocumentationVersion(_, context), `item`],
        position: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetDocumentationVersionsCommand = de_GetDocumentationVersionsCommand;
const de_GetDocumentationVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDomainNameCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        certificateArn: smithy_client_1.expectString,
        certificateName: smithy_client_1.expectString,
        certificateUploadDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        distributionDomainName: smithy_client_1.expectString,
        distributionHostedZoneId: smithy_client_1.expectString,
        domainName: smithy_client_1.expectString,
        domainNameStatus: smithy_client_1.expectString,
        domainNameStatusMessage: smithy_client_1.expectString,
        endpointConfiguration: smithy_client_1._json,
        mutualTlsAuthentication: smithy_client_1._json,
        ownershipVerificationCertificateArn: smithy_client_1.expectString,
        regionalCertificateArn: smithy_client_1.expectString,
        regionalCertificateName: smithy_client_1.expectString,
        regionalDomainName: smithy_client_1.expectString,
        regionalHostedZoneId: smithy_client_1.expectString,
        securityPolicy: smithy_client_1.expectString,
        tags: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetDomainNameCommand = de_GetDomainNameCommand;
const de_GetDomainNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDomainNamesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDomainNamesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        items: [, (_) => de_ListOfDomainName(_, context), `item`],
        position: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetDomainNamesCommand = de_GetDomainNamesCommand;
const de_GetDomainNamesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetExportCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetExportCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        contentType: [, output.headers["content-type"]],
        contentDisposition: [, output.headers["content-disposition"]],
    });
    const data = await (0, smithy_client_1.collectBody)(output.body, context);
    contents.body = data;
    return contents;
};
exports.de_GetExportCommand = de_GetExportCommand;
const de_GetExportCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetGatewayResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetGatewayResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        defaultResponse: smithy_client_1.expectBoolean,
        responseParameters: smithy_client_1._json,
        responseTemplates: smithy_client_1._json,
        responseType: smithy_client_1.expectString,
        statusCode: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetGatewayResponseCommand = de_GetGatewayResponseCommand;
const de_GetGatewayResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetGatewayResponsesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetGatewayResponsesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        items: [, smithy_client_1._json, `item`],
        position: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetGatewayResponsesCommand = de_GetGatewayResponsesCommand;
const de_GetGatewayResponsesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetIntegrationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        cacheKeyParameters: smithy_client_1._json,
        cacheNamespace: smithy_client_1.expectString,
        connectionId: smithy_client_1.expectString,
        connectionType: smithy_client_1.expectString,
        contentHandling: smithy_client_1.expectString,
        credentials: smithy_client_1.expectString,
        httpMethod: smithy_client_1.expectString,
        integrationResponses: smithy_client_1._json,
        passthroughBehavior: smithy_client_1.expectString,
        requestParameters: smithy_client_1._json,
        requestTemplates: smithy_client_1._json,
        timeoutInMillis: smithy_client_1.expectInt32,
        tlsConfig: smithy_client_1._json,
        type: smithy_client_1.expectString,
        uri: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetIntegrationCommand = de_GetIntegrationCommand;
const de_GetIntegrationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetIntegrationResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        contentHandling: smithy_client_1.expectString,
        responseParameters: smithy_client_1._json,
        responseTemplates: smithy_client_1._json,
        selectionPattern: smithy_client_1.expectString,
        statusCode: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetIntegrationResponseCommand = de_GetIntegrationResponseCommand;
const de_GetIntegrationResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetMethodCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetMethodCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        apiKeyRequired: smithy_client_1.expectBoolean,
        authorizationScopes: smithy_client_1._json,
        authorizationType: smithy_client_1.expectString,
        authorizerId: smithy_client_1.expectString,
        httpMethod: smithy_client_1.expectString,
        methodIntegration: smithy_client_1._json,
        methodResponses: smithy_client_1._json,
        operationName: smithy_client_1.expectString,
        requestModels: smithy_client_1._json,
        requestParameters: smithy_client_1._json,
        requestValidatorId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetMethodCommand = de_GetMethodCommand;
const de_GetMethodCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetMethodResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetMethodResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        responseModels: smithy_client_1._json,
        responseParameters: smithy_client_1._json,
        statusCode: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetMethodResponseCommand = de_GetMethodResponseCommand;
const de_GetMethodResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetModelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetModelCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        contentType: smithy_client_1.expectString,
        description: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        schema: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetModelCommand = de_GetModelCommand;
const de_GetModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetModelsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetModelsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        items: [, smithy_client_1._json, `item`],
        position: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetModelsCommand = de_GetModelsCommand;
const de_GetModelsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetModelTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetModelTemplateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        value: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetModelTemplateCommand = de_GetModelTemplateCommand;
const de_GetModelTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetRequestValidatorCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRequestValidatorCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        id: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        validateRequestBody: smithy_client_1.expectBoolean,
        validateRequestParameters: smithy_client_1.expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetRequestValidatorCommand = de_GetRequestValidatorCommand;
const de_GetRequestValidatorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetRequestValidatorsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRequestValidatorsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        items: [, smithy_client_1._json, `item`],
        position: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetRequestValidatorsCommand = de_GetRequestValidatorsCommand;
const de_GetRequestValidatorsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        id: smithy_client_1.expectString,
        parentId: smithy_client_1.expectString,
        path: smithy_client_1.expectString,
        pathPart: smithy_client_1.expectString,
        resourceMethods: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetResourceCommand = de_GetResourceCommand;
const de_GetResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetResourcesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetResourcesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        items: [, smithy_client_1._json, `item`],
        position: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetResourcesCommand = de_GetResourcesCommand;
const de_GetResourcesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetRestApiCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRestApiCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        apiKeySource: smithy_client_1.expectString,
        binaryMediaTypes: smithy_client_1._json,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        disableExecuteApiEndpoint: smithy_client_1.expectBoolean,
        endpointConfiguration: smithy_client_1._json,
        id: smithy_client_1.expectString,
        minimumCompressionSize: smithy_client_1.expectInt32,
        name: smithy_client_1.expectString,
        policy: smithy_client_1.expectString,
        rootResourceId: smithy_client_1.expectString,
        tags: smithy_client_1._json,
        version: smithy_client_1.expectString,
        warnings: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetRestApiCommand = de_GetRestApiCommand;
const de_GetRestApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetRestApisCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRestApisCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        items: [, (_) => de_ListOfRestApi(_, context), `item`],
        position: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetRestApisCommand = de_GetRestApisCommand;
const de_GetRestApisCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetSdkCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetSdkCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        contentType: [, output.headers["content-type"]],
        contentDisposition: [, output.headers["content-disposition"]],
    });
    const data = await (0, smithy_client_1.collectBody)(output.body, context);
    contents.body = data;
    return contents;
};
exports.de_GetSdkCommand = de_GetSdkCommand;
const de_GetSdkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetSdkTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetSdkTypeCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        configurationProperties: smithy_client_1._json,
        description: smithy_client_1.expectString,
        friendlyName: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetSdkTypeCommand = de_GetSdkTypeCommand;
const de_GetSdkTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetSdkTypesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetSdkTypesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        items: [, smithy_client_1._json, `item`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetSdkTypesCommand = de_GetSdkTypesCommand;
const de_GetSdkTypesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetStageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetStageCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        accessLogSettings: smithy_client_1._json,
        cacheClusterEnabled: smithy_client_1.expectBoolean,
        cacheClusterSize: smithy_client_1.expectString,
        cacheClusterStatus: smithy_client_1.expectString,
        canarySettings: (_) => de_CanarySettings(_, context),
        clientCertificateId: smithy_client_1.expectString,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        deploymentId: smithy_client_1.expectString,
        description: smithy_client_1.expectString,
        documentationVersion: smithy_client_1.expectString,
        lastUpdatedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        methodSettings: (_) => de_MapOfMethodSettings(_, context),
        stageName: smithy_client_1.expectString,
        tags: smithy_client_1._json,
        tracingEnabled: smithy_client_1.expectBoolean,
        variables: smithy_client_1._json,
        webAclArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetStageCommand = de_GetStageCommand;
const de_GetStageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetStagesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetStagesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        item: (_) => de_ListOfStage(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetStagesCommand = de_GetStagesCommand;
const de_GetStagesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetTagsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetTagsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        tags: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetTagsCommand = de_GetTagsCommand;
const de_GetTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetUsageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetUsageCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        endDate: smithy_client_1.expectString,
        items: [, smithy_client_1._json, `values`],
        position: smithy_client_1.expectString,
        startDate: smithy_client_1.expectString,
        usagePlanId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetUsageCommand = de_GetUsageCommand;
const de_GetUsageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetUsagePlanCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetUsagePlanCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        apiStages: (_) => de_ListOfApiStage(_, context),
        description: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        productCode: smithy_client_1.expectString,
        quota: smithy_client_1._json,
        tags: smithy_client_1._json,
        throttle: (_) => de_ThrottleSettings(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetUsagePlanCommand = de_GetUsagePlanCommand;
const de_GetUsagePlanCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetUsagePlanKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetUsagePlanKeyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        id: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        type: smithy_client_1.expectString,
        value: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetUsagePlanKeyCommand = de_GetUsagePlanKeyCommand;
const de_GetUsagePlanKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetUsagePlanKeysCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetUsagePlanKeysCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        items: [, smithy_client_1._json, `item`],
        position: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetUsagePlanKeysCommand = de_GetUsagePlanKeysCommand;
const de_GetUsagePlanKeysCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetUsagePlansCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetUsagePlansCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        items: [, (_) => de_ListOfUsagePlan(_, context), `item`],
        position: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetUsagePlansCommand = de_GetUsagePlansCommand;
const de_GetUsagePlansCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetVpcLinkCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        description: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        status: smithy_client_1.expectString,
        statusMessage: smithy_client_1.expectString,
        tags: smithy_client_1._json,
        targetArns: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetVpcLinkCommand = de_GetVpcLinkCommand;
const de_GetVpcLinkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetVpcLinksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetVpcLinksCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        items: [, smithy_client_1._json, `item`],
        position: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetVpcLinksCommand = de_GetVpcLinksCommand;
const de_GetVpcLinksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ImportApiKeysCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_ImportApiKeysCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ids: smithy_client_1._json,
        warnings: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ImportApiKeysCommand = de_ImportApiKeysCommand;
const de_ImportApiKeysCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ImportDocumentationPartsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ImportDocumentationPartsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ids: smithy_client_1._json,
        warnings: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ImportDocumentationPartsCommand = de_ImportDocumentationPartsCommand;
const de_ImportDocumentationPartsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ImportRestApiCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_ImportRestApiCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        apiKeySource: smithy_client_1.expectString,
        binaryMediaTypes: smithy_client_1._json,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        disableExecuteApiEndpoint: smithy_client_1.expectBoolean,
        endpointConfiguration: smithy_client_1._json,
        id: smithy_client_1.expectString,
        minimumCompressionSize: smithy_client_1.expectInt32,
        name: smithy_client_1.expectString,
        policy: smithy_client_1.expectString,
        rootResourceId: smithy_client_1.expectString,
        tags: smithy_client_1._json,
        version: smithy_client_1.expectString,
        warnings: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ImportRestApiCommand = de_ImportRestApiCommand;
const de_ImportRestApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PutGatewayResponseCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_PutGatewayResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        defaultResponse: smithy_client_1.expectBoolean,
        responseParameters: smithy_client_1._json,
        responseTemplates: smithy_client_1._json,
        responseType: smithy_client_1.expectString,
        statusCode: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_PutGatewayResponseCommand = de_PutGatewayResponseCommand;
const de_PutGatewayResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PutIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_PutIntegrationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        cacheKeyParameters: smithy_client_1._json,
        cacheNamespace: smithy_client_1.expectString,
        connectionId: smithy_client_1.expectString,
        connectionType: smithy_client_1.expectString,
        contentHandling: smithy_client_1.expectString,
        credentials: smithy_client_1.expectString,
        httpMethod: smithy_client_1.expectString,
        integrationResponses: smithy_client_1._json,
        passthroughBehavior: smithy_client_1.expectString,
        requestParameters: smithy_client_1._json,
        requestTemplates: smithy_client_1._json,
        timeoutInMillis: smithy_client_1.expectInt32,
        tlsConfig: smithy_client_1._json,
        type: smithy_client_1.expectString,
        uri: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_PutIntegrationCommand = de_PutIntegrationCommand;
const de_PutIntegrationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PutIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_PutIntegrationResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        contentHandling: smithy_client_1.expectString,
        responseParameters: smithy_client_1._json,
        responseTemplates: smithy_client_1._json,
        selectionPattern: smithy_client_1.expectString,
        statusCode: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_PutIntegrationResponseCommand = de_PutIntegrationResponseCommand;
const de_PutIntegrationResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PutMethodCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_PutMethodCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        apiKeyRequired: smithy_client_1.expectBoolean,
        authorizationScopes: smithy_client_1._json,
        authorizationType: smithy_client_1.expectString,
        authorizerId: smithy_client_1.expectString,
        httpMethod: smithy_client_1.expectString,
        methodIntegration: smithy_client_1._json,
        methodResponses: smithy_client_1._json,
        operationName: smithy_client_1.expectString,
        requestModels: smithy_client_1._json,
        requestParameters: smithy_client_1._json,
        requestValidatorId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_PutMethodCommand = de_PutMethodCommand;
const de_PutMethodCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PutMethodResponseCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_PutMethodResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        responseModels: smithy_client_1._json,
        responseParameters: smithy_client_1._json,
        statusCode: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_PutMethodResponseCommand = de_PutMethodResponseCommand;
const de_PutMethodResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PutRestApiCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutRestApiCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        apiKeySource: smithy_client_1.expectString,
        binaryMediaTypes: smithy_client_1._json,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        disableExecuteApiEndpoint: smithy_client_1.expectBoolean,
        endpointConfiguration: smithy_client_1._json,
        id: smithy_client_1.expectString,
        minimumCompressionSize: smithy_client_1.expectInt32,
        name: smithy_client_1.expectString,
        policy: smithy_client_1.expectString,
        rootResourceId: smithy_client_1.expectString,
        tags: smithy_client_1._json,
        version: smithy_client_1.expectString,
        warnings: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_PutRestApiCommand = de_PutRestApiCommand;
const de_PutRestApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_TagResourceCommand = de_TagResourceCommand;
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_TestInvokeAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_TestInvokeAuthorizerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        authorization: smithy_client_1._json,
        claims: smithy_client_1._json,
        clientStatus: smithy_client_1.expectInt32,
        latency: smithy_client_1.expectLong,
        log: smithy_client_1.expectString,
        policy: smithy_client_1.expectString,
        principalId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_TestInvokeAuthorizerCommand = de_TestInvokeAuthorizerCommand;
const de_TestInvokeAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_TestInvokeMethodCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_TestInvokeMethodCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        body: smithy_client_1.expectString,
        headers: smithy_client_1._json,
        latency: smithy_client_1.expectLong,
        log: smithy_client_1.expectString,
        multiValueHeaders: smithy_client_1._json,
        status: smithy_client_1.expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_TestInvokeMethodCommand = de_TestInvokeMethodCommand;
const de_TestInvokeMethodCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UntagResourceCommand = de_UntagResourceCommand;
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateAccountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateAccountCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        apiKeyVersion: smithy_client_1.expectString,
        cloudwatchRoleArn: smithy_client_1.expectString,
        features: smithy_client_1._json,
        throttleSettings: (_) => de_ThrottleSettings(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateAccountCommand = de_UpdateAccountCommand;
const de_UpdateAccountCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateApiKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateApiKeyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        customerId: smithy_client_1.expectString,
        description: smithy_client_1.expectString,
        enabled: smithy_client_1.expectBoolean,
        id: smithy_client_1.expectString,
        lastUpdatedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        name: smithy_client_1.expectString,
        stageKeys: smithy_client_1._json,
        tags: smithy_client_1._json,
        value: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateApiKeyCommand = de_UpdateApiKeyCommand;
const de_UpdateApiKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateAuthorizerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        authType: smithy_client_1.expectString,
        authorizerCredentials: smithy_client_1.expectString,
        authorizerResultTtlInSeconds: smithy_client_1.expectInt32,
        authorizerUri: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
        identitySource: smithy_client_1.expectString,
        identityValidationExpression: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        providerARNs: smithy_client_1._json,
        type: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateAuthorizerCommand = de_UpdateAuthorizerCommand;
const de_UpdateAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateBasePathMappingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateBasePathMappingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        basePath: smithy_client_1.expectString,
        restApiId: smithy_client_1.expectString,
        stage: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateBasePathMappingCommand = de_UpdateBasePathMappingCommand;
const de_UpdateBasePathMappingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateClientCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateClientCertificateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        clientCertificateId: smithy_client_1.expectString,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        expirationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        pemEncodedCertificate: smithy_client_1.expectString,
        tags: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateClientCertificateCommand = de_UpdateClientCertificateCommand;
const de_UpdateClientCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDeploymentCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        apiSummary: smithy_client_1._json,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateDeploymentCommand = de_UpdateDeploymentCommand;
const de_UpdateDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.apigateway#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateDocumentationPartCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDocumentationPartCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        id: smithy_client_1.expectString,
        location: smithy_client_1._json,
        properties: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateDocumentationPartCommand = de_UpdateDocumentationPartCommand;
const de_UpdateDocumentationPartCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateDocumentationVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDocumentationVersionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        version: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateDocumentationVersionCommand = de_UpdateDocumentationVersionCommand;
const de_UpdateDocumentationVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDomainNameCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        certificateArn: smithy_client_1.expectString,
        certificateName: smithy_client_1.expectString,
        certificateUploadDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        distributionDomainName: smithy_client_1.expectString,
        distributionHostedZoneId: smithy_client_1.expectString,
        domainName: smithy_client_1.expectString,
        domainNameStatus: smithy_client_1.expectString,
        domainNameStatusMessage: smithy_client_1.expectString,
        endpointConfiguration: smithy_client_1._json,
        mutualTlsAuthentication: smithy_client_1._json,
        ownershipVerificationCertificateArn: smithy_client_1.expectString,
        regionalCertificateArn: smithy_client_1.expectString,
        regionalCertificateName: smithy_client_1.expectString,
        regionalDomainName: smithy_client_1.expectString,
        regionalHostedZoneId: smithy_client_1.expectString,
        securityPolicy: smithy_client_1.expectString,
        tags: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateDomainNameCommand = de_UpdateDomainNameCommand;
const de_UpdateDomainNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateGatewayResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateGatewayResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        defaultResponse: smithy_client_1.expectBoolean,
        responseParameters: smithy_client_1._json,
        responseTemplates: smithy_client_1._json,
        responseType: smithy_client_1.expectString,
        statusCode: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateGatewayResponseCommand = de_UpdateGatewayResponseCommand;
const de_UpdateGatewayResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateIntegrationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        cacheKeyParameters: smithy_client_1._json,
        cacheNamespace: smithy_client_1.expectString,
        connectionId: smithy_client_1.expectString,
        connectionType: smithy_client_1.expectString,
        contentHandling: smithy_client_1.expectString,
        credentials: smithy_client_1.expectString,
        httpMethod: smithy_client_1.expectString,
        integrationResponses: smithy_client_1._json,
        passthroughBehavior: smithy_client_1.expectString,
        requestParameters: smithy_client_1._json,
        requestTemplates: smithy_client_1._json,
        timeoutInMillis: smithy_client_1.expectInt32,
        tlsConfig: smithy_client_1._json,
        type: smithy_client_1.expectString,
        uri: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateIntegrationCommand = de_UpdateIntegrationCommand;
const de_UpdateIntegrationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateIntegrationResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        contentHandling: smithy_client_1.expectString,
        responseParameters: smithy_client_1._json,
        responseTemplates: smithy_client_1._json,
        selectionPattern: smithy_client_1.expectString,
        statusCode: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateIntegrationResponseCommand = de_UpdateIntegrationResponseCommand;
const de_UpdateIntegrationResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateMethodCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateMethodCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        apiKeyRequired: smithy_client_1.expectBoolean,
        authorizationScopes: smithy_client_1._json,
        authorizationType: smithy_client_1.expectString,
        authorizerId: smithy_client_1.expectString,
        httpMethod: smithy_client_1.expectString,
        methodIntegration: smithy_client_1._json,
        methodResponses: smithy_client_1._json,
        operationName: smithy_client_1.expectString,
        requestModels: smithy_client_1._json,
        requestParameters: smithy_client_1._json,
        requestValidatorId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateMethodCommand = de_UpdateMethodCommand;
const de_UpdateMethodCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateMethodResponseCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_UpdateMethodResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        responseModels: smithy_client_1._json,
        responseParameters: smithy_client_1._json,
        statusCode: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateMethodResponseCommand = de_UpdateMethodResponseCommand;
const de_UpdateMethodResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateModelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateModelCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        contentType: smithy_client_1.expectString,
        description: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        schema: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateModelCommand = de_UpdateModelCommand;
const de_UpdateModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateRequestValidatorCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateRequestValidatorCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        id: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        validateRequestBody: smithy_client_1.expectBoolean,
        validateRequestParameters: smithy_client_1.expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateRequestValidatorCommand = de_UpdateRequestValidatorCommand;
const de_UpdateRequestValidatorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        id: smithy_client_1.expectString,
        parentId: smithy_client_1.expectString,
        path: smithy_client_1.expectString,
        pathPart: smithy_client_1.expectString,
        resourceMethods: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateResourceCommand = de_UpdateResourceCommand;
const de_UpdateResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateRestApiCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateRestApiCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        apiKeySource: smithy_client_1.expectString,
        binaryMediaTypes: smithy_client_1._json,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        disableExecuteApiEndpoint: smithy_client_1.expectBoolean,
        endpointConfiguration: smithy_client_1._json,
        id: smithy_client_1.expectString,
        minimumCompressionSize: smithy_client_1.expectInt32,
        name: smithy_client_1.expectString,
        policy: smithy_client_1.expectString,
        rootResourceId: smithy_client_1.expectString,
        tags: smithy_client_1._json,
        version: smithy_client_1.expectString,
        warnings: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateRestApiCommand = de_UpdateRestApiCommand;
const de_UpdateRestApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateStageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateStageCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        accessLogSettings: smithy_client_1._json,
        cacheClusterEnabled: smithy_client_1.expectBoolean,
        cacheClusterSize: smithy_client_1.expectString,
        cacheClusterStatus: smithy_client_1.expectString,
        canarySettings: (_) => de_CanarySettings(_, context),
        clientCertificateId: smithy_client_1.expectString,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        deploymentId: smithy_client_1.expectString,
        description: smithy_client_1.expectString,
        documentationVersion: smithy_client_1.expectString,
        lastUpdatedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        methodSettings: (_) => de_MapOfMethodSettings(_, context),
        stageName: smithy_client_1.expectString,
        tags: smithy_client_1._json,
        tracingEnabled: smithy_client_1.expectBoolean,
        variables: smithy_client_1._json,
        webAclArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateStageCommand = de_UpdateStageCommand;
const de_UpdateStageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateUsageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateUsageCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        endDate: smithy_client_1.expectString,
        items: [, smithy_client_1._json, `values`],
        position: smithy_client_1.expectString,
        startDate: smithy_client_1.expectString,
        usagePlanId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateUsageCommand = de_UpdateUsageCommand;
const de_UpdateUsageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateUsagePlanCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateUsagePlanCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        apiStages: (_) => de_ListOfApiStage(_, context),
        description: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        productCode: smithy_client_1.expectString,
        quota: smithy_client_1._json,
        tags: smithy_client_1._json,
        throttle: (_) => de_ThrottleSettings(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateUsagePlanCommand = de_UpdateUsagePlanCommand;
const de_UpdateUsagePlanCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateVpcLinkCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        description: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        status: smithy_client_1.expectString,
        statusMessage: smithy_client_1.expectString,
        tags: smithy_client_1._json,
        targetArns: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateVpcLinkCommand = de_UpdateVpcLinkCommand;
const de_UpdateVpcLinkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = (0, smithy_client_1.withBaseException)(APIGatewayServiceException_1.APIGatewayServiceException);
const de_BadRequestExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.BadRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({
        retryAfterSeconds: [, parsedOutput.headers["retry-after"]],
    });
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_NotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.NotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ServiceUnavailableExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({
        retryAfterSeconds: [, parsedOutput.headers["retry-after"]],
    });
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({
        retryAfterSeconds: [, parsedOutput.headers["retry-after"]],
    });
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.UnauthorizedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const se_ApiStage = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        apiId: [],
        stage: [],
        throttle: (_) => se_MapOfApiStageThrottleSettings(_, context),
    });
};
const se_CanarySettings = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        deploymentId: [],
        percentTraffic: smithy_client_1.serializeFloat,
        stageVariableOverrides: smithy_client_1._json,
        useStageCache: [],
    });
};
const se_DeploymentCanarySettings = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        percentTraffic: smithy_client_1.serializeFloat,
        stageVariableOverrides: smithy_client_1._json,
        useStageCache: [],
    });
};
const se_ListOfApiStage = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ApiStage(entry, context);
    });
};
const se_MapOfApiStageThrottleSettings = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_ThrottleSettings(value, context);
        return acc;
    }, {});
};
const se_ThrottleSettings = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        burstLimit: [],
        rateLimit: smithy_client_1.serializeFloat,
    });
};
const de_ApiKey = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        customerId: smithy_client_1.expectString,
        description: smithy_client_1.expectString,
        enabled: smithy_client_1.expectBoolean,
        id: smithy_client_1.expectString,
        lastUpdatedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        name: smithy_client_1.expectString,
        stageKeys: smithy_client_1._json,
        tags: smithy_client_1._json,
        value: smithy_client_1.expectString,
    });
};
const de_ApiStage = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        apiId: smithy_client_1.expectString,
        stage: smithy_client_1.expectString,
        throttle: (_) => de_MapOfApiStageThrottleSettings(_, context),
    });
};
const de_CanarySettings = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        deploymentId: smithy_client_1.expectString,
        percentTraffic: smithy_client_1.limitedParseDouble,
        stageVariableOverrides: smithy_client_1._json,
        useStageCache: smithy_client_1.expectBoolean,
    });
};
const de_ClientCertificate = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        clientCertificateId: smithy_client_1.expectString,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        expirationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        pemEncodedCertificate: smithy_client_1.expectString,
        tags: smithy_client_1._json,
    });
};
const de_Deployment = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        apiSummary: smithy_client_1._json,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
    });
};
const de_DocumentationVersion = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        version: smithy_client_1.expectString,
    });
};
const de_DomainName = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        certificateArn: smithy_client_1.expectString,
        certificateName: smithy_client_1.expectString,
        certificateUploadDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        distributionDomainName: smithy_client_1.expectString,
        distributionHostedZoneId: smithy_client_1.expectString,
        domainName: smithy_client_1.expectString,
        domainNameStatus: smithy_client_1.expectString,
        domainNameStatusMessage: smithy_client_1.expectString,
        endpointConfiguration: smithy_client_1._json,
        mutualTlsAuthentication: smithy_client_1._json,
        ownershipVerificationCertificateArn: smithy_client_1.expectString,
        regionalCertificateArn: smithy_client_1.expectString,
        regionalCertificateName: smithy_client_1.expectString,
        regionalDomainName: smithy_client_1.expectString,
        regionalHostedZoneId: smithy_client_1.expectString,
        securityPolicy: smithy_client_1.expectString,
        tags: smithy_client_1._json,
    });
};
const de_ListOfApiKey = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ApiKey(entry, context);
    });
    return retVal;
};
const de_ListOfApiStage = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ApiStage(entry, context);
    });
    return retVal;
};
const de_ListOfClientCertificate = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClientCertificate(entry, context);
    });
    return retVal;
};
const de_ListOfDeployment = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Deployment(entry, context);
    });
    return retVal;
};
const de_ListOfDocumentationVersion = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DocumentationVersion(entry, context);
    });
    return retVal;
};
const de_ListOfDomainName = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DomainName(entry, context);
    });
    return retVal;
};
const de_ListOfRestApi = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RestApi(entry, context);
    });
    return retVal;
};
const de_ListOfStage = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Stage(entry, context);
    });
    return retVal;
};
const de_ListOfUsagePlan = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UsagePlan(entry, context);
    });
    return retVal;
};
const de_MapOfApiStageThrottleSettings = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_ThrottleSettings(value, context);
        return acc;
    }, {});
};
const de_MapOfMethodSettings = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_MethodSetting(value, context);
        return acc;
    }, {});
};
const de_MethodSetting = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        cacheDataEncrypted: smithy_client_1.expectBoolean,
        cacheTtlInSeconds: smithy_client_1.expectInt32,
        cachingEnabled: smithy_client_1.expectBoolean,
        dataTraceEnabled: smithy_client_1.expectBoolean,
        loggingLevel: smithy_client_1.expectString,
        metricsEnabled: smithy_client_1.expectBoolean,
        requireAuthorizationForCacheControl: smithy_client_1.expectBoolean,
        throttlingBurstLimit: smithy_client_1.expectInt32,
        throttlingRateLimit: smithy_client_1.limitedParseDouble,
        unauthorizedCacheControlHeaderStrategy: smithy_client_1.expectString,
    });
};
const de_RestApi = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        apiKeySource: smithy_client_1.expectString,
        binaryMediaTypes: smithy_client_1._json,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        disableExecuteApiEndpoint: smithy_client_1.expectBoolean,
        endpointConfiguration: smithy_client_1._json,
        id: smithy_client_1.expectString,
        minimumCompressionSize: smithy_client_1.expectInt32,
        name: smithy_client_1.expectString,
        policy: smithy_client_1.expectString,
        rootResourceId: smithy_client_1.expectString,
        tags: smithy_client_1._json,
        version: smithy_client_1.expectString,
        warnings: smithy_client_1._json,
    });
};
const de_Stage = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        accessLogSettings: smithy_client_1._json,
        cacheClusterEnabled: smithy_client_1.expectBoolean,
        cacheClusterSize: smithy_client_1.expectString,
        cacheClusterStatus: smithy_client_1.expectString,
        canarySettings: (_) => de_CanarySettings(_, context),
        clientCertificateId: smithy_client_1.expectString,
        createdDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        deploymentId: smithy_client_1.expectString,
        description: smithy_client_1.expectString,
        documentationVersion: smithy_client_1.expectString,
        lastUpdatedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        methodSettings: (_) => de_MapOfMethodSettings(_, context),
        stageName: smithy_client_1.expectString,
        tags: smithy_client_1._json,
        tracingEnabled: smithy_client_1.expectBoolean,
        variables: smithy_client_1._json,
        webAclArn: smithy_client_1.expectString,
    });
};
const de_ThrottleSettings = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        burstLimit: smithy_client_1.expectInt32,
        rateLimit: smithy_client_1.limitedParseDouble,
    });
};
const de_UsagePlan = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        apiStages: (_) => de_ListOfApiStage(_, context),
        description: smithy_client_1.expectString,
        id: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        productCode: smithy_client_1.expectString,
        quota: smithy_client_1._json,
        tags: smithy_client_1._json,
        throttle: (_) => de_ThrottleSettings(_, context),
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
