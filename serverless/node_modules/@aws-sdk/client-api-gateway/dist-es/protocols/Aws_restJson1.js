import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { _json, collectBody, convertMap, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, limitedParseDouble as __limitedParseDouble, map, parseEpochTimestamp as __parseEpochTimestamp, resolvedPath as __resolvedPath, serializeFloat as __serializeFloat, take, withBaseException, } from "@smithy/smithy-client";
import { APIGatewayServiceException as __BaseException } from "../models/APIGatewayServiceException";
import { BadRequestException, ConflictException, LimitExceededException, NotFoundException, ServiceUnavailableException, TooManyRequestsException, UnauthorizedException, } from "../models/models_0";
export const se_CreateApiKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/apikeys";
    let body;
    body = JSON.stringify(take(input, {
        customerId: [],
        description: [],
        enabled: [],
        generateDistinctId: [],
        name: [],
        stageKeys: (_) => _json(_),
        tags: (_) => _json(_),
        value: [],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/authorizers";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        authType: [],
        authorizerCredentials: [],
        authorizerResultTtlInSeconds: [],
        authorizerUri: [],
        identitySource: [],
        identityValidationExpression: [],
        name: [],
        providerARNs: (_) => _json(_),
        type: [],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateBasePathMappingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainnames/{domainName}/basepathmappings";
    resolvedPath = __resolvedPath(resolvedPath, input, "domainName", () => input.domainName, "{domainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        basePath: [],
        restApiId: [],
        stage: [],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateDeploymentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/deployments";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        cacheClusterEnabled: [],
        cacheClusterSize: [],
        canarySettings: (_) => se_DeploymentCanarySettings(_, context),
        description: [],
        stageDescription: [],
        stageName: [],
        tracingEnabled: [],
        variables: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateDocumentationPartCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/documentation/parts";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        location: (_) => _json(_),
        properties: [],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateDocumentationVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/documentation/versions";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        documentationVersion: [],
        stageName: [],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateDomainNameCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/domainnames";
    let body;
    body = JSON.stringify(take(input, {
        certificateArn: [],
        certificateBody: [],
        certificateChain: [],
        certificateName: [],
        certificatePrivateKey: [],
        domainName: [],
        endpointConfiguration: (_) => _json(_),
        mutualTlsAuthentication: (_) => _json(_),
        ownershipVerificationCertificateArn: [],
        regionalCertificateArn: [],
        regionalCertificateName: [],
        securityPolicy: [],
        tags: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateModelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/models";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        contentType: [],
        description: [],
        name: [],
        schema: [],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateRequestValidatorCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/requestvalidators";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        name: [],
        validateRequestBody: [],
        validateRequestParameters: [],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{parentId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "parentId", () => input.parentId, "{parentId}", false);
    let body;
    body = JSON.stringify(take(input, {
        pathPart: [],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateRestApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis";
    let body;
    body = JSON.stringify(take(input, {
        apiKeySource: [],
        binaryMediaTypes: (_) => _json(_),
        cloneFrom: [],
        description: [],
        disableExecuteApiEndpoint: [],
        endpointConfiguration: (_) => _json(_),
        minimumCompressionSize: [],
        name: [],
        policy: [],
        tags: (_) => _json(_),
        version: [],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateStageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/stages";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        cacheClusterEnabled: [],
        cacheClusterSize: [],
        canarySettings: (_) => se_CanarySettings(_, context),
        deploymentId: [],
        description: [],
        documentationVersion: [],
        stageName: [],
        tags: (_) => _json(_),
        tracingEnabled: [],
        variables: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateUsagePlanCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans";
    let body;
    body = JSON.stringify(take(input, {
        apiStages: (_) => se_ListOfApiStage(_, context),
        description: [],
        name: [],
        quota: (_) => _json(_),
        tags: (_) => _json(_),
        throttle: (_) => se_ThrottleSettings(_, context),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateUsagePlanKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans/{usagePlanId}/keys";
    resolvedPath = __resolvedPath(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    let body;
    body = JSON.stringify(take(input, {
        keyId: [],
        keyType: [],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateVpcLinkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/vpclinks";
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        name: [],
        tags: (_) => _json(_),
        targetArns: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteApiKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/apikeys/{apiKey}";
    resolvedPath = __resolvedPath(resolvedPath, input, "apiKey", () => input.apiKey, "{apiKey}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/authorizers/{authorizerId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "authorizerId", () => input.authorizerId, "{authorizerId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteBasePathMappingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainnames/{domainName}/basepathmappings/{basePath}";
    resolvedPath = __resolvedPath(resolvedPath, input, "domainName", () => input.domainName, "{domainName}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "basePath", () => input.basePath, "{basePath}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteClientCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/clientcertificates/{clientCertificateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "clientCertificateId", () => input.clientCertificateId, "{clientCertificateId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteDeploymentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/deployments/{deploymentId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "deploymentId", () => input.deploymentId, "{deploymentId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteDocumentationPartCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/documentation/parts/{documentationPartId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "documentationPartId", () => input.documentationPartId, "{documentationPartId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteDocumentationVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/documentation/versions/{documentationVersion}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "documentationVersion", () => input.documentationVersion, "{documentationVersion}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteDomainNameCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/domainnames/{domainName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "domainName", () => input.domainName, "{domainName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteGatewayResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/gatewayresponses/{responseType}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "responseType", () => input.responseType, "{responseType}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteIntegrationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteIntegrationResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteMethodCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteMethodResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteModelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/models/{modelName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "modelName", () => input.modelName, "{modelName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteRequestValidatorCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/requestvalidators/{requestValidatorId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "requestValidatorId", () => input.requestValidatorId, "{requestValidatorId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteRestApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteStageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/stages/{stageName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "stageName", () => input.stageName, "{stageName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteUsagePlanCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans/{usagePlanId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteUsagePlanKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans/{usagePlanId}/keys/{keyId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "keyId", () => input.keyId, "{keyId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteVpcLinkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/vpclinks/{vpcLinkId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "vpcLinkId", () => input.vpcLinkId, "{vpcLinkId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_FlushStageAuthorizersCacheCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/stages/{stageName}/cache/authorizers";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "stageName", () => input.stageName, "{stageName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_FlushStageCacheCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/stages/{stageName}/cache/data";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "stageName", () => input.stageName, "{stageName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GenerateClientCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/clientcertificates";
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        tags: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetAccountCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/account";
    let body;
    body = "";
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetApiKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/apikeys/{apiKey}";
    resolvedPath = __resolvedPath(resolvedPath, input, "apiKey", () => input.apiKey, "{apiKey}", false);
    const query = map({
        includeValue: [() => input.includeValue !== void 0, () => input.includeValue.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetApiKeysCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/apikeys";
    const query = map({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
        name: [, input.nameQuery],
        customerId: [, input.customerId],
        includeValues: [() => input.includeValues !== void 0, () => input.includeValues.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/authorizers/{authorizerId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "authorizerId", () => input.authorizerId, "{authorizerId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetAuthorizersCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/authorizers";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetBasePathMappingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainnames/{domainName}/basepathmappings/{basePath}";
    resolvedPath = __resolvedPath(resolvedPath, input, "domainName", () => input.domainName, "{domainName}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "basePath", () => input.basePath, "{basePath}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetBasePathMappingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainnames/{domainName}/basepathmappings";
    resolvedPath = __resolvedPath(resolvedPath, input, "domainName", () => input.domainName, "{domainName}", false);
    const query = map({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetClientCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/clientcertificates/{clientCertificateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "clientCertificateId", () => input.clientCertificateId, "{clientCertificateId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetClientCertificatesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/clientcertificates";
    const query = map({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetDeploymentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/deployments/{deploymentId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "deploymentId", () => input.deploymentId, "{deploymentId}", false);
    const query = map({
        embed: [() => input.embed !== void 0, () => (input.embed || []).map((_entry) => _entry)],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetDeploymentsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/deployments";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetDocumentationPartCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/documentation/parts/{documentationPartId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "documentationPartId", () => input.documentationPartId, "{documentationPartId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetDocumentationPartsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/documentation/parts";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        type: [, input.type],
        name: [, input.nameQuery],
        path: [, input.path],
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
        locationStatus: [, input.locationStatus],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetDocumentationVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/documentation/versions/{documentationVersion}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "documentationVersion", () => input.documentationVersion, "{documentationVersion}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetDocumentationVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/documentation/versions";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetDomainNameCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/domainnames/{domainName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "domainName", () => input.domainName, "{domainName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetDomainNamesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/domainnames";
    const query = map({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetExportCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        accept: input.accepts,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/stages/{stageName}/exports/{exportType}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "stageName", () => input.stageName, "{stageName}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "exportType", () => input.exportType, "{exportType}", false);
    const query = map({
        ...convertMap(input.parameters),
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetGatewayResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/gatewayresponses/{responseType}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "responseType", () => input.responseType, "{responseType}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetGatewayResponsesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/gatewayresponses";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetIntegrationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetIntegrationResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetMethodCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetMethodResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetModelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/models/{modelName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "modelName", () => input.modelName, "{modelName}", false);
    const query = map({
        flatten: [() => input.flatten !== void 0, () => input.flatten.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetModelsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/models";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetModelTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/models/{modelName}/default_template";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "modelName", () => input.modelName, "{modelName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetRequestValidatorCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/requestvalidators/{requestValidatorId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "requestValidatorId", () => input.requestValidatorId, "{requestValidatorId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetRequestValidatorsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/requestvalidators";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    const query = map({
        embed: [() => input.embed !== void 0, () => (input.embed || []).map((_entry) => _entry)],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetResourcesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/resources";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
        embed: [() => input.embed !== void 0, () => (input.embed || []).map((_entry) => _entry)],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetRestApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetRestApisCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis";
    const query = map({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetSdkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/stages/{stageName}/sdks/{sdkType}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "stageName", () => input.stageName, "{stageName}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "sdkType", () => input.sdkType, "{sdkType}", false);
    const query = map({
        ...convertMap(input.parameters),
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetSdkTypeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/sdktypes/{id}";
    resolvedPath = __resolvedPath(resolvedPath, input, "id", () => input.id, "{id}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetSdkTypesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/sdktypes";
    const query = map({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetStageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/stages/{stageName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "stageName", () => input.stageName, "{stageName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetStagesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/stages";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        deploymentId: [, input.deploymentId],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetTagsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/tags/{resourceArn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceArn", () => input.resourceArn, "{resourceArn}", false);
    const query = map({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetUsageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans/{usagePlanId}/usage";
    resolvedPath = __resolvedPath(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    const query = map({
        keyId: [, input.keyId],
        startDate: [, __expectNonNull(input.startDate, `startDate`)],
        endDate: [, __expectNonNull(input.endDate, `endDate`)],
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetUsagePlanCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans/{usagePlanId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetUsagePlanKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans/{usagePlanId}/keys/{keyId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "keyId", () => input.keyId, "{keyId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetUsagePlanKeysCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans/{usagePlanId}/keys";
    resolvedPath = __resolvedPath(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    const query = map({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
        name: [, input.nameQuery],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetUsagePlansCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans";
    const query = map({
        position: [, input.position],
        keyId: [, input.keyId],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetVpcLinkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/vpclinks/{vpcLinkId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "vpcLinkId", () => input.vpcLinkId, "{vpcLinkId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetVpcLinksCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/vpclinks";
    const query = map({
        position: [, input.position],
        limit: [() => input.limit !== void 0, () => input.limit.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ImportApiKeysCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/octet-stream",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/apikeys";
    const query = map({
        mode: [, "import"],
        format: [, __expectNonNull(input.format, `format`)],
        failonwarnings: [() => input.failOnWarnings !== void 0, () => input.failOnWarnings.toString()],
    });
    let body;
    if (input.body !== undefined) {
        body = input.body;
    }
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ImportDocumentationPartsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/octet-stream",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/documentation/parts";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        mode: [, input.mode],
        failonwarnings: [() => input.failOnWarnings !== void 0, () => input.failOnWarnings.toString()],
    });
    let body;
    if (input.body !== undefined) {
        body = input.body;
    }
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ImportRestApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/octet-stream",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis";
    const query = map({
        mode: [, "import"],
        ...convertMap(input.parameters),
        failonwarnings: [() => input.failOnWarnings !== void 0, () => input.failOnWarnings.toString()],
    });
    let body;
    if (input.body !== undefined) {
        body = input.body;
    }
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_PutGatewayResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/gatewayresponses/{responseType}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "responseType", () => input.responseType, "{responseType}", false);
    let body;
    body = JSON.stringify(take(input, {
        responseParameters: (_) => _json(_),
        responseTemplates: (_) => _json(_),
        statusCode: [],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutIntegrationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    body = JSON.stringify(take(input, {
        cacheKeyParameters: (_) => _json(_),
        cacheNamespace: [],
        connectionId: [],
        connectionType: [],
        contentHandling: [],
        credentials: [],
        httpMethod: [, , `integrationHttpMethod`],
        passthroughBehavior: [],
        requestParameters: (_) => _json(_),
        requestTemplates: (_) => _json(_),
        timeoutInMillis: [],
        tlsConfig: (_) => _json(_),
        type: [],
        uri: [],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutIntegrationResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    body = JSON.stringify(take(input, {
        contentHandling: [],
        responseParameters: (_) => _json(_),
        responseTemplates: (_) => _json(_),
        selectionPattern: [],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutMethodCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    body = JSON.stringify(take(input, {
        apiKeyRequired: [],
        authorizationScopes: (_) => _json(_),
        authorizationType: [],
        authorizerId: [],
        operationName: [],
        requestModels: (_) => _json(_),
        requestParameters: (_) => _json(_),
        requestValidatorId: [],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutMethodResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    body = JSON.stringify(take(input, {
        responseModels: (_) => _json(_),
        responseParameters: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutRestApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/octet-stream",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        ...convertMap(input.parameters),
        mode: [, input.mode],
        failonwarnings: [() => input.failOnWarnings !== void 0, () => input.failOnWarnings.toString()],
    });
    let body;
    if (input.body !== undefined) {
        body = input.body;
    }
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_TagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/tags/{resourceArn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceArn", () => input.resourceArn, "{resourceArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        tags: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_TestInvokeAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/authorizers/{authorizerId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "authorizerId", () => input.authorizerId, "{authorizerId}", false);
    let body;
    body = JSON.stringify(take(input, {
        additionalContext: (_) => _json(_),
        body: [],
        headers: (_) => _json(_),
        multiValueHeaders: (_) => _json(_),
        pathWithQueryString: [],
        stageVariables: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_TestInvokeMethodCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    body = JSON.stringify(take(input, {
        body: [],
        clientCertificateId: [],
        headers: (_) => _json(_),
        multiValueHeaders: (_) => _json(_),
        pathWithQueryString: [],
        stageVariables: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UntagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/tags/{resourceArn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceArn", () => input.resourceArn, "{resourceArn}", false);
    const query = map({
        tagKeys: [
            __expectNonNull(input.tagKeys, `tagKeys`) != null,
            () => (input.tagKeys || []).map((_entry) => _entry),
        ],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_UpdateAccountCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/account";
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateApiKeyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/apikeys/{apiKey}";
    resolvedPath = __resolvedPath(resolvedPath, input, "apiKey", () => input.apiKey, "{apiKey}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/authorizers/{authorizerId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "authorizerId", () => input.authorizerId, "{authorizerId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateBasePathMappingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainnames/{domainName}/basepathmappings/{basePath}";
    resolvedPath = __resolvedPath(resolvedPath, input, "domainName", () => input.domainName, "{domainName}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "basePath", () => input.basePath, "{basePath}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateClientCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/clientcertificates/{clientCertificateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "clientCertificateId", () => input.clientCertificateId, "{clientCertificateId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateDeploymentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/deployments/{deploymentId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "deploymentId", () => input.deploymentId, "{deploymentId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateDocumentationPartCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/documentation/parts/{documentationPartId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "documentationPartId", () => input.documentationPartId, "{documentationPartId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateDocumentationVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/documentation/versions/{documentationVersion}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "documentationVersion", () => input.documentationVersion, "{documentationVersion}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateDomainNameCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/domainnames/{domainName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "domainName", () => input.domainName, "{domainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateGatewayResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/gatewayresponses/{responseType}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "responseType", () => input.responseType, "{responseType}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateIntegrationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateIntegrationResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateMethodCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateMethodResponseCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "httpMethod", () => input.httpMethod, "{httpMethod}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateModelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/models/{modelName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "modelName", () => input.modelName, "{modelName}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateRequestValidatorCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/requestvalidators/{requestValidatorId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "requestValidatorId", () => input.requestValidatorId, "{requestValidatorId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/restapis/{restApiId}/resources/{resourceId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "resourceId", () => input.resourceId, "{resourceId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateRestApiCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateStageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/restapis/{restApiId}/stages/{stageName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "restApiId", () => input.restApiId, "{restApiId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "stageName", () => input.stageName, "{stageName}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateUsageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/usageplans/{usagePlanId}/keys/{keyId}/usage";
    resolvedPath = __resolvedPath(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "keyId", () => input.keyId, "{keyId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateUsagePlanCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/usageplans/{usagePlanId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateVpcLinkCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/vpclinks/{vpcLinkId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "vpcLinkId", () => input.vpcLinkId, "{vpcLinkId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const de_CreateApiKeyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateApiKeyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        customerId: __expectString,
        description: __expectString,
        enabled: __expectBoolean,
        id: __expectString,
        lastUpdatedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
        stageKeys: _json,
        tags: _json,
        value: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateApiKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authType: __expectString,
        authorizerCredentials: __expectString,
        authorizerResultTtlInSeconds: __expectInt32,
        authorizerUri: __expectString,
        id: __expectString,
        identitySource: __expectString,
        identityValidationExpression: __expectString,
        name: __expectString,
        providerARNs: _json,
        type: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateBasePathMappingCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateBasePathMappingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        basePath: __expectString,
        restApiId: __expectString,
        stage: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateBasePathMappingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateDeploymentCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiSummary: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        id: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.apigateway#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateDocumentationPartCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateDocumentationPartCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        location: _json,
        properties: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateDocumentationPartCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateDocumentationVersionCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateDocumentationVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        version: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateDocumentationVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateDomainNameCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificateArn: __expectString,
        certificateName: __expectString,
        certificateUploadDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        distributionDomainName: __expectString,
        distributionHostedZoneId: __expectString,
        domainName: __expectString,
        domainNameStatus: __expectString,
        domainNameStatusMessage: __expectString,
        endpointConfiguration: _json,
        mutualTlsAuthentication: _json,
        ownershipVerificationCertificateArn: __expectString,
        regionalCertificateArn: __expectString,
        regionalCertificateName: __expectString,
        regionalDomainName: __expectString,
        regionalHostedZoneId: __expectString,
        securityPolicy: __expectString,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateDomainNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateModelCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateModelCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        contentType: __expectString,
        description: __expectString,
        id: __expectString,
        name: __expectString,
        schema: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateRequestValidatorCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateRequestValidatorCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        name: __expectString,
        validateRequestBody: __expectBoolean,
        validateRequestParameters: __expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateRequestValidatorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateResourceCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        parentId: __expectString,
        path: __expectString,
        pathPart: __expectString,
        resourceMethods: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateRestApiCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateRestApiCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeySource: __expectString,
        binaryMediaTypes: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        disableExecuteApiEndpoint: __expectBoolean,
        endpointConfiguration: _json,
        id: __expectString,
        minimumCompressionSize: __expectInt32,
        name: __expectString,
        policy: __expectString,
        rootResourceId: __expectString,
        tags: _json,
        version: __expectString,
        warnings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateRestApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateStageCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateStageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        accessLogSettings: _json,
        cacheClusterEnabled: __expectBoolean,
        cacheClusterSize: __expectString,
        cacheClusterStatus: __expectString,
        canarySettings: (_) => de_CanarySettings(_, context),
        clientCertificateId: __expectString,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        deploymentId: __expectString,
        description: __expectString,
        documentationVersion: __expectString,
        lastUpdatedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        methodSettings: (_) => de_MapOfMethodSettings(_, context),
        stageName: __expectString,
        tags: _json,
        tracingEnabled: __expectBoolean,
        variables: _json,
        webAclArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateStageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateUsagePlanCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateUsagePlanCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiStages: (_) => de_ListOfApiStage(_, context),
        description: __expectString,
        id: __expectString,
        name: __expectString,
        productCode: __expectString,
        quota: _json,
        tags: _json,
        throttle: (_) => de_ThrottleSettings(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateUsagePlanCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateUsagePlanKeyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateUsagePlanKeyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        name: __expectString,
        type: __expectString,
        value: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateUsagePlanKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CreateVpcLinkCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        description: __expectString,
        id: __expectString,
        name: __expectString,
        status: __expectString,
        statusMessage: __expectString,
        tags: _json,
        targetArns: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateVpcLinkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteApiKeyCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteApiKeyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteApiKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteBasePathMappingCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteBasePathMappingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteBasePathMappingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteClientCertificateCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteClientCertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteClientCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteDeploymentCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteDocumentationPartCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteDocumentationPartCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteDocumentationPartCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteDocumentationVersionCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteDocumentationVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteDocumentationVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteDomainNameCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteDomainNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteGatewayResponseCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteGatewayResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteGatewayResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteIntegrationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteIntegrationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteIntegrationResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteIntegrationResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteMethodCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteMethodCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteMethodCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteMethodResponseCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteMethodResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteMethodResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteModelCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteModelCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteRequestValidatorCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteRequestValidatorCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteRequestValidatorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteResourceCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteRestApiCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteRestApiCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteRestApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteStageCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteStageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteStageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteUsagePlanCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteUsagePlanCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteUsagePlanCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteUsagePlanKeyCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteUsagePlanKeyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteUsagePlanKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_DeleteVpcLinkCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteVpcLinkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_FlushStageAuthorizersCacheCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_FlushStageAuthorizersCacheCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_FlushStageAuthorizersCacheCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_FlushStageCacheCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_FlushStageCacheCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_FlushStageCacheCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GenerateClientCertificateCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_GenerateClientCertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        clientCertificateId: __expectString,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        expirationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        pemEncodedCertificate: __expectString,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GenerateClientCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetAccountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAccountCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeyVersion: __expectString,
        cloudwatchRoleArn: __expectString,
        features: _json,
        throttleSettings: (_) => de_ThrottleSettings(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetAccountCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetApiKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetApiKeyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        customerId: __expectString,
        description: __expectString,
        enabled: __expectBoolean,
        id: __expectString,
        lastUpdatedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
        stageKeys: _json,
        tags: _json,
        value: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetApiKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetApiKeysCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetApiKeysCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, (_) => de_ListOfApiKey(_, context), `item`],
        position: __expectString,
        warnings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetApiKeysCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authType: __expectString,
        authorizerCredentials: __expectString,
        authorizerResultTtlInSeconds: __expectInt32,
        authorizerUri: __expectString,
        id: __expectString,
        identitySource: __expectString,
        identityValidationExpression: __expectString,
        name: __expectString,
        providerARNs: _json,
        type: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetAuthorizersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAuthorizersCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetAuthorizersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetBasePathMappingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBasePathMappingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        basePath: __expectString,
        restApiId: __expectString,
        stage: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetBasePathMappingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetBasePathMappingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBasePathMappingsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetBasePathMappingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetClientCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetClientCertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        clientCertificateId: __expectString,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        expirationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        pemEncodedCertificate: __expectString,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetClientCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetClientCertificatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetClientCertificatesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, (_) => de_ListOfClientCertificate(_, context), `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetClientCertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDeploymentCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiSummary: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        id: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.apigateway#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetDeploymentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDeploymentsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, (_) => de_ListOfDeployment(_, context), `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetDeploymentsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.apigateway#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetDocumentationPartCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDocumentationPartCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        location: _json,
        properties: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetDocumentationPartCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetDocumentationPartsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDocumentationPartsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetDocumentationPartsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetDocumentationVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDocumentationVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        version: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetDocumentationVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetDocumentationVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDocumentationVersionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, (_) => de_ListOfDocumentationVersion(_, context), `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetDocumentationVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDomainNameCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificateArn: __expectString,
        certificateName: __expectString,
        certificateUploadDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        distributionDomainName: __expectString,
        distributionHostedZoneId: __expectString,
        domainName: __expectString,
        domainNameStatus: __expectString,
        domainNameStatusMessage: __expectString,
        endpointConfiguration: _json,
        mutualTlsAuthentication: _json,
        ownershipVerificationCertificateArn: __expectString,
        regionalCertificateArn: __expectString,
        regionalCertificateName: __expectString,
        regionalDomainName: __expectString,
        regionalHostedZoneId: __expectString,
        securityPolicy: __expectString,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetDomainNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetDomainNamesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDomainNamesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, (_) => de_ListOfDomainName(_, context), `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetDomainNamesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetExportCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetExportCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        contentType: [, output.headers["content-type"]],
        contentDisposition: [, output.headers["content-disposition"]],
    });
    const data = await collectBody(output.body, context);
    contents.body = data;
    return contents;
};
const de_GetExportCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetGatewayResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetGatewayResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        defaultResponse: __expectBoolean,
        responseParameters: _json,
        responseTemplates: _json,
        responseType: __expectString,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetGatewayResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetGatewayResponsesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetGatewayResponsesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetGatewayResponsesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetIntegrationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        cacheKeyParameters: _json,
        cacheNamespace: __expectString,
        connectionId: __expectString,
        connectionType: __expectString,
        contentHandling: __expectString,
        credentials: __expectString,
        httpMethod: __expectString,
        integrationResponses: _json,
        passthroughBehavior: __expectString,
        requestParameters: _json,
        requestTemplates: _json,
        timeoutInMillis: __expectInt32,
        tlsConfig: _json,
        type: __expectString,
        uri: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetIntegrationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetIntegrationResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        contentHandling: __expectString,
        responseParameters: _json,
        responseTemplates: _json,
        selectionPattern: __expectString,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetIntegrationResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetMethodCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetMethodCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeyRequired: __expectBoolean,
        authorizationScopes: _json,
        authorizationType: __expectString,
        authorizerId: __expectString,
        httpMethod: __expectString,
        methodIntegration: _json,
        methodResponses: _json,
        operationName: __expectString,
        requestModels: _json,
        requestParameters: _json,
        requestValidatorId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetMethodCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetMethodResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetMethodResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        responseModels: _json,
        responseParameters: _json,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetMethodResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetModelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetModelCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        contentType: __expectString,
        description: __expectString,
        id: __expectString,
        name: __expectString,
        schema: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetModelsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetModelsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetModelsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetModelTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetModelTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        value: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetModelTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetRequestValidatorCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRequestValidatorCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        name: __expectString,
        validateRequestBody: __expectBoolean,
        validateRequestParameters: __expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetRequestValidatorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetRequestValidatorsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRequestValidatorsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetRequestValidatorsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        parentId: __expectString,
        path: __expectString,
        pathPart: __expectString,
        resourceMethods: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetResourcesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetResourcesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetResourcesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetRestApiCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRestApiCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeySource: __expectString,
        binaryMediaTypes: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        disableExecuteApiEndpoint: __expectBoolean,
        endpointConfiguration: _json,
        id: __expectString,
        minimumCompressionSize: __expectInt32,
        name: __expectString,
        policy: __expectString,
        rootResourceId: __expectString,
        tags: _json,
        version: __expectString,
        warnings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetRestApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetRestApisCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRestApisCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, (_) => de_ListOfRestApi(_, context), `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetRestApisCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetSdkCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetSdkCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        contentType: [, output.headers["content-type"]],
        contentDisposition: [, output.headers["content-disposition"]],
    });
    const data = await collectBody(output.body, context);
    contents.body = data;
    return contents;
};
const de_GetSdkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetSdkTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetSdkTypeCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        configurationProperties: _json,
        description: __expectString,
        friendlyName: __expectString,
        id: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetSdkTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetSdkTypesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetSdkTypesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetSdkTypesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetStageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetStageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        accessLogSettings: _json,
        cacheClusterEnabled: __expectBoolean,
        cacheClusterSize: __expectString,
        cacheClusterStatus: __expectString,
        canarySettings: (_) => de_CanarySettings(_, context),
        clientCertificateId: __expectString,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        deploymentId: __expectString,
        description: __expectString,
        documentationVersion: __expectString,
        lastUpdatedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        methodSettings: (_) => de_MapOfMethodSettings(_, context),
        stageName: __expectString,
        tags: _json,
        tracingEnabled: __expectBoolean,
        variables: _json,
        webAclArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetStageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetStagesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetStagesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        item: (_) => de_ListOfStage(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetStagesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetTagsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetTagsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetUsageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetUsageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        endDate: __expectString,
        items: [, _json, `values`],
        position: __expectString,
        startDate: __expectString,
        usagePlanId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetUsageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetUsagePlanCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetUsagePlanCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiStages: (_) => de_ListOfApiStage(_, context),
        description: __expectString,
        id: __expectString,
        name: __expectString,
        productCode: __expectString,
        quota: _json,
        tags: _json,
        throttle: (_) => de_ThrottleSettings(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetUsagePlanCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetUsagePlanKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetUsagePlanKeyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        name: __expectString,
        type: __expectString,
        value: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetUsagePlanKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetUsagePlanKeysCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetUsagePlanKeysCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetUsagePlanKeysCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetUsagePlansCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetUsagePlansCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, (_) => de_ListOfUsagePlan(_, context), `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetUsagePlansCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetVpcLinkCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        description: __expectString,
        id: __expectString,
        name: __expectString,
        status: __expectString,
        statusMessage: __expectString,
        tags: _json,
        targetArns: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetVpcLinkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetVpcLinksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetVpcLinksCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetVpcLinksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ImportApiKeysCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_ImportApiKeysCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ids: _json,
        warnings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ImportApiKeysCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ImportDocumentationPartsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ImportDocumentationPartsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ids: _json,
        warnings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ImportDocumentationPartsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ImportRestApiCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_ImportRestApiCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeySource: __expectString,
        binaryMediaTypes: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        disableExecuteApiEndpoint: __expectBoolean,
        endpointConfiguration: _json,
        id: __expectString,
        minimumCompressionSize: __expectInt32,
        name: __expectString,
        policy: __expectString,
        rootResourceId: __expectString,
        tags: _json,
        version: __expectString,
        warnings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ImportRestApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_PutGatewayResponseCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_PutGatewayResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        defaultResponse: __expectBoolean,
        responseParameters: _json,
        responseTemplates: _json,
        responseType: __expectString,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_PutGatewayResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_PutIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_PutIntegrationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        cacheKeyParameters: _json,
        cacheNamespace: __expectString,
        connectionId: __expectString,
        connectionType: __expectString,
        contentHandling: __expectString,
        credentials: __expectString,
        httpMethod: __expectString,
        integrationResponses: _json,
        passthroughBehavior: __expectString,
        requestParameters: _json,
        requestTemplates: _json,
        timeoutInMillis: __expectInt32,
        tlsConfig: _json,
        type: __expectString,
        uri: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_PutIntegrationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_PutIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_PutIntegrationResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        contentHandling: __expectString,
        responseParameters: _json,
        responseTemplates: _json,
        selectionPattern: __expectString,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_PutIntegrationResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_PutMethodCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_PutMethodCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeyRequired: __expectBoolean,
        authorizationScopes: _json,
        authorizationType: __expectString,
        authorizerId: __expectString,
        httpMethod: __expectString,
        methodIntegration: _json,
        methodResponses: _json,
        operationName: __expectString,
        requestModels: _json,
        requestParameters: _json,
        requestValidatorId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_PutMethodCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_PutMethodResponseCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_PutMethodResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        responseModels: _json,
        responseParameters: _json,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_PutMethodResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_PutRestApiCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutRestApiCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeySource: __expectString,
        binaryMediaTypes: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        disableExecuteApiEndpoint: __expectBoolean,
        endpointConfiguration: _json,
        id: __expectString,
        minimumCompressionSize: __expectInt32,
        name: __expectString,
        policy: __expectString,
        rootResourceId: __expectString,
        tags: _json,
        version: __expectString,
        warnings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_PutRestApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_TestInvokeAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_TestInvokeAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authorization: _json,
        claims: _json,
        clientStatus: __expectInt32,
        latency: __expectLong,
        log: __expectString,
        policy: __expectString,
        principalId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_TestInvokeAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_TestInvokeMethodCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_TestInvokeMethodCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        body: __expectString,
        headers: _json,
        latency: __expectLong,
        log: __expectString,
        multiValueHeaders: _json,
        status: __expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_TestInvokeMethodCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateAccountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateAccountCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeyVersion: __expectString,
        cloudwatchRoleArn: __expectString,
        features: _json,
        throttleSettings: (_) => de_ThrottleSettings(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateAccountCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateApiKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateApiKeyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        customerId: __expectString,
        description: __expectString,
        enabled: __expectBoolean,
        id: __expectString,
        lastUpdatedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
        stageKeys: _json,
        tags: _json,
        value: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateApiKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authType: __expectString,
        authorizerCredentials: __expectString,
        authorizerResultTtlInSeconds: __expectInt32,
        authorizerUri: __expectString,
        id: __expectString,
        identitySource: __expectString,
        identityValidationExpression: __expectString,
        name: __expectString,
        providerARNs: _json,
        type: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateBasePathMappingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateBasePathMappingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        basePath: __expectString,
        restApiId: __expectString,
        stage: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateBasePathMappingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateClientCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateClientCertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        clientCertificateId: __expectString,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        expirationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        pemEncodedCertificate: __expectString,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateClientCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDeploymentCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiSummary: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        id: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.apigateway#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateDocumentationPartCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDocumentationPartCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        location: _json,
        properties: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateDocumentationPartCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateDocumentationVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDocumentationVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        version: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateDocumentationVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDomainNameCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificateArn: __expectString,
        certificateName: __expectString,
        certificateUploadDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        distributionDomainName: __expectString,
        distributionHostedZoneId: __expectString,
        domainName: __expectString,
        domainNameStatus: __expectString,
        domainNameStatusMessage: __expectString,
        endpointConfiguration: _json,
        mutualTlsAuthentication: _json,
        ownershipVerificationCertificateArn: __expectString,
        regionalCertificateArn: __expectString,
        regionalCertificateName: __expectString,
        regionalDomainName: __expectString,
        regionalHostedZoneId: __expectString,
        securityPolicy: __expectString,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateDomainNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateGatewayResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateGatewayResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        defaultResponse: __expectBoolean,
        responseParameters: _json,
        responseTemplates: _json,
        responseType: __expectString,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateGatewayResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateIntegrationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        cacheKeyParameters: _json,
        cacheNamespace: __expectString,
        connectionId: __expectString,
        connectionType: __expectString,
        contentHandling: __expectString,
        credentials: __expectString,
        httpMethod: __expectString,
        integrationResponses: _json,
        passthroughBehavior: __expectString,
        requestParameters: _json,
        requestTemplates: _json,
        timeoutInMillis: __expectInt32,
        tlsConfig: _json,
        type: __expectString,
        uri: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateIntegrationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateIntegrationResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        contentHandling: __expectString,
        responseParameters: _json,
        responseTemplates: _json,
        selectionPattern: __expectString,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateIntegrationResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateMethodCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateMethodCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeyRequired: __expectBoolean,
        authorizationScopes: _json,
        authorizationType: __expectString,
        authorizerId: __expectString,
        httpMethod: __expectString,
        methodIntegration: _json,
        methodResponses: _json,
        operationName: __expectString,
        requestModels: _json,
        requestParameters: _json,
        requestValidatorId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateMethodCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateMethodResponseCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_UpdateMethodResponseCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        responseModels: _json,
        responseParameters: _json,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateMethodResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateModelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateModelCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        contentType: __expectString,
        description: __expectString,
        id: __expectString,
        name: __expectString,
        schema: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateModelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateRequestValidatorCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateRequestValidatorCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        name: __expectString,
        validateRequestBody: __expectBoolean,
        validateRequestParameters: __expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateRequestValidatorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        parentId: __expectString,
        path: __expectString,
        pathPart: __expectString,
        resourceMethods: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateRestApiCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateRestApiCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeySource: __expectString,
        binaryMediaTypes: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        disableExecuteApiEndpoint: __expectBoolean,
        endpointConfiguration: _json,
        id: __expectString,
        minimumCompressionSize: __expectInt32,
        name: __expectString,
        policy: __expectString,
        rootResourceId: __expectString,
        tags: _json,
        version: __expectString,
        warnings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateRestApiCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateStageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateStageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        accessLogSettings: _json,
        cacheClusterEnabled: __expectBoolean,
        cacheClusterSize: __expectString,
        cacheClusterStatus: __expectString,
        canarySettings: (_) => de_CanarySettings(_, context),
        clientCertificateId: __expectString,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        deploymentId: __expectString,
        description: __expectString,
        documentationVersion: __expectString,
        lastUpdatedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        methodSettings: (_) => de_MapOfMethodSettings(_, context),
        stageName: __expectString,
        tags: _json,
        tracingEnabled: __expectBoolean,
        variables: _json,
        webAclArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateStageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateUsageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateUsageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        endDate: __expectString,
        items: [, _json, `values`],
        position: __expectString,
        startDate: __expectString,
        usagePlanId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateUsageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateUsagePlanCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateUsagePlanCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiStages: (_) => de_ListOfApiStage(_, context),
        description: __expectString,
        id: __expectString,
        name: __expectString,
        productCode: __expectString,
        quota: _json,
        tags: _json,
        throttle: (_) => de_ThrottleSettings(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateUsagePlanCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateVpcLinkCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        description: __expectString,
        id: __expectString,
        name: __expectString,
        status: __expectString,
        statusMessage: __expectString,
        tags: _json,
        targetArns: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateVpcLinkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_BadRequestExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new BadRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({
        retryAfterSeconds: [, parsedOutput.headers["retry-after"]],
    });
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_NotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new NotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceUnavailableExceptionRes = async (parsedOutput, context) => {
    const contents = map({
        retryAfterSeconds: [, parsedOutput.headers["retry-after"]],
    });
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
    const contents = map({
        retryAfterSeconds: [, parsedOutput.headers["retry-after"]],
    });
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new UnauthorizedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_ApiStage = (input, context) => {
    return take(input, {
        apiId: [],
        stage: [],
        throttle: (_) => se_MapOfApiStageThrottleSettings(_, context),
    });
};
const se_CanarySettings = (input, context) => {
    return take(input, {
        deploymentId: [],
        percentTraffic: __serializeFloat,
        stageVariableOverrides: _json,
        useStageCache: [],
    });
};
const se_DeploymentCanarySettings = (input, context) => {
    return take(input, {
        percentTraffic: __serializeFloat,
        stageVariableOverrides: _json,
        useStageCache: [],
    });
};
const se_ListOfApiStage = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ApiStage(entry, context);
    });
};
const se_MapOfApiStageThrottleSettings = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_ThrottleSettings(value, context);
        return acc;
    }, {});
};
const se_ThrottleSettings = (input, context) => {
    return take(input, {
        burstLimit: [],
        rateLimit: __serializeFloat,
    });
};
const de_ApiKey = (output, context) => {
    return take(output, {
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        customerId: __expectString,
        description: __expectString,
        enabled: __expectBoolean,
        id: __expectString,
        lastUpdatedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
        stageKeys: _json,
        tags: _json,
        value: __expectString,
    });
};
const de_ApiStage = (output, context) => {
    return take(output, {
        apiId: __expectString,
        stage: __expectString,
        throttle: (_) => de_MapOfApiStageThrottleSettings(_, context),
    });
};
const de_CanarySettings = (output, context) => {
    return take(output, {
        deploymentId: __expectString,
        percentTraffic: __limitedParseDouble,
        stageVariableOverrides: _json,
        useStageCache: __expectBoolean,
    });
};
const de_ClientCertificate = (output, context) => {
    return take(output, {
        clientCertificateId: __expectString,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        expirationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        pemEncodedCertificate: __expectString,
        tags: _json,
    });
};
const de_Deployment = (output, context) => {
    return take(output, {
        apiSummary: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        id: __expectString,
    });
};
const de_DocumentationVersion = (output, context) => {
    return take(output, {
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        version: __expectString,
    });
};
const de_DomainName = (output, context) => {
    return take(output, {
        certificateArn: __expectString,
        certificateName: __expectString,
        certificateUploadDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        distributionDomainName: __expectString,
        distributionHostedZoneId: __expectString,
        domainName: __expectString,
        domainNameStatus: __expectString,
        domainNameStatusMessage: __expectString,
        endpointConfiguration: _json,
        mutualTlsAuthentication: _json,
        ownershipVerificationCertificateArn: __expectString,
        regionalCertificateArn: __expectString,
        regionalCertificateName: __expectString,
        regionalDomainName: __expectString,
        regionalHostedZoneId: __expectString,
        securityPolicy: __expectString,
        tags: _json,
    });
};
const de_ListOfApiKey = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ApiKey(entry, context);
    });
    return retVal;
};
const de_ListOfApiStage = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ApiStage(entry, context);
    });
    return retVal;
};
const de_ListOfClientCertificate = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClientCertificate(entry, context);
    });
    return retVal;
};
const de_ListOfDeployment = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Deployment(entry, context);
    });
    return retVal;
};
const de_ListOfDocumentationVersion = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DocumentationVersion(entry, context);
    });
    return retVal;
};
const de_ListOfDomainName = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DomainName(entry, context);
    });
    return retVal;
};
const de_ListOfRestApi = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RestApi(entry, context);
    });
    return retVal;
};
const de_ListOfStage = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Stage(entry, context);
    });
    return retVal;
};
const de_ListOfUsagePlan = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UsagePlan(entry, context);
    });
    return retVal;
};
const de_MapOfApiStageThrottleSettings = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_ThrottleSettings(value, context);
        return acc;
    }, {});
};
const de_MapOfMethodSettings = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_MethodSetting(value, context);
        return acc;
    }, {});
};
const de_MethodSetting = (output, context) => {
    return take(output, {
        cacheDataEncrypted: __expectBoolean,
        cacheTtlInSeconds: __expectInt32,
        cachingEnabled: __expectBoolean,
        dataTraceEnabled: __expectBoolean,
        loggingLevel: __expectString,
        metricsEnabled: __expectBoolean,
        requireAuthorizationForCacheControl: __expectBoolean,
        throttlingBurstLimit: __expectInt32,
        throttlingRateLimit: __limitedParseDouble,
        unauthorizedCacheControlHeaderStrategy: __expectString,
    });
};
const de_RestApi = (output, context) => {
    return take(output, {
        apiKeySource: __expectString,
        binaryMediaTypes: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        disableExecuteApiEndpoint: __expectBoolean,
        endpointConfiguration: _json,
        id: __expectString,
        minimumCompressionSize: __expectInt32,
        name: __expectString,
        policy: __expectString,
        rootResourceId: __expectString,
        tags: _json,
        version: __expectString,
        warnings: _json,
    });
};
const de_Stage = (output, context) => {
    return take(output, {
        accessLogSettings: _json,
        cacheClusterEnabled: __expectBoolean,
        cacheClusterSize: __expectString,
        cacheClusterStatus: __expectString,
        canarySettings: (_) => de_CanarySettings(_, context),
        clientCertificateId: __expectString,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        deploymentId: __expectString,
        description: __expectString,
        documentationVersion: __expectString,
        lastUpdatedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        methodSettings: (_) => de_MapOfMethodSettings(_, context),
        stageName: __expectString,
        tags: _json,
        tracingEnabled: __expectBoolean,
        variables: _json,
        webAclArn: __expectString,
    });
};
const de_ThrottleSettings = (output, context) => {
    return take(output, {
        burstLimit: __expectInt32,
        rateLimit: __limitedParseDouble,
    });
};
const de_UsagePlan = (output, context) => {
    return take(output, {
        apiStages: (_) => de_ListOfApiStage(_, context),
        description: __expectString,
        id: __expectString,
        name: __expectString,
        productCode: __expectString,
        quota: _json,
        tags: _json,
        throttle: (_) => de_ThrottleSettings(_, context),
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
