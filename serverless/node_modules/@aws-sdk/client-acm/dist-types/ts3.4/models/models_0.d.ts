import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { ACMServiceException as __BaseException } from "./ACMServiceException";
export declare class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<AccessDeniedException, __BaseException>
  );
}
export interface Tag {
  Key: string | undefined;
  Value?: string;
}
export interface AddTagsToCertificateRequest {
  CertificateArn: string | undefined;
  Tags: Tag[] | undefined;
}
export declare class InvalidArnException extends __BaseException {
  readonly name: "InvalidArnException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidArnException, __BaseException>
  );
}
export declare class InvalidParameterException extends __BaseException {
  readonly name: "InvalidParameterException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidParameterException, __BaseException>
  );
}
export declare class InvalidTagException extends __BaseException {
  readonly name: "InvalidTagException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidTagException, __BaseException>
  );
}
export declare class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>
  );
}
export declare class TagPolicyException extends __BaseException {
  readonly name: "TagPolicyException";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<TagPolicyException, __BaseException>);
}
export declare class ThrottlingException extends __BaseException {
  readonly name: "ThrottlingException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ThrottlingException, __BaseException>
  );
}
export declare class TooManyTagsException extends __BaseException {
  readonly name: "TooManyTagsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<TooManyTagsException, __BaseException>
  );
}
export declare const RecordType: {
  readonly CNAME: "CNAME";
};
export type RecordType = (typeof RecordType)[keyof typeof RecordType];
export interface ResourceRecord {
  Name: string | undefined;
  Type: RecordType | undefined;
  Value: string | undefined;
}
export declare const ValidationMethod: {
  readonly DNS: "DNS";
  readonly EMAIL: "EMAIL";
};
export type ValidationMethod =
  (typeof ValidationMethod)[keyof typeof ValidationMethod];
export declare const DomainStatus: {
  readonly FAILED: "FAILED";
  readonly PENDING_VALIDATION: "PENDING_VALIDATION";
  readonly SUCCESS: "SUCCESS";
};
export type DomainStatus = (typeof DomainStatus)[keyof typeof DomainStatus];
export interface DomainValidation {
  DomainName: string | undefined;
  ValidationEmails?: string[];
  ValidationDomain?: string;
  ValidationStatus?: DomainStatus;
  ResourceRecord?: ResourceRecord;
  ValidationMethod?: ValidationMethod;
}
export declare const ExtendedKeyUsageName: {
  readonly ANY: "ANY";
  readonly CODE_SIGNING: "CODE_SIGNING";
  readonly CUSTOM: "CUSTOM";
  readonly EMAIL_PROTECTION: "EMAIL_PROTECTION";
  readonly IPSEC_END_SYSTEM: "IPSEC_END_SYSTEM";
  readonly IPSEC_TUNNEL: "IPSEC_TUNNEL";
  readonly IPSEC_USER: "IPSEC_USER";
  readonly NONE: "NONE";
  readonly OCSP_SIGNING: "OCSP_SIGNING";
  readonly TIME_STAMPING: "TIME_STAMPING";
  readonly TLS_WEB_CLIENT_AUTHENTICATION: "TLS_WEB_CLIENT_AUTHENTICATION";
  readonly TLS_WEB_SERVER_AUTHENTICATION: "TLS_WEB_SERVER_AUTHENTICATION";
};
export type ExtendedKeyUsageName =
  (typeof ExtendedKeyUsageName)[keyof typeof ExtendedKeyUsageName];
export interface ExtendedKeyUsage {
  Name?: ExtendedKeyUsageName;
  OID?: string;
}
export declare const FailureReason: {
  readonly ADDITIONAL_VERIFICATION_REQUIRED: "ADDITIONAL_VERIFICATION_REQUIRED";
  readonly CAA_ERROR: "CAA_ERROR";
  readonly DOMAIN_NOT_ALLOWED: "DOMAIN_NOT_ALLOWED";
  readonly DOMAIN_VALIDATION_DENIED: "DOMAIN_VALIDATION_DENIED";
  readonly INVALID_PUBLIC_DOMAIN: "INVALID_PUBLIC_DOMAIN";
  readonly NO_AVAILABLE_CONTACTS: "NO_AVAILABLE_CONTACTS";
  readonly OTHER: "OTHER";
  readonly PCA_ACCESS_DENIED: "PCA_ACCESS_DENIED";
  readonly PCA_INVALID_ARGS: "PCA_INVALID_ARGS";
  readonly PCA_INVALID_ARN: "PCA_INVALID_ARN";
  readonly PCA_INVALID_DURATION: "PCA_INVALID_DURATION";
  readonly PCA_INVALID_STATE: "PCA_INVALID_STATE";
  readonly PCA_LIMIT_EXCEEDED: "PCA_LIMIT_EXCEEDED";
  readonly PCA_NAME_CONSTRAINTS_VALIDATION: "PCA_NAME_CONSTRAINTS_VALIDATION";
  readonly PCA_REQUEST_FAILED: "PCA_REQUEST_FAILED";
  readonly PCA_RESOURCE_NOT_FOUND: "PCA_RESOURCE_NOT_FOUND";
  readonly SLR_NOT_FOUND: "SLR_NOT_FOUND";
};
export type FailureReason = (typeof FailureReason)[keyof typeof FailureReason];
export declare const KeyAlgorithm: {
  readonly EC_prime256v1: "EC_prime256v1";
  readonly EC_secp384r1: "EC_secp384r1";
  readonly EC_secp521r1: "EC_secp521r1";
  readonly RSA_1024: "RSA_1024";
  readonly RSA_2048: "RSA_2048";
  readonly RSA_3072: "RSA_3072";
  readonly RSA_4096: "RSA_4096";
};
export type KeyAlgorithm = (typeof KeyAlgorithm)[keyof typeof KeyAlgorithm];
export declare const KeyUsageName: {
  readonly ANY: "ANY";
  readonly CERTIFICATE_SIGNING: "CERTIFICATE_SIGNING";
  readonly CRL_SIGNING: "CRL_SIGNING";
  readonly CUSTOM: "CUSTOM";
  readonly DATA_ENCIPHERMENT: "DATA_ENCIPHERMENT";
  readonly DECIPHER_ONLY: "DECIPHER_ONLY";
  readonly DIGITAL_SIGNATURE: "DIGITAL_SIGNATURE";
  readonly ENCHIPER_ONLY: "ENCIPHER_ONLY";
  readonly KEY_AGREEMENT: "KEY_AGREEMENT";
  readonly KEY_ENCIPHERMENT: "KEY_ENCIPHERMENT";
  readonly NON_REPUDATION: "NON_REPUDIATION";
};
export type KeyUsageName = (typeof KeyUsageName)[keyof typeof KeyUsageName];
export interface KeyUsage {
  Name?: KeyUsageName;
}
export declare const CertificateTransparencyLoggingPreference: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type CertificateTransparencyLoggingPreference =
  (typeof CertificateTransparencyLoggingPreference)[keyof typeof CertificateTransparencyLoggingPreference];
export interface CertificateOptions {
  CertificateTransparencyLoggingPreference?: CertificateTransparencyLoggingPreference;
}
export declare const RenewalEligibility: {
  readonly ELIGIBLE: "ELIGIBLE";
  readonly INELIGIBLE: "INELIGIBLE";
};
export type RenewalEligibility =
  (typeof RenewalEligibility)[keyof typeof RenewalEligibility];
export declare const RenewalStatus: {
  readonly FAILED: "FAILED";
  readonly PENDING_AUTO_RENEWAL: "PENDING_AUTO_RENEWAL";
  readonly PENDING_VALIDATION: "PENDING_VALIDATION";
  readonly SUCCESS: "SUCCESS";
};
export type RenewalStatus = (typeof RenewalStatus)[keyof typeof RenewalStatus];
export interface RenewalSummary {
  RenewalStatus: RenewalStatus | undefined;
  DomainValidationOptions: DomainValidation[] | undefined;
  RenewalStatusReason?: FailureReason;
  UpdatedAt: Date | undefined;
}
export declare const RevocationReason: {
  readonly AFFILIATION_CHANGED: "AFFILIATION_CHANGED";
  readonly A_A_COMPROMISE: "A_A_COMPROMISE";
  readonly CA_COMPROMISE: "CA_COMPROMISE";
  readonly CERTIFICATE_HOLD: "CERTIFICATE_HOLD";
  readonly CESSATION_OF_OPERATION: "CESSATION_OF_OPERATION";
  readonly KEY_COMPROMISE: "KEY_COMPROMISE";
  readonly PRIVILEGE_WITHDRAWN: "PRIVILEGE_WITHDRAWN";
  readonly REMOVE_FROM_CRL: "REMOVE_FROM_CRL";
  readonly SUPERCEDED: "SUPERCEDED";
  readonly UNSPECIFIED: "UNSPECIFIED";
};
export type RevocationReason =
  (typeof RevocationReason)[keyof typeof RevocationReason];
export declare const CertificateStatus: {
  readonly EXPIRED: "EXPIRED";
  readonly FAILED: "FAILED";
  readonly INACTIVE: "INACTIVE";
  readonly ISSUED: "ISSUED";
  readonly PENDING_VALIDATION: "PENDING_VALIDATION";
  readonly REVOKED: "REVOKED";
  readonly VALIDATION_TIMED_OUT: "VALIDATION_TIMED_OUT";
};
export type CertificateStatus =
  (typeof CertificateStatus)[keyof typeof CertificateStatus];
export declare const CertificateType: {
  readonly AMAZON_ISSUED: "AMAZON_ISSUED";
  readonly IMPORTED: "IMPORTED";
  readonly PRIVATE: "PRIVATE";
};
export type CertificateType =
  (typeof CertificateType)[keyof typeof CertificateType];
export interface CertificateDetail {
  CertificateArn?: string;
  DomainName?: string;
  SubjectAlternativeNames?: string[];
  DomainValidationOptions?: DomainValidation[];
  Serial?: string;
  Subject?: string;
  Issuer?: string;
  CreatedAt?: Date;
  IssuedAt?: Date;
  ImportedAt?: Date;
  Status?: CertificateStatus;
  RevokedAt?: Date;
  RevocationReason?: RevocationReason;
  NotBefore?: Date;
  NotAfter?: Date;
  KeyAlgorithm?: KeyAlgorithm;
  SignatureAlgorithm?: string;
  InUseBy?: string[];
  FailureReason?: FailureReason;
  Type?: CertificateType;
  RenewalSummary?: RenewalSummary;
  KeyUsages?: KeyUsage[];
  ExtendedKeyUsages?: ExtendedKeyUsage[];
  CertificateAuthorityArn?: string;
  RenewalEligibility?: RenewalEligibility;
  Options?: CertificateOptions;
}
export declare class ConflictException extends __BaseException {
  readonly name: "ConflictException";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
}
export interface DeleteCertificateRequest {
  CertificateArn: string | undefined;
}
export declare class ResourceInUseException extends __BaseException {
  readonly name: "ResourceInUseException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ResourceInUseException, __BaseException>
  );
}
export interface DescribeCertificateRequest {
  CertificateArn: string | undefined;
}
export interface DescribeCertificateResponse {
  Certificate?: CertificateDetail;
}
export interface ExportCertificateRequest {
  CertificateArn: string | undefined;
  Passphrase: Uint8Array | undefined;
}
export interface ExportCertificateResponse {
  Certificate?: string;
  CertificateChain?: string;
  PrivateKey?: string;
}
export declare class RequestInProgressException extends __BaseException {
  readonly name: "RequestInProgressException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<RequestInProgressException, __BaseException>
  );
}
export interface ExpiryEventsConfiguration {
  DaysBeforeExpiry?: number;
}
export interface GetAccountConfigurationResponse {
  ExpiryEvents?: ExpiryEventsConfiguration;
}
export interface GetCertificateRequest {
  CertificateArn: string | undefined;
}
export interface GetCertificateResponse {
  Certificate?: string;
  CertificateChain?: string;
}
export interface ImportCertificateRequest {
  CertificateArn?: string;
  Certificate: Uint8Array | undefined;
  PrivateKey: Uint8Array | undefined;
  CertificateChain?: Uint8Array;
  Tags?: Tag[];
}
export interface ImportCertificateResponse {
  CertificateArn?: string;
}
export declare class LimitExceededException extends __BaseException {
  readonly name: "LimitExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LimitExceededException, __BaseException>
  );
}
export declare class InvalidArgsException extends __BaseException {
  readonly name: "InvalidArgsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidArgsException, __BaseException>
  );
}
export interface Filters {
  extendedKeyUsage?: ExtendedKeyUsageName[];
  keyUsage?: KeyUsageName[];
  keyTypes?: KeyAlgorithm[];
}
export declare const SortBy: {
  readonly CREATED_AT: "CREATED_AT";
};
export type SortBy = (typeof SortBy)[keyof typeof SortBy];
export declare const SortOrder: {
  readonly ASCENDING: "ASCENDING";
  readonly DESCENDING: "DESCENDING";
};
export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];
export interface ListCertificatesRequest {
  CertificateStatuses?: CertificateStatus[];
  Includes?: Filters;
  NextToken?: string;
  MaxItems?: number;
  SortBy?: SortBy;
  SortOrder?: SortOrder;
}
export interface CertificateSummary {
  CertificateArn?: string;
  DomainName?: string;
  SubjectAlternativeNameSummaries?: string[];
  HasAdditionalSubjectAlternativeNames?: boolean;
  Status?: CertificateStatus;
  Type?: CertificateType;
  KeyAlgorithm?: KeyAlgorithm;
  KeyUsages?: KeyUsageName[];
  ExtendedKeyUsages?: ExtendedKeyUsageName[];
  InUse?: boolean;
  Exported?: boolean;
  RenewalEligibility?: RenewalEligibility;
  NotBefore?: Date;
  NotAfter?: Date;
  CreatedAt?: Date;
  IssuedAt?: Date;
  ImportedAt?: Date;
  RevokedAt?: Date;
}
export interface ListCertificatesResponse {
  NextToken?: string;
  CertificateSummaryList?: CertificateSummary[];
}
export declare class ValidationException extends __BaseException {
  readonly name: "ValidationException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ValidationException, __BaseException>
  );
}
export interface ListTagsForCertificateRequest {
  CertificateArn: string | undefined;
}
export interface ListTagsForCertificateResponse {
  Tags?: Tag[];
}
export interface PutAccountConfigurationRequest {
  ExpiryEvents?: ExpiryEventsConfiguration;
  IdempotencyToken: string | undefined;
}
export interface RemoveTagsFromCertificateRequest {
  CertificateArn: string | undefined;
  Tags: Tag[] | undefined;
}
export interface RenewCertificateRequest {
  CertificateArn: string | undefined;
}
export declare class InvalidDomainValidationOptionsException extends __BaseException {
  readonly name: "InvalidDomainValidationOptionsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidDomainValidationOptionsException,
      __BaseException
    >
  );
}
export interface DomainValidationOption {
  DomainName: string | undefined;
  ValidationDomain: string | undefined;
}
export interface RequestCertificateRequest {
  DomainName: string | undefined;
  ValidationMethod?: ValidationMethod;
  SubjectAlternativeNames?: string[];
  IdempotencyToken?: string;
  DomainValidationOptions?: DomainValidationOption[];
  Options?: CertificateOptions;
  CertificateAuthorityArn?: string;
  Tags?: Tag[];
  KeyAlgorithm?: KeyAlgorithm;
}
export interface RequestCertificateResponse {
  CertificateArn?: string;
}
export declare class InvalidStateException extends __BaseException {
  readonly name: "InvalidStateException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidStateException, __BaseException>
  );
}
export interface ResendValidationEmailRequest {
  CertificateArn: string | undefined;
  Domain: string | undefined;
  ValidationDomain: string | undefined;
}
export interface UpdateCertificateOptionsRequest {
  CertificateArn: string | undefined;
  Options: CertificateOptions | undefined;
}
export declare const ExportCertificateRequestFilterSensitiveLog: (
  obj: ExportCertificateRequest
) => any;
export declare const ExportCertificateResponseFilterSensitiveLog: (
  obj: ExportCertificateResponse
) => any;
export declare const ImportCertificateRequestFilterSensitiveLog: (
  obj: ImportCertificateRequest
) => any;
